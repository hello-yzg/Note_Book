<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>两数相加</title>
    <link href="/2023/a85684359d52/"/>
    <url>/2023/a85684359d52/</url>
    
    <content type="html"><![CDATA[<h3 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h3><blockquote><p>C++ Tips</p><ol><li><p>new 的返回类型为指针，执行构造函数</p></li><li><p>C++11引入参数列表构造（类与结构体）</p></li></ol><p>Java Tips</p><ol><li>new的返回类型为引用，执行构造函数</li></ol></blockquote><p>题目：</p><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><h4 id="链表遍历"><a href="#链表遍历" class="headerlink" title="链表遍历"></a>链表遍历</h4><p>时间复杂度：O(<em>n</em>)</p><p>空间复杂度：O(<em>1</em>)</p><h5 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//c++</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        <span class="hljs-keyword">auto</span> cur = dummy; <span class="hljs-comment">// cur用于指针操作，dummy用于指针返回</span><br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>; <span class="hljs-comment">// 进位</span><br>        <span class="hljs-keyword">while</span>(l1 || l2 || carry)&#123; <span class="hljs-comment">// 指针操作未完成或存在进位</span><br>             carry += (l1 ? l1-&gt;val : <span class="hljs-number">0</span>) + (l2 ? l2-&gt;val : <span class="hljs-number">0</span>); <br>             cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(carry % <span class="hljs-number">10</span>); <span class="hljs-comment">// 计算存储值</span><br>             carry /= <span class="hljs-number">10</span>; <span class="hljs-comment">// 计算进位值</span><br>             <span class="hljs-keyword">if</span> (l1) l1 = l1-&gt;next;<br>             <span class="hljs-keyword">if</span> (l2) l2 = l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy; <span class="hljs-comment">//对同一个对象的引用</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span> || carry != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">null</span>) carry += l1.val;<br>            <span class="hljs-keyword">if</span>(l2 != <span class="hljs-literal">null</span>) carry += l2.val;<br>            cur = cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry % <span class="hljs-number">10</span>);<br>            carry /= <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">null</span>) l1 = l1.next;<br>            <span class="hljs-keyword">if</span>(l2 != <span class="hljs-literal">null</span>) l2 = l2.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#python3</span><br><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params">self, l1: <span class="hljs-type">Optional</span>[ListNode], l2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        cur = dummy = ListNode()<br>        carry = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2 <span class="hljs-keyword">or</span> carry:<br>            carry += (l1.val <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>) + (l2.val <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)<br>            cur.<span class="hljs-built_in">next</span> = ListNode(carry % <span class="hljs-number">10</span>)<br>            carry //= <span class="hljs-number">10</span><br>            cur = cur.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> l1: l1 = l1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> l2: l2 = l2.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h5 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//c</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* l1, <span class="hljs-keyword">struct</span> ListNode* l2)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">dummy</span> =</span> (<span class="hljs-keyword">struct</span> ListNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode)); <span class="hljs-comment">// 哑节点(dummy node)</span><br>dummy-&gt;val = <span class="hljs-number">0</span>;<br>dummy-&gt;next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">cur</span> =</span> dummy;<br><span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (l1 || l2 || carry)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">temp</span> =</span> (<span class="hljs-keyword">struct</span> ListNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));<br>        carry += (l1 ? l1-&gt;val : <span class="hljs-number">0</span>) + (l2 ? l2-&gt;val : <span class="hljs-number">0</span>);<br>temp-&gt;val = carry % <span class="hljs-number">10</span>;<br>temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>cur-&gt;next = temp;<br><br>cur = cur-&gt;next;<br>carry = carry / <span class="hljs-number">10</span>;<br>l1 = l1 ? l1-&gt;next : <span class="hljs-literal">NULL</span>;<br>l2 = l2 ? l2-&gt;next : <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//javascript</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">l1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">l2</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) &#123;<br>    <span class="hljs-keyword">let</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(); <br>    <span class="hljs-keyword">let</span> cur = dummy;<br>    <span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">while</span> (l1 || l2 || carry) &#123;<br>        <span class="hljs-keyword">if</span> (l1) carry += l1.<span class="hljs-property">val</span>; <br>        <span class="hljs-keyword">if</span> (l2) carry += l2.<span class="hljs-property">val</span>; <br>        cur = cur.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry % <span class="hljs-number">10</span>); <br>        carry = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(carry / <span class="hljs-number">10</span>); <br>        <span class="hljs-keyword">if</span> (l1) l1 = l1.<span class="hljs-property">next</span>; <br>        <span class="hljs-keyword">if</span> (l2) l2 = l2.<span class="hljs-property">next</span>; <br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>; <br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>基础：两数相加</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>延迟变量扩展</title>
    <link href="/2023/372e22d3c82a/"/>
    <url>/2023/372e22d3c82a/</url>
    
    <content type="html"><![CDATA[<h3 id="延迟变量扩展"><a href="#延迟变量扩展" class="headerlink" title="延迟变量扩展"></a>延迟变量扩展</h3><p>在使用批处理进行文件遍历时，由于文件路径使用了延迟变量扩展导致路径定位失败，代码如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs powershell">@<span class="hljs-built_in">echo</span> off &amp; setlocal enabledelayedexpansion<br><br>rem 省略具体路径<br><span class="hljs-built_in">set</span> path=......<br><br>call :Test !path!<br><br>pause<br><br>:TestMethod<br><span class="hljs-built_in">set</span> arg1=%~<span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> exist !arg1! (<br>    <span class="hljs-keyword">for</span> /<span class="hljs-built_in">R</span> !arg1! %%F <span class="hljs-keyword">in</span> (\*) <span class="hljs-keyword">do</span> (<br>        <span class="hljs-keyword">if</span> not %%~nxF==test.bat (<br>            <span class="hljs-built_in">del</span> %%F /q<br>        )<br>    )<br>)<br>goto :eof<br></code></pre></td></tr></table></figure><p>代码非常简单，使用延迟变量扩展和标签传入路径，递归遍历，删除test.bat外的所有文件。原则上开启了延迟变量后——setlocal enabledelayedexpansion，变量引用就应该使用 !*!，但奇怪的是，对于12行，可以正确执行，但对于13行，就无法定位路径，多次测试还发现以下信息：</p><ul><li>将13行中的延迟变量扩展更改为变量扩展，即%arg1%，问题消失</li><li>将13行中的遍历目标改为文件夹，问题消失</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">...<br><span class="hljs-keyword">for</span> /D %%F <span class="hljs-keyword">in</span> (!arg1!\*) <span class="hljs-keyword">do</span> (<br>...<br></code></pre></td></tr></table></figure><p>总而言之，现有的语法规则无法解释上述现象，多方查阅依然没有定论，记录在这里，希望未来可以得到解答。</p>]]></content>
    
    
    <categories>
      
      <category>批处理</category>
      
      <category>基础：变量扩展</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2023/70527323af9f/"/>
    <url>/2023/70527323af9f/</url>
    
    <content type="html"><![CDATA[<h3 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1. 线性表"></a>1. 线性表</h3><ul><li><p>C&#x2F;C++ 中，malloc 的结果为 void* , 因此需进行强制类型转换。</p></li><li><p>链表表头节点的优势：简化操作，具体表现在：</p><ul><li>起点稳定</li><li>便于判空</li><li>统一化操作（增删链表首元素无需进行特殊处理）</li></ul></li><li><p>从freelist理解为什么新申请的内存会有脏数据，即变量初始化的必要性。</p></li><li><p>两种实现方式的根本区别（基于下标）：</p><table><thead><tr><th align="center"></th><th align="center">顺序表n</th><th align="center">单链表n</th></tr></thead><tbody><tr><td align="center">增删</td><td align="center">顺序插入     O (n)</td><td align="center">随机插入      O (1)</td></tr><tr><td align="center">改查</td><td align="center">随机查找     O (1)</td><td align="center">顺序查找      O (n)</td></tr></tbody></table></li><li><p>单链表的典型操作代码（指针基础）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义单链表节点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><br>ElemType data;         <span class="hljs-comment">//数据域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>* <span class="hljs-title">link</span>;</span>    <span class="hljs-comment">//指针域</span><br>&#125;* LinkList;<br><br><span class="hljs-comment">//插入</span><br>Status <span class="hljs-title function_">Insert</span> <span class="hljs-params">(LNode *L, LNode *p, ElemType item)</span><br>&#123;<br>    LNode *temp;<br>    temp = (LNode *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    <span class="hljs-keyword">if</span>(temp == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">else</span> temp-&gt;data = item;<br>    temp-&gt;link = p-&gt;link;<br>    p-&gt;link = temp;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//删除</span><br>Status <span class="hljs-title function_">Delete</span> <span class="hljs-params">(LNode *L, LNode *p, ElemType *item)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(L == <span class="hljs-literal">NULL</span> || p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>    *item = p-&gt;link-&gt;data;<br>    p-&gt;link = p-&gt;link-&gt;link;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-栈，队列和数组"><a href="#2-栈，队列和数组" class="headerlink" title="2. 栈，队列和数组"></a>2. 栈，队列和数组</h3><ul><li><p>循环队列中，由于入队时队尾指针追赶头指针，出队时头指针追赶队尾指针，因此队空与队满时头尾指针相对位置相同（重合），最常见的修改方式为：设定 length 为 n 的队列存储上限为 n-1。</p></li><li><p>栈的应用（利用先进先出的特点）：</p><ul><li>表达式中括号的匹配检查</li><li>计算后缀表达式</li></ul></li><li><p>队列的应用：</p><ul><li>二叉树的层序遍历（后续章节介绍）</li></ul></li><li><p>特殊矩阵的压缩存储（地址转换式）</p><p><strong>推导思想为算出 i 前一行为止的项数，加上 i 行的偏移量。</strong></p><ul><li><p>上三角矩阵（首项：n尾项：n - i + 1项数：i偏移量：j - i          ） $[(n+n-i+1)*i]&#x2F;2 + j-i$</p></li><li><p>下三角矩阵（首项：1尾项：i            项数：i偏移量：j              ） $[(1+i)*i]&#x2F;2 + j $</p></li><li><p>三对角矩阵（差值：1行项：3           项数：i偏移量：j - i + 1   ） $3i-1 + j-i+1$</p></li></ul></li></ul><center style="color:#C0C0C0">图1</center><h3 id="3-树与二叉树"><a href="#3-树与二叉树" class="headerlink" title="3. 树与二叉树"></a>3. 树与二叉树</h3><ul><li><p>树结构本身是一个递归的结构。</p></li><li><p>含$n$个节点的树中，边数为$n-1$（由根节点出发，每个节点都需要一条边与之相连）。</p></li><li><p>节点所在层数 &#x3D; 路径长度 &#x3D; 节点深$(i&gt;&#x3D;0)$,  $i_{max} + 1 &#x3D; 树高（h&gt;&#x3D;1)$。</p></li><li><p>满二叉树教材定义有分歧（建议以定义一为主）：</p><ul><li>定义一：所有分支节点度均为 2，叶i子节点处在同一层</li><li>定义二：仅有度为 2 和 0 的节点</li></ul></li><li><p>完全二叉树：$0 \sim h-1$ 层为满二叉树，$h$层节点靠左排列。&#x3D;&#x3D;这里会混淆层数与高度，会意即可&#x3D;&#x3D;</p></li><li><p>二叉树的一些数学性质依赖等比数列求和公式（首项为1，公比为2）：</p><ul><li>第 i 层最大节点数：$2^i (i&gt;&#x3D;0)$</li><li>高度为 h 最大节点总数： $2^h-1 (h&gt;&#x3D;1)$</li></ul></li></ul><blockquote><p>公比为q的等比数列前n项和：$S_n&#x3D;\frac{a_1(1-q^n)}{1-q}$, 通过错位相减法证明</p></blockquote><ul><li>具有 n 个节点的完全二叉树高为：$\lceil \log_2(n+1) \rceil$。</li></ul><blockquote><p>$2^{h-1}-1 &lt; n \le 2^h-1$<br>$2^{h-1} &lt; n+1 \le 2^h$<br>$h-1 &lt; log_2(n+1) \le h$<br>$log_2(n+1) \le h &lt; log_2(n+1)+1$</p><p>$\therefore h &#x3D; \lceil \log_2(n+1) \rceil$</p></blockquote><ul><li>对于任意二叉树，有叶节点数为 $n_0$, 度为 1 的节点数为$n_1$, 度为 2 的节点数为$n_2$, 则 $n_0&#x3D;n_2+1$。</li></ul><blockquote><p>记二叉树边数为 b</p><p>$b&#x3D;n-1&#x3D;n_0+n_1+n_2-1$</p><p>$b&#x3D;2n_2+n_1$</p><p>$n_0+n_1+n_2-1&#x3D;2n_2+n_1$</p><p>$\therefore n_0&#x3D;n_2+1$</p></blockquote><ul><li>满二叉树定理可推广至k叉树：$n_0&#x3D;\sum_{i&#x3D;2}^k(i-1)n_i+1$</li><li>完全二叉树的顺序存储（高度$h\ge1$, 层数$i\ge0$）<ul><li>根节点存储在$A[0]$, 数组大小为$2^h-1$</li><li>$A[i]$， 左子节点为$A[2i+1]$，右子节点为$A[2i+2]$</li></ul></li></ul><blockquote><p>假设$A[i]$左子节点是最后一个节点，即通过满二叉树定理可得叶节点数为$i+1$</p><p>$\therefore 左子节点地址&#x3D; i+叶子节点数&#x3D;i+(i+1)&#x3D;2i+1$</p><p>假设$A[i]$右子节点是最后一个节点，即通过满二叉树定理可得叶节点数为$i+1+1$（$A[i]$度也为2）</p><p>$\therefore 右子节点地址&#x3D; i+叶子节点数&#x3D;i+(i+1+1)&#x3D;2i+2$</p></blockquote><ul><li>二叉树的链式存储（二叉链表）定义：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinNode</span>&#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinNode</span>* <span class="hljs-title">lchild</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinNode</span>* <span class="hljs-title">rchild</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在$2n$个指针域中，有$n-1$个非空指针域（边），有$n+1$个空指针域。</li><li>三叉链表对比二叉链表多了一个用来存储 parent 的指针域。</li><li>二叉树必须给定中序遍历序列 + 先序遍历序列 &#x2F; 后序遍历序列，才可确定唯一的树结构。（依赖中序序列分割左右子树）</li><li>二叉树进行递归遍历时，利用叶子节点的空指针域记录直接前驱与直接后继的地址，这样在进行一次遍历的同时也对树进行了线索化，之后再遍历时将不再需要递归，而是根据线索指针线性遍历即可。</li><li>树的  “左孩子右兄弟” 二叉链表（与 “子节点” 二叉链表不同）存储方式，为树与二叉树的转换提供了桥梁。</li><li>一棵树的后根遍历与这棵树所对应的二叉树的中序遍历相同。因为树转化为二叉树后是没有右子树的，所以最后访问的是树的根结点。</li><li>对于二叉排序树，在得到先序遍历序列 &#x2F; 后序遍历序列时，中序遍历序列是隐含的，因为有序性使得左子树值一定小于根节点，右子树值一定大于根节点，由此分割左右子树。</li><li>二叉排序树的查找效率在理想情况下为$O(log_2n)$, 相当于折半查找；但最坏情况下可能由于失衡而退化为线性树，查找时间复杂度为$O(n)$。</li><li>对二叉排序树进行插入或删除时，插入的对象一定是叶子节点，删除时如果度为 0 或 1，也相对简单，但删除度为 2 的节点时，由于需要维持树的有序性，要找到被删除节点的直接前驱（左子树的 “右下角”）或直接后继（右子树的 “左下角”）进行代替。</li><li>平衡二叉树（AVL树）在插入或删除时，需检查是否失衡：<ul><li>左子树左侧过长失衡 -&gt; 沿根节点右旋</li><li>左子树右侧过长失衡 -&gt; 先沿左子树节点左旋（转换为左子树左侧过长失衡），再沿根节点右旋</li><li>右子树左侧过长失衡 -&gt; 先沿右子树节点右旋（转换为右子树右侧过长失衡），再沿根节点左旋</li><li>右子树右侧过长失衡 -&gt; 沿根节点左旋</li></ul></li><li>等长编码：ASCII码（8位），Unicode（16位）；不等长编码：哈夫曼编码（通过哈夫曼算法构建哈夫曼树）。</li><li>哈夫曼译码：通过逐位扫描哈夫曼编码，0则进入哈夫曼树左分支，1则进入哈夫曼树右分支，直到扫描完成到达叶子节点读取译码，由于译码只存储在叶子节点中，因此具有前缀特性，即任何字符编码都不是其他任何字符编码的前缀。</li></ul><h3 id="4-图"><a href="#4-图" class="headerlink" title="4. 图"></a>4. 图</h3><ul><li>无向图的邻接矩阵为对称矩阵， $i$行或$i$列的非零元素个数为顶点$i$的度；对于有向图，$i$行的非零元素个数为顶点$i$的入度，$i$列的非零元素个数为顶点$i$的出度。</li><li>将邻接链表的表头元素使用数组存储的方法为邻接表。无向图顶点$i$对应的邻接链表结点个数为顶点$i$的度；对于有向图，顶点$i$对应的邻接链表结点个数为顶点$i$的出度，顶点$i$的入度需要遍历全部的邻接链表，为了方便，常引入逆邻接表。</li><li>邻接多重表避免了无向图的重复存储，有利于边的遍历处理。利用 mark 对边进行标记，利用 link 保存方向信息，本质为引入了指针域存储方向信息，因此不再对边进行重复存储。<ul><li>链表节点：| mark | vertex1 | link1 | vertex2 | link2 |</li></ul></li><li>在邻接多重表基础上，修改数组节点，增加入度与出度表头指针域，变为十字链表（本质为融合逆邻接表）。<ul><li>链表节点：| mark | vertex1 | link1 | vertex2 | link2 |</li><li>数组节点：| vertex | firin | firout |</li></ul></li><li>图的深度优先搜索（DFS）本质为递归，使用栈结构，得到图的各个连通分量，可用于构建连通树与最小DFS生成树。直观来看，DFS为沿当前路径不断遍历，直到无节点可访问时返回上一个 “岔路口” 。</li><li>图的广度优先搜索（BFS）本质为迭代，使用队列结构，得到图的各个连通分量，可用于构建连通树与最小BFS生成树。直观来看，BFS为先遍历最近距离的节点，直到无节点可访问时扩大遍历范围。</li><li>连通图 G &#x3D;（V,E）有 $\mid E \mid&gt; \mid V \mid -1$, 则说明图中存在回路，生成树不唯一，其中权值最小的生成树为 G 的最小生成树。</li><li>普利姆算法（Prim）</li></ul><blockquote><p>① 设图 T（U，{}）为连通图 G（V，E）的最小生成树，从顶点$v_i$开始，U&#x3D;{$v_i$}。</p><p>② 在所有$u\in U,v\in V-U$的边$(u,v)\in E$中选择一条权值最小的边$(u_i,v_j)$, 将$v_j$与$(u_i,v_j)$加入 T 中, 即$T&#x3D;T\bigcup({v_j},{(u_i,v_j)})$。</p><p>③ 重复②，直到 U &#x3D; V。</p></blockquote><p>​<img src="https://img.hello-yzg.cn/CS联考+%23+数据结构-001.png" style="zoom: 100%;" /></p><center style="color:#C0C0C0">图1</center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXEDGE 20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXVEX 20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIFINTY 65535</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> arc[MAXVEX][MAXVEX]; <span class="hljs-comment">//邻接矩阵</span><br>    <span class="hljs-type">int</span> numVertexes, numEdges;<br>&#125;MGraph;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构建图</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateMGraph</span><span class="hljs-params">(MGraph * G)</span>&#123;<br>    <br>    <span class="hljs-type">int</span> i, j;<br>    <br>    G-&gt;numVertexes = <span class="hljs-number">9</span>; <span class="hljs-comment">// 9个顶点</span><br>    G-&gt;numEdges = <span class="hljs-number">15</span>; <span class="hljs-comment">// 15条边</span><br>    <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;numVertexes; i++) &#123; <span class="hljs-comment">// 初始化图</span><br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; G-&gt;numVertexes; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i == j)<br>                G-&gt;arc[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>                G-&gt;arc[i][j] = G-&gt;arc[j][i] = INIFINTY;<br>        &#125;<br>    &#125;<br>    <br>    G-&gt;arc[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">10</span>;<br>    G-&gt;arc[<span class="hljs-number">0</span>][<span class="hljs-number">5</span>] = <span class="hljs-number">11</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">18</span>;<br>    G-&gt;arc[<span class="hljs-number">1</span>][<span class="hljs-number">8</span>] = <span class="hljs-number">12</span>;<br>    G-&gt;arc[<span class="hljs-number">1</span>][<span class="hljs-number">6</span>] = <span class="hljs-number">16</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">22</span>;<br>    G-&gt;arc[<span class="hljs-number">2</span>][<span class="hljs-number">8</span>] = <span class="hljs-number">8</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">20</span>;<br>    G-&gt;arc[<span class="hljs-number">3</span>][<span class="hljs-number">7</span>] = <span class="hljs-number">16</span>;<br>    G-&gt;arc[<span class="hljs-number">3</span>][<span class="hljs-number">6</span>] = <span class="hljs-number">24</span>;<br>    G-&gt;arc[<span class="hljs-number">3</span>][<span class="hljs-number">8</span>] = <span class="hljs-number">21</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">4</span>][<span class="hljs-number">5</span>] = <span class="hljs-number">26</span>;<br>    G-&gt;arc[<span class="hljs-number">4</span>][<span class="hljs-number">7</span>] = <span class="hljs-number">7</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>] = <span class="hljs-number">17</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">6</span>][<span class="hljs-number">7</span>] = <span class="hljs-number">19</span>;<br>    <br>    <span class="hljs-comment">// 利用邻接矩阵的对称性</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;numVertexes; i++)<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; G-&gt;numVertexes; j++)<br>            G-&gt;arc[j][i] = G-&gt;arc[i][j];<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Prime算法生成最小生成树</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MiniSpanTree_Prim</span><span class="hljs-params">(MGraph G)</span>&#123;<br>    <br>    <span class="hljs-type">int</span> min,i,j,k;<br>    <br>    <span class="hljs-comment">// 利用两个数组，保存边依附点与边的权值（生成树扩张新顶点可选择的边）</span><br>    <span class="hljs-type">int</span> adjvex[MAXVEX]; <span class="hljs-comment">// 保存最新的依附点集</span><br>    <span class="hljs-type">int</span> lowcost[MAXVEX]; <span class="hljs-comment">// 保存最新的权值集，数组下标为边的另一个依附点</span><br>    <br>    adjvex[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化，第一个顶点v0</span><br>    lowcost[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化, 第一个权值为0，即v0加入生成树</span><br>    <br>    <span class="hljs-comment">// 遍历v0之外的顶点</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; G.numVertexes; i++) &#123;<br>        adjvex[i] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 更新依附点集</span><br>        lowcost[i] = G.arc[<span class="hljs-number">0</span>][i];  <span class="hljs-comment">// 更新权值集</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 进行 numVertexes-1 次循环，锁定 numVertexes-1 条边</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; G.numVertexes; i++) &#123;<br>        min = INIFINTY; <span class="hljs-comment">// 初始化最小权值</span><br>        j = <span class="hljs-number">1</span>;<br>        k = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 找到当前权值集中的最小值</span><br>        <span class="hljs-keyword">while</span> (j &lt; G.numVertexes) &#123; <br>            <span class="hljs-keyword">if</span> (lowcost[j] != <span class="hljs-number">0</span> &amp;&amp; lowcost[j] &lt; min) &#123;<br>                min = lowcost[j];  <br>                k = j;  <span class="hljs-comment">// 将当前最小值对应的边依附点存入k</span><br>            &#125;<br>            j++;<br>        &#125;<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d, %d)\n&quot;</span>, adjvex[k], k); <span class="hljs-comment">// 打印锁定的权值最小的边</span><br>        lowcost[k] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 更新权值集，对应下标的权值记为0，即锁定了依附点，记为已处理</span><br>        <br>        <span class="hljs-comment">// 锁定边后，顶点k加入，生成树发生变化，需要更新依附点集和权值集</span><br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt; G.numVertexes; j++) &#123;  <br>            <br>            <span class="hljs-comment">// 比较从k点出发的扩张权，如果更小，则更新</span><br>            <span class="hljs-keyword">if</span> (lowcost[j]!= <span class="hljs-number">0</span> &amp;&amp; G.arc[k][j] &lt; lowcost[j]) &#123;<br>                adjvex[j] = k; <span class="hljs-comment">// 更新依附点k</span><br>                lowcost[j] = G.arc[k][j]; <span class="hljs-comment">// 将更小的权值存入lowcost对应位置</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span> &#123;<br>    <br>    MGraph G;<br>    CreateMGraph(&amp;G);<br>    MiniSpanTree_Prim(G);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">代码输出:</span><br><span class="hljs-comment">(0,1)</span><br><span class="hljs-comment">(0,5)</span><br><span class="hljs-comment">(1,8)</span><br><span class="hljs-comment">(8,2)</span><br><span class="hljs-comment">(1,6)</span><br><span class="hljs-comment">(6,7)</span><br><span class="hljs-comment">(7,4)</span><br><span class="hljs-comment">(7,3)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li>克鲁斯卡尔算法（Kruskal）</li></ul><blockquote><p>① 设图 T（V，{}）为连通图 G（V，E）的最小生成树，T 中每个顶点自成连通分量。</p><p>② 在 E 中选择权值最小的边，若该边的两个顶点落在 T 中不同的连通分量上，则将此边加入 T，否则舍弃该边。</p><p>③ 重复②，直到 T 中所有顶点在同一连通分量上。</p></blockquote><p>​<img src="https://img.hello-yzg.cn/CS联考+%23+数据结构-002.png" style="zoom: 100%;" /></p><center style="color:#C0C0C0">图2</center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXEDGE 20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXVEX 20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIFINTY 65535</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> arc[MAXVEX][MAXVEX]; <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-type">int</span> numVertexes, numEdges;<br>&#125;MGraph;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">// 边集数组</span><br>    <span class="hljs-type">int</span> begin;<br>    <span class="hljs-type">int</span> end;<br>    <span class="hljs-type">int</span> weight;<br>&#125;Edge;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构建图</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateMGraph</span><span class="hljs-params">(MGraph * G)</span>&#123;<br>    <br>    <span class="hljs-type">int</span> i, j;<br>    <br>    G-&gt;numVertexes = <span class="hljs-number">9</span>; <span class="hljs-comment">// 9个顶点</span><br>    G-&gt;numEdges = <span class="hljs-number">15</span>; <span class="hljs-comment">// 15条边</span><br>    <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;numVertexes; i++) &#123; <span class="hljs-comment">// 初始化图</span><br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; G-&gt;numVertexes; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i == j)<br>                G-&gt;arc[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>                G-&gt;arc[i][j] = G-&gt;arc[j][i] = INIFINTY;<br>        &#125;<br>    &#125;<br>    <br>    G-&gt;arc[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">10</span>;<br>    G-&gt;arc[<span class="hljs-number">0</span>][<span class="hljs-number">5</span>] = <span class="hljs-number">11</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">18</span>;<br>    G-&gt;arc[<span class="hljs-number">1</span>][<span class="hljs-number">8</span>] = <span class="hljs-number">12</span>;<br>    G-&gt;arc[<span class="hljs-number">1</span>][<span class="hljs-number">6</span>] = <span class="hljs-number">16</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">22</span>;<br>    G-&gt;arc[<span class="hljs-number">2</span>][<span class="hljs-number">8</span>] = <span class="hljs-number">8</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">20</span>;<br>    G-&gt;arc[<span class="hljs-number">3</span>][<span class="hljs-number">7</span>] = <span class="hljs-number">16</span>;<br>    G-&gt;arc[<span class="hljs-number">3</span>][<span class="hljs-number">6</span>] = <span class="hljs-number">24</span>;<br>    G-&gt;arc[<span class="hljs-number">3</span>][<span class="hljs-number">8</span>] = <span class="hljs-number">21</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">4</span>][<span class="hljs-number">5</span>] = <span class="hljs-number">26</span>;<br>    G-&gt;arc[<span class="hljs-number">4</span>][<span class="hljs-number">7</span>] = <span class="hljs-number">7</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>] = <span class="hljs-number">17</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">6</span>][<span class="hljs-number">7</span>] = <span class="hljs-number">19</span>;<br>    <br>    <span class="hljs-comment">// 利用邻接矩阵的对称性</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;numVertexes; i++)<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; G-&gt;numVertexes; j++)<br>            G-&gt;arc[j][i] = G-&gt;arc[i][j];<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 交换头、尾、权值，用于边集的有序化（采取冒泡排序）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Swapn</span><span class="hljs-params">(Edge * edges, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>    <br>    <span class="hljs-type">int</span> temp;<br>    temp = edges[i].begin;<br>    edges[i].begin = edges[j].begin;<br>    edges[j].begin = temp;<br>    <br>    temp = edges[i].end;<br>    edges[i].end = edges[j].end;<br>    edges[j].end = temp;<br>    <br>    temp = edges[i].weight;<br>    edges[i].weight = edges[j].weight;<br>    edges[j].weight = temp;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对权值进行排序——冒泡排序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Edge edges[], MGraph *G)</span>&#123;<br><br>    <span class="hljs-type">int</span> i,j;<br>    <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;  i &lt; G-&gt;numEdges; i++) &#123;<br>        <span class="hljs-keyword">for</span> (j = i+<span class="hljs-number">1</span>; j &lt; G-&gt;numEdges; j++) &#123;<br>            <span class="hljs-keyword">if</span> (edges[i].weight &gt; edges[j].weight)<br>                Swapn(edges, i, j);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;权值排序之后为：\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;  i &lt; G-&gt;numEdges; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d, %d) %d\n&quot;</span>, edges[i].begin, edges[i].end, edges[i].weight);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用 &quot;while&quot; 迭代查找连通分量的 &quot;最新顶点&quot; ，返回此顶点说明落在生成树连通分量中</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> * parent, <span class="hljs-type">int</span> f)</span>&#123;<br>    <br>    <span class="hljs-keyword">while</span> (parent[f] &gt; <span class="hljs-number">0</span>)<br>        f = parent[f];<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Kruskal算法生成最小生成树</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MiniSpanTree_Kruskal</span><span class="hljs-params">(MGraph G)</span>&#123;<br>    <br>    <span class="hljs-type">int</span> i,j,n,m;<br>    <br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>    <br>    Edge edges[MAXEDGE]; <span class="hljs-comment">// 定义边集数组</span><br>    <span class="hljs-type">int</span> parent[MAXVEX]; <span class="hljs-comment">// 定义连通分量判断数组来判断边与边是否形成回路</span><br>    <br>    <span class="hljs-comment">// 构建边集数组并排序</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G.numVertexes - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (j = i+<span class="hljs-number">1</span>; j &lt; G.numVertexes; j++) &#123;<br>            <span class="hljs-keyword">if</span> (G.arc[i][j] &lt; INIFINTY) &#123;<br>                edges[k].begin = i;<br>                edges[k].end = j;<br>                edges[k].weight = G.arc[i][j];<br>                k++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    sort(edges, &amp;G);<br>    <br>    <span class="hljs-comment">// 初始化回路判断数组</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G.numVertexes; i++) &#123;<br>        parent[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打印最小生成树:\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G.numEdges; i++) &#123;<br>        n = Find(parent, edges[i].begin); <span class="hljs-comment">// 判断起点是否落在生成树连通分量中</span><br>        m = Find(parent, edges[i].end); <span class="hljs-comment">// 判断终点是否落在生成树连通分量中</span><br>        <br>        <span class="hljs-comment">// 未形成回路，可以加入</span><br>        <span class="hljs-keyword">if</span> (n != m) &#123;<br>            parent[n] = m; <span class="hljs-comment">// 更新连通分量判断数组</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d, %d) %d\n&quot;</span>,edges[i].begin, edges[i].end<br>                   , edges[i].weight);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span> &#123;<br>    <br>    MGraph G;<br>    CreateMGraph(&amp;G);<br>    MiniSpanTree_Kruskal(G);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>联考</category>
      
      <category>基础：408</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数之和</title>
    <link href="/2023/dca8257178c4/"/>
    <url>/2023/dca8257178c4/</url>
    
    <content type="html"><![CDATA[<h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><blockquote><p>C++ Tips</p><ol><li><p>参数为引用时（&amp; 或 *），直接操作原始数据</p></li><li><p>C++11 引入 unordered_map（哈希表的数据结构）</p></li></ol></blockquote><p>题目：</p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。</p><h4 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h4><p>时间复杂度：O(<em>n</em>)</p><p>空间复杂度：O(<em>n</em>)</p><h5 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//c++</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hashtable;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">auto</span> it = hashtable.<span class="hljs-built_in">find</span>(target - nums[i]);<br>            <span class="hljs-keyword">if</span>(it != hashtable.<span class="hljs-built_in">end</span>())&#123;<br>                <span class="hljs-keyword">return</span> &#123;it-&gt;second, i&#125;;<br>            &#125;<br>            hashtable[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        Map&lt;Integer,Integer&gt; hashtable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i)&#123;<br>            <span class="hljs-keyword">if</span>(hashtable.containsKey(target-nums[i]))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;hashtable.get(target - nums[i]),i&#125;;<br>            &#125;<br>            hashtable.put(nums[i],i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="python"><a href="#python" class="headerlink" title="python"></a>python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#python3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        hashtable = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">if</span> target - num <span class="hljs-keyword">in</span> hashtable:<br>                <span class="hljs-keyword">return</span> [hashtable[target - num], i]<br>            hashtable[nums[i]] = i<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h5 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span> &#123;</span><br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> val;<br>    UT_hash_handle hh;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span>* <span class="hljs-title">hashtable</span>;</span><br><br><span class="hljs-keyword">struct</span> hashTable* <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> ikey)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span>* <span class="hljs-title">tmp</span>;</span><br>    HASH_FIND_INT(hashtable, &amp;ikey, tmp);<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> ikey, <span class="hljs-type">int</span> ival)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span>* <span class="hljs-title">it</span> =</span> find(ikey);<br>    <span class="hljs-keyword">if</span> (it == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span>* <span class="hljs-title">tmp</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> hashTable));<br>        tmp-&gt;key = ikey, tmp-&gt;val = ival;<br>        HASH_ADD_INT(hashtable, key, tmp);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        it-&gt;val = ival;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span>* <span class="hljs-title function_">twoSum</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span>* returnSize)</span> &#123;<br>    hashtable = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numsSize; i++) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span>* <span class="hljs-title">it</span> =</span> find(target - nums[i]);<br>        <span class="hljs-keyword">if</span> (it != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-type">int</span>* ret = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">2</span>);<br>            ret[<span class="hljs-number">0</span>] = it-&gt;val, ret[<span class="hljs-number">1</span>] = i;<br>            *returnSize = <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>        insert(nums[i], i);<br>    &#125;<br>    *returnSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//javascript</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> twoSum = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) &#123;<br>    <span class="hljs-keyword">let</span> idx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; ; j++) &#123;<br>        <span class="hljs-keyword">const</span> x = nums[j];<br>        <span class="hljs-keyword">if</span> (idx.<span class="hljs-title function_">has</span>(target - x)) <br>            <span class="hljs-keyword">return</span> [idx.<span class="hljs-title function_">get</span>(target - x), j]; <br>        idx.<span class="hljs-title function_">set</span>(x, j); <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>基础：两数之和</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 帧率获取</title>
    <link href="/2023/da0ce45cc34a/"/>
    <url>/2023/da0ce45cc34a/</url>
    
    <content type="html"><![CDATA[<h3 id="1-实时获取FPS"><a href="#1-实时获取FPS" class="headerlink" title="1. 实时获取FPS"></a>1. 实时获取FPS</h3><h4 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">DecimalFormat</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecimalFormat</span>(<span class="hljs-string">&quot;##0.00&quot;</span>);<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">MONITOR_INTERVAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">160L</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">MONITOR_INTERVAL_NANOS</span> <span class="hljs-operator">=</span> MONITOR_INTERVAL * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">mStartFrameTIme</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">mFrameCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getFps</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">//SDK版本小于JELLY_BEAN（Android 4.1）</span><br>    &#125;<br>    Choreographer.getInstance().postFrameCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Choreographer</span>.FrameCallback() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFrame</span><span class="hljs-params">(<span class="hljs-type">long</span> frameTimeNanos)</span> &#123;<br>            <span class="hljs-keyword">if</span> (mStartFrameTIme == <span class="hljs-number">0</span>) &#123;<br>                mStartFrameTIme = frameTimeNanos;<br>            &#125;<br>            <span class="hljs-type">float</span> <span class="hljs-variable">interval</span> <span class="hljs-operator">=</span> (frameTimeNanos - mStartFrameTIme) / <span class="hljs-number">1000000.0f</span>;<br>            <span class="hljs-keyword">if</span> (interval &gt; MONITOR_INTERVAL) &#123;<br>                <span class="hljs-type">double</span> <span class="hljs-variable">fps</span> <span class="hljs-operator">=</span> ((<span class="hljs-type">double</span>) mFrameCount * <span class="hljs-number">1000L</span>) / interval;<br>                Log.i(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;fps:&quot;</span> + format.format(FPS));<br>                mFrameCount = <span class="hljs-number">0</span>;<br>                mStartFrameTIme = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ++mFrameCount;<br>            &#125;<br>            Choreographer.getInstance().postFrameCallback(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//递归获取</span><br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-关闭-VSync-TBD"><a href="#2-关闭-VSync-TBD" class="headerlink" title="2. 关闭 VSync (TBD)"></a>2. 关闭 VSync (TBD)</h3><h3 id="3-在-GL-线程中自定义-FPS-TBD"><a href="#3-在-GL-线程中自定义-FPS-TBD" class="headerlink" title="3. 在 GL 线程中自定义 FPS (TBD)"></a>3. 在 GL 线程中自定义 FPS (TBD)</h3><h3 id="4-——-——-——"><a href="#4-——-——-——" class="headerlink" title="4. —— —— ——"></a>4. —— —— ——</h3>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>基础：帧率</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 中的特殊视图</title>
    <link href="/2023/34ae59f9ac53/"/>
    <url>/2023/34ae59f9ac53/</url>
    
    <content type="html"><![CDATA[<h3 id="SurfaceView-amp-TextureView"><a href="#SurfaceView-amp-TextureView" class="headerlink" title="SurfaceView &amp; TextureView"></a>SurfaceView &amp; TextureView</h3><h4 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h4><blockquote><p>在 SDK 的文档中，对 Surface 的描述是这样的：“Handle onto a raw buffer that is being managed by the screen compositor”，意思是 “由屏幕显示内容合成器所管理的原始缓冲区的句柄” 。所谓原始缓冲区，是用于保存当前窗口的像素数据的缓存空间，也就是说，通过 Surface 可以获取原始缓冲区以及其中的内容。Surface 对应一块屏幕缓冲区，每个 Window 对应一个 Surface，任何 View 都画在 Surface 上，Surface 中， 借助Canvas画图，原始缓冲区用来保存数据。从代码层面看，Surface 为 BufferQueue 的 Producer 接口实现类，使生产者可以通过它的软件或硬件渲染接口为其提供 GraphicBuffer。</p></blockquote><h4 id="SurfaceView"><a href="#SurfaceView" class="headerlink" title="SurfaceView"></a>SurfaceView</h4><blockquote><p>Surface View 从 Android 1.0 (API level 1) 时就有。它继承自类 View，因此它本质上是一个 View。但与普通 View 不同的是，它有自己的 Surface。我们知道，一般的 Activity 包含的多个 View 会组成 View hierarchy 的树形结构，只有最顶层的 DecorView，也就是根结点视图，才是对 WMS (Window Manager Service) 可见的。这个DecorView 在 WMS 中有一个对应的 WindowState。相应地，在 SF (Surface Flinger) 中对应的 Layer。而 SurfaceView 自带一个 Surface，这个 Surface 在 WMS 中有自己对应的 WindowState，在 SF 中也会有自己的 Layer。也就是说，虽然在 App 端它仍在 View hierarchy 中，但在 Server 端 (WMS和SF) 中，它与宿主窗口是分离的。这样的好处是对这个 Surface 的渲染可以放到单独线程去做，渲染时可以有自己的 GL context 。这对于一些游戏、视频等性能相关的应用非常有益，因为它不会影响主线程对事件的响应。但它也有缺点，因为这个 Surface 不在 View hierarchy 中，它的显示也不受 View 的属性控制，所以不能进行平移，缩放等变换，也不能放在其它 ViewGroup 中，一些 View 中的特性也无法使用，例如 View.setAlpha()。 从 Android7.0 开始，SurfaceView 的窗口位置与其他 View 渲染同步更新。这意味着在屏幕上平移和缩放 SurfaceView 不会导致渲染失真。</p></blockquote><p>​<img src="https://img.hello-yzg.cn/Android+%23+Surface+View+and+Texture+View-001.png" style="zoom: 150%;" /></p><center style="color:#C0C0C0">图1</center><h6 id="个人理解（实现原理）："><a href="#个人理解（实现原理）：" class="headerlink" title="个人理解（实现原理）："></a>个人理解（实现原理）：</h6><p>SurfaceView 继承了 View 的部分特性，例如布局，事件响应等；同时</p><ul><li>持有一个单独的 Surface，重写了来自 View 的渲染实现，在自己的线程中进行绘制，不参与 UI 线程的绘制 Looper</li><li>双缓冲机制使它有两个独立的 GraphicBuffer (图像缓存区) ：frontBuffer 和 backBuffer，每次绘制时，将直接在backBuffer 中进行绘制，绘制完成后与frontBuffer进行交换，post 至 SurfaceFlinger 进行最终合成并显示</li><li>可以直接从内存或者DMA等硬件接口取得图像数据，提升性能</li></ul><h6 id="应用领域（设计需求）："><a href="#应用领域（设计需求）：" class="headerlink" title="应用领域（设计需求）："></a>应用领域（设计需求）：</h6><p>SurfaceView的以上特性使它成为显示实时视频流、游戏动画等需要频繁更新的图像内容的首选。</p><h4 id="GLSurfaceView"><a href="#GLSurfaceView" class="headerlink" title="GLSurfaceView"></a>GLSurfaceView</h4><blockquote><p>GLSurfaceView 从 Android 1.5 (API level 3) 开始加入 ，作为 SurfaceView 的补充。它可以看作是 SurfaceView 的一种典型使用模式。在 SurfaceView 的基础上，它加入了 EGL (Embedded Graphic Library) 的管理，并自带了渲染线程。另外它定义了用户需要实现的 Render 接口，提供了用 Strategy pattern 更改具体 Render 行为的灵活性。作为 GLSurfaceView 的 Client，只需要将实现了渲染函数的 Renderer 的实现类设置给 GLSurfaceView 即可。</p></blockquote><p>扩展 SurfaceView，可以调用 OpenGL ES 类库，多用于开发3D效果</p><h4 id="SurfaceTexture"><a href="#SurfaceTexture" class="headerlink" title="SurfaceTexture"></a>SurfaceTexture</h4><blockquote><p>SurfaceTexture 从 Android 3.0 (API level 11) 加入。和 SurfaceView 不同的是，它对图像流的处理并不直接显示，而是转为 GL 外部纹理 (External Texture)，因此可用于图像流数据的二次处理（如 Camera 滤镜，桌面特效等）。比如 Camera 的预览数据，变成纹理后可以交给 GLSurfaceView 直接显示，也可以通过 SurfaceTexture 交给 TextureView 作为 View hierarchy 中的一个硬件加速层来显示。首先，SurfaceTexture 从图像流 (来自 Camera 预览，视频解码，GL 绘制场景等) 中获得帧数据，当调用 updateTexImage() 时，根据内容流中最近的图像更新 SurfaceTexture 对应的 GL 纹理对象，接下来，就可以像操作普通 GL 纹理一样操作它了。它核心管理着一个 BufferQueue 的 Consumer 和 Producer 两端。Producer 端用于接收内容流的源输出数据，Consumer 端用于拿 GraphicBuffer 并生成纹理。SurfaceTexture.OnFrameAvailableListener 用于让 SurfaceTexture 的使用者知道有新数据到来。JNISurfaceTextureContext 是 OnFrameAvailableListener 从 Native 到 Java 的 JNI 跳板。其中 SurfaceTexture 中的attachToGLContext() 和 detachToGLContext() 可以让多个 GL context 共享同一个内容源。</p></blockquote><p>扩展 Surface，获取图像流后，不绘制 GraphicBuffer 提交 SF 合成，而是生成为 ExternalTexture 提交 GL 渲染。</p><h4 id="TextureView"><a href="#TextureView" class="headerlink" title="TextureView"></a>TextureView</h4><blockquote><p>TextureView 从 Android 4.0 (API level 14) 中引入。它可以将内容流直接投影到 View 中，可以用于实现 Live preview 等功能。和 SurfaceView 不同，它不会在 WMS 中单独创建窗口，而是作为 View hierachy 中的一个普通 View，因此可以和其它普通 View 一样进行移动，旋转，缩放，动画等变化。值得注意的是 TextureView 必须在硬件加速的窗口中。它显示的内容流数据可以来自 App 进程或是远端进程。TextureView 继承自 View，它与其它的 View 一样在 View hierarchy 中管理与绘制。TextureView 重载了 draw() 方法，其中主要把 SurfaceTexture 中收到的图像数据作为纹理更新到对应的 HardwareLayer 中。SurfaceTexture.OnFrameAvailableListener 用于通知 TextureView 内容流有新图像到来。SurfaceTextureListener 接口用于让TextureView 的使用者知道 SurfaceTexture 已准备好，这样就可以把 SurfaceTexture 交给相应的内容源。SurfaceTexture 可以用作非直接输出的内容流，这样就提供二次处理的机会。与 SurfaceView 直接输出相比，这样会有若干帧的延迟。同时，由于它本身管理 BufferQueue，因此内存消耗也会稍微大一些。</p></blockquote><h6 id="个人理解（实现原理）：-1"><a href="#个人理解（实现原理）：-1" class="headerlink" title="个人理解（实现原理）："></a>个人理解（实现原理）：</h6><p>TextureView 继承了 View 的大部分特性，例如布局，事件响应等；同时</p><ul><li>作为用于图像投影的普通 View 在 UI 线程中进行绘制，具有 view 的大部分特性</li><li>内容数据要先由 SurfaceTexture 输出为 GL 外部纹理，再加入 View hierachy 作为一个硬件加速层实现 GL 投影，复杂的数据交换导致了绘制延时</li><li>接收类型为外部纹理 (GL特有) 使得其本身必须能够与GPU进行数据交换，即开启硬件加速，开销较大</li></ul><h6 id="应用领域（设计需求）：-1"><a href="#应用领域（设计需求）：-1" class="headerlink" title="应用领域（设计需求）："></a>应用领域（设计需求）：</h6><p>SurfaceView的以上特性使它成为供 GL 进行图像内容再处理的首选，但并不常用。</p><h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><ul><li><p><strong>在 Android 7.0 上系统 SurfaceView 的性能比 TextureView 更有优势</strong>，支持对象的内容位置和包含的应用内容同步更新，平移、缩放不会产生黑边。 <strong>在7.0以下系统如果使用场景有动画效果，可以选择性使用 TextureView</strong>。</p></li><li><p>由于失效 (invalidation) 和缓冲的特性，<strong>TextureView 增加了额外1~3帧的延迟显示画面更新</strong>。</p></li><li><p>TextureView 总是使用 GL 合成，而 SurfaceView 可以使用硬件 overlay 后端，可以占用更少的内存。</p></li><li><p>TextureView 的内部缓冲队列导致比 SurfaceView 使用更多的内存。</p></li><li><p>SurfaceView 内部自持有 Surface，Surface 创建、销毁、改变时由系统处理，通过 SurfaceHolder  回调通知。</p></li><li><p>当画布创建好时，可以将 Surface 绑定到 MediaPlayer 中。SurfaceView 如果为用户可见的时候，创建 SurfaceView 的 SurfaceHolder 用于显示视频流解析的帧图片，如果发现 SurfaceView 变为用户不可见的时候，则立即销毁 SurfaceView 的 SurfaceHolder，以达到节约系统资源的目的。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>基础：View</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello C++ !</title>
    <link href="/2023/975ba186bf91/"/>
    <url>/2023/975ba186bf91/</url>
    
    <content type="html"><![CDATA[<h2 id="1-C-初识"><a href="#1-C-初识" class="headerlink" title="1. C++初识"></a>1. C++初识</h2><h3 id="1-1-HellofromC"><a href="#1-1-HellofromC" class="headerlink" title="1.1 HellofromC++"></a>1.1 HellofromC++</h3><h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><p>单行 &#x2F;&#x2F; </p><p>多行 &#x2F;*  *&#x2F;</p><h3 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h3><p>数据类型 变量名 &#x3D; 初始值；（写入内容，避免Null与Any）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//取变量名</span><br><span class="hljs-meta">#x  </span><br></code></pre></td></tr></table></figure><h3 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4 常量"></a>1.4 常量</h3><p>记录程序中不可更改的数据</p><h4 id="1-4-1-define-宏常量（预编译，不占用内存）"><a href="#1-4-1-define-宏常量（预编译，不占用内存）" class="headerlink" title="1.4.1 #define 宏常量（预编译，不占用内存）"></a>1.4.1 #define 宏常量（预编译，不占用内存）</h4><p>#define 常量名 常量值；</p><h4 id="1-4-2-const修饰的变量（编译，占用内存）"><a href="#1-4-2-const修饰的变量（编译，占用内存）" class="headerlink" title="1.4.2 const修饰的变量（编译，占用内存）"></a>1.4.2 const修饰的变量（编译，占用内存）</h4><p>变量定义前加const关键字，不可修改</p><h3 id="1-5-关键字"><a href="#1-5-关键字" class="headerlink" title="1.5 关键字"></a>1.5 关键字</h3><p>C++预先保留得标识符</p><h3 id="1-5-标识符命名规则"><a href="#1-5-标识符命名规则" class="headerlink" title="1.5 标识符命名规则"></a>1.5 标识符命名规则</h3><p>由字母、数字、下划线组成；第一个字符不能为数字；字母区分大小写</p><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><p>分配内存空间的关键字</p><h3 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h3><table><thead><tr><th>数据类型</th><th>占用空间</th><th>取值范围</th></tr></thead><tbody><tr><td>short，短整型</td><td>2B</td><td>-2^15~2^15-1</td></tr><tr><td>int，整型</td><td>4B</td><td>-2^31~2^31-1</td></tr><tr><td>long，长整型</td><td>4B (Windows，Linux-32位)， 8B（Linux-64位）</td><td>-2^31~2^31-1</td></tr><tr><td>long long，长长整型</td><td>8B</td><td>-2^63~2^63-1</td></tr></tbody></table><h3 id="2-2-sizeof关键字"><a href="#2-2-sizeof关键字" class="headerlink" title="2.2 sizeof关键字"></a>2.2 sizeof关键字</h3><p>sizeof (数据类型&#x2F;变量名)，单位为字节</p><h3 id="2-3-实型（浮点型）"><a href="#2-3-实型（浮点型）" class="headerlink" title="2.3 实型（浮点型）"></a>2.3 实型（浮点型）</h3><p>单精度 float  7位有效数字</p><p>双精度 double  15~16位有效数字</p><p>默认：C++输出实型 &lt;&#x3D; 6位有效数字</p><p>科学计数法  eg：  3e2 &#x3D; 3 * 10^2     3e-2 &#x3D; 3 * 0.1^2</p><h3 id="2-4-字符型"><a href="#2-4-字符型" class="headerlink" title="2.4 字符型"></a>2.4 字符型</h3><p>char  1B</p><p>表示形式为单引号，传入内存中为ASCII码，强转int后可查看, a - 97, A - 65</p><p>ASCII码：</p><p>​1.非打印控制字符：0~31，用于控制外围设备</p><p>​2.打印字符：32~126，键盘</p><h3 id="2-5-转义字符"><a href="#2-5-转义字符" class="headerlink" title="2.5 转义字符"></a>2.5 转义字符</h3><p>列举几项：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">\a  =  警报<br>\n  =  换行<br>\t  =  水平制表，跳至下一个tab（<span class="hljs-number">8</span>位光标）<br>\\  =  \<br>\<span class="hljs-string">&#x27;  =  &#x27;</span><br>\<span class="hljs-string">&quot;  =  &quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-6-字符串型"><a href="#2-6-字符串型" class="headerlink" title="2.6 字符串型"></a>2.6 字符串型</h3><p>本质为字符数组，表示形式为双引号</p><ul><li>C风格：char Name[] &#x3D; “……”</li><li>C++风格：string Name &#x3D; “……”</li></ul><h3 id="2-7-布尔类型-bool"><a href="#2-7-布尔类型-bool" class="headerlink" title="2.7 布尔类型 bool"></a>2.7 布尔类型 bool</h3><p>bool类型占1B，只有两个值</p><ul><li>true  —真 （本质为1）</li><li>false —假 （本质为0）</li></ul><h3 id="2-8-数据输入"><a href="#2-8-数据输入" class="headerlink" title="2.8 数据输入"></a>2.8 数据输入</h3><p>从键盘获取数据</p><p>cin &gt;&gt; 变量</p><h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h2><p>执行代码的运算</p><table><thead><tr><th>运算符类型</th><th>作用</th></tr></thead><tbody><tr><td>算术运算符</td><td>四则运算</td></tr><tr><td>赋值运算符</td><td>表达式给变量赋值</td></tr><tr><td>比较运算符</td><td>比较表达式，返回真&#x2F;假</td></tr><tr><td>逻辑运算符</td><td>逻辑运算，返回真&#x2F;假</td></tr></tbody></table><h3 id="3-1-算数运算符"><a href="#3-1-算数运算符" class="headerlink" title="3.1 算数运算符"></a>3.1 算数运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">+ - * / % ++ --<br></code></pre></td></tr></table></figure><p>除法运算除数 !&#x3D; 0</p><p>小数不可取模运算</p><p>a++: 存储变量a，对变量a进行递增（副本），语句结束赋值回a</p><p>++a: 对变量a进行递增</p><h3 id="3-2-赋值运算符"><a href="#3-2-赋值运算符" class="headerlink" title="3.2 赋值运算符"></a>3.2 赋值运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">= += -= *= /= %=<br></code></pre></td></tr></table></figure><h3 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">== != &gt; &lt; &gt;= &lt;=<br></code></pre></td></tr></table></figure><p>结果为0或1</p><h3 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h3><table><thead><tr><th>运算符</th><th>术语</th><th>结果</th></tr></thead><tbody><tr><td>！</td><td>非</td><td>a为假，!a为真；a为真，!a为假</td></tr><tr><td>&amp;&amp;</td><td>与</td><td>a与b都为真，a&amp;&amp;b为真，否则为假</td></tr><tr><td>||</td><td>或</td><td>a与b都为假，a||b为假，否则为真</td></tr></tbody></table><h2 id="4-程序流程结构"><a href="#4-程序流程结构" class="headerlink" title="4. 程序流程结构"></a>4. 程序流程结构</h2><p>三种基本的程序运行结构：</p><ul><li>顺序结构：顺序执行，不发生跳转</li><li>选择结构：依据条件选择执行</li><li>循环结构：依据条件循环执行</li></ul><h3 id="4-1-选择结构"><a href="#4-1-选择结构" class="headerlink" title="4.1 选择结构"></a>4.1 选择结构</h3><h4 id="4-1-1-if语句"><a href="#4-1-1-if语句" class="headerlink" title="4.1.1 if语句"></a>4.1.1 if语句</h4><ul><li>单行格式if语句</li><li>多行格式if语句</li><li>多条件的if语句</li></ul><h4 id="4-1-2-三目运算符"><a href="#4-1-2-三目运算符" class="headerlink" title="4.1.2 三目运算符"></a>4.1.2 三目运算符</h4><p>取 MAX(a, b) 赋值于 c</p><ul><li>c &#x3D; a &gt; b ? a : b</li></ul><h4 id="4-1-3-switch语句"><a href="#4-1-3-switch语句" class="headerlink" title="4.1.3 switch语句"></a>4.1.3 switch语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span>(表达式：整型或字符型)&#123;<br><span class="hljs-keyword">case</span> 结果<span class="hljs-number">1</span>: 执行语句; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> 结果<span class="hljs-number">2</span>: 执行语句; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> 结果<span class="hljs-number">3</span>: 执行语句; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>: 执行语句; <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结构清晰，执行效率高</p><h3 id="4-2-循环结构"><a href="#4-2-循环结构" class="headerlink" title="4.2 循环结构"></a>4.2 循环结构</h3><h4 id="4-2-1-while循环语句"><a href="#4-2-1-while循环语句" class="headerlink" title="4.2.1 while循环语句"></a>4.2.1 while循环语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(循环条件)&#123;循环语句&#125;<br></code></pre></td></tr></table></figure><p>只要循环条件的结果为真，就执行循环语句</p><p>注意事项：避免死循环的出现，即必须提供退出循环的接口</p><ul><li><p>案例：猜数字 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<span class="hljs-comment">//根据系统时间生成随机数</span><br><br><span class="hljs-type">int</span> num = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span>; <span class="hljs-comment">//生成0~99随机数(伪随机数)</span><br>cout &lt;&lt; num &lt;&lt; endl;<br><br><span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>cin &gt;&gt; val;<br><span class="hljs-keyword">if</span> (val &gt; num) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;猜测过大&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &lt; num) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;猜测过小&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;您猜对了&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//跳出当前循环</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-2-2-do……while循环语句"><a href="#4-2-2-do……while循环语句" class="headerlink" title="4.2.2 do……while循环语句"></a>4.2.2 do……while循环语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span>&#123;循环语句&#125;<span class="hljs-keyword">while</span>(循环条件)<br></code></pre></td></tr></table></figure><p>与while语句的区别为先执行一次循环语句，再判断循环条件</p><ul><li><p>案例：水仙花数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> num = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-type">int</span> a = num % <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = num / <span class="hljs-number">10</span> % <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> c = num / <span class="hljs-number">10</span> / <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> d = a*a*a + b*b*b + c*c*c;<br>    <span class="hljs-keyword">if</span> (num == d) &#123;<br>        cout &lt;&lt; num &lt;&lt; endl;<br>    &#125;<br>    num++;<br>&#125; <span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-2-3-for循环语句"><a href="#4-2-3-for循环语句" class="headerlink" title="4.2.3 for循环语句"></a>4.2.3 for循环语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(起始表达式；条件表达式；末尾循环体)&#123;循环语句&#125;<br></code></pre></td></tr></table></figure><ul><li>案例：敲桌子</li></ul><h4 id="4-2-4-嵌套循环"><a href="#4-2-4-嵌套循环" class="headerlink" title="4.2.4 嵌套循环"></a>4.2.4 嵌套循环</h4><p>在循环中嵌套循环，用于处理“多维”问题</p><p>外层执行一次，内层执行一周</p><ul><li><p>案例：乘法口诀表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; ++i) <span class="hljs-comment">//行&#123;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) <span class="hljs-comment">//列&#123;</span><br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; i * j&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-3-跳转语句"><a href="#4-3-跳转语句" class="headerlink" title="4.3 跳转语句"></a>4.3 跳转语句</h3><h4 id="4-3-1-break语句"><a href="#4-3-1-break语句" class="headerlink" title="4.3.1 break语句"></a>4.3.1 break语句</h4><p>使用时机：</p><ul><li>switch选择语句</li><li>循环语句</li></ul><h4 id="4-3-2-continue语句"><a href="#4-3-2-continue语句" class="headerlink" title="4.3.2 continue语句"></a>4.3.2 continue语句</h4><p>在循环语句中，跳过本次循环，继续执行下一次循环</p><h4 id="4-3-3-goto语句"><a href="#4-3-3-goto语句" class="headerlink" title="4.3.3 goto语句"></a>4.3.3 goto语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">goto</span> 标记；<br></code></pre></td></tr></table></figure><p>标记格式为 标记名 + “:”</p><p>若标记存在，则跳转到标记的位置</p><p>不推荐使用，会破环程序空间局部性和代码结构</p><h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>存放相同类型数据的集合</p><ul><li>特点1：每个数据元素的类型相同</li><li>特点2：物理上，内存连续</li></ul><h3 id="5-2-一维数组"><a href="#5-2-一维数组" class="headerlink" title="5.2 一维数组"></a>5.2 一维数组</h3><h4 id="5-2-1-一维数组的定义方式"><a href="#5-2-1-一维数组的定义方式" class="headerlink" title="5.2.1 一维数组的定义方式"></a>5.2.1 一维数组的定义方式</h4><p>三种定义方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span> 数据类型 数组名[数组长度]；<br><br><span class="hljs-comment">//定义时初始化，未初始化的内存会分配 0</span><br><span class="hljs-number">2.</span> 数据类型 数组名[数组长度] = &#123;值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>，值<span class="hljs-number">3</span>，......&#125;<br><span class="hljs-number">3.</span> 数据类型 数组名[] = &#123;值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>，值<span class="hljs-number">3</span>，......&#125;<br><br>eg:  <span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>];<br>通过下标（[序号]，从<span class="hljs-number">0</span>开始）访存，arr[<span class="hljs-number">0</span>]，arr[<span class="hljs-number">1</span>]，arr[<span class="hljs-number">2</span>]，......<br></code></pre></td></tr></table></figure><h4 id="5-2-2-一维数组的数组名"><a href="#5-2-2-一维数组的数组名" class="headerlink" title="5.2.2 一维数组的数组名"></a>5.2.2 一维数组的数组名</h4><ul><li>统计数组长度                                            sizeof(arr)</li><li>获取数组首地址或首元素地址                 arr</li></ul><p>数组名为常量，不可被赋值</p><ul><li><p>案例：五只小猪称体重</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">300</span>,<span class="hljs-number">350</span>,<span class="hljs-number">200</span>,<span class="hljs-number">400</span>,<span class="hljs-number">250</span> &#125;;<br><span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] &gt; max)&#123;<br>        max = arr[i];<br>    &#125;<br>&#125;<br>cout &lt;&lt; max &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li><li><p>案例：数组逆置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;; <span class="hljs-comment">//目标数组</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;逆置前：&quot;</span>  &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i)&#123;<br>    cout &lt;&lt; arr[i] &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; <span class="hljs-comment">//首指针</span><br><span class="hljs-type">int</span> end = <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>; <span class="hljs-comment">//尾指针</span><br><span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>    <span class="hljs-type">int</span> temp = arr[start];<br>    arr[start] = arr[end];<br>    arr[end] = temp;<br>    ++start;<br>    --end;<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;逆置后：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i)&#123;<br>    cout &lt;&lt; arr[i] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="5-2-3-冒泡排序"><a href="#5-2-3-冒泡排序" class="headerlink" title="5.2.3 冒泡排序"></a>5.2.3 冒泡排序</h4><p>对数组内的元素进行排序，具体执行：</p><ol><li>比较相邻的元素，通过交换保证较大元素右侧</li><li>一轮过后，会得到最大元素（尾元素）——”冒泡“</li><li>重复以上步骤，但比较次数-1，因为最大元素已经确定</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span> &#125;;<br>cout &lt;&lt; <span class="hljs-string">&quot;排序前：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i)&#123;<br>    cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//冒泡排序执行 [9-1=8] 轮，每轮确定一个最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i) &#123;<br>    <span class="hljs-comment">//每轮执行 [当前元素个数-1] 次对比</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span> - i - <span class="hljs-number">1</span>; ++j) &#123;<br>        <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-type">int</span> temp = arr[j];<br>            arr[j] = arr[j+<span class="hljs-number">1</span>];<br>            arr[j+<span class="hljs-number">1</span>] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;排序后：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i) &#123;<br>    cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-二维数组"><a href="#5-3-二维数组" class="headerlink" title="5.3 二维数组"></a>5.3 二维数组</h3><p>增加数组维度</p><h4 id="5-3-1-二维数组的定义方式"><a href="#5-3-1-二维数组的定义方式" class="headerlink" title="5.3.1 二维数组的定义方式"></a>5.3.1 二维数组的定义方式</h4><p>四种定义方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span> 数据类型 数组名[行数][列数]；<br><span class="hljs-number">2.</span> 数据类型 数组名[行数][列数] = <span class="hljs-comment">//推荐使用</span><br>&#123; <br>&#123;值<span class="hljs-number">0</span>_1，值<span class="hljs-number">0</span>_2，......&#125;，<br>&#123;值<span class="hljs-number">1</span>_1，值<span class="hljs-number">1</span>_2，......&#125;，<br>......<br>&#125;；<br><span class="hljs-number">3.</span> 数据类型 数组名[行数][列数] = &#123;值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>，值<span class="hljs-number">3</span>，值<span class="hljs-number">4</span>，......&#125;；<br><span class="hljs-number">4.</span> 数据类型 数组名[][列数] = &#123;值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>，值<span class="hljs-number">3</span>，值<span class="hljs-number">4</span>，......&#125;；<br><br>eg:  <span class="hljs-type">int</span> arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]<br>通过下标（[行号][列号]，从<span class="hljs-number">0</span>开始）访存，arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]，arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]，arr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]，......<br></code></pre></td></tr></table></figure><h4 id="5-3-2-二维数组的数组名"><a href="#5-3-2-二维数组的数组名" class="headerlink" title="5.3.2 二维数组的数组名"></a>5.3.2 二维数组的数组名</h4><ul><li>统计数组长度                                                              sizeof(arr)</li><li>统计数组每行长度                                                      sizeof(arr[行号])</li><li>获取数组首地址或首行地址或首元素地址                arr</li></ul><p>数组名为常量，不可被赋值</p><h4 id="5-3-3-二维数组应用案例"><a href="#5-3-3-二维数组应用案例" class="headerlink" title="5.3.3 二维数组应用案例"></a>5.3.3 二维数组应用案例</h4><p>考试成绩统计</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>]=<br>&#123;<br>&#123; <span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span> &#125;,<br>&#123; <span class="hljs-number">90</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span> &#125;,<br>&#123; <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; ++j)&#123;<br>        sum += arr[i][j];<br>        cout &lt;&lt; arr[i][j] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;第 &quot;</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;个同学的总分为：&quot;</span> &lt;&lt; sum &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p>将一段经常使用的代码封装起来，减少重复代码——程序块</p><h3 id="6-2-函数的定义"><a href="#6-2-函数的定义" class="headerlink" title="6.2 函数的定义"></a>6.2 函数的定义</h3><p>函数的定义一般分为五部分：</p><ol><li>返回值类型</li><li>函数名</li><li>参数声明列表——形参</li><li>函数体语句</li><li>return表达式</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">返回值类型 函数名 （参数声明列表）&#123;<br>函数体语句；<br><span class="hljs-keyword">return</span>表达式；<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-函数的调用"><a href="#6-3-函数的调用" class="headerlink" title="6.3 函数的调用"></a>6.3 函数的调用</h3><p>传入具体的参数——实参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">函数名（参数值列表）；<br></code></pre></td></tr></table></figure><p>调用时，实参的值会传递给形参</p><h3 id="6-4-值传递"><a href="#6-4-值传递" class="headerlink" title="6.4 值传递"></a>6.4 值传递</h3><p>函数调用时，实参的值会传递给形参，并不受形参的影响</p><h3 id="6-5-函数的常见样式"><a href="#6-5-函数的常见样式" class="headerlink" title="6.5 函数的常见样式"></a>6.5 函数的常见样式</h3><p>常见的函数样式有四种：</p><ol><li>无参无返</li><li>有参无返</li><li>无参有返</li><li>有参有返</li></ol><h3 id="6-6-函数的声明"><a href="#6-6-函数的声明" class="headerlink" title="6.6 函数的声明"></a>6.6 函数的声明</h3><p>向编译器声明函数信息（一般情况下代码逐行执行，意味着函数定义必须写于调用之前，为了改善这种强秩序，引入声明机制）</p><p>函数的实际主体可以单独定义，但必须唯一</p><h3 id="6-7-函数的分文件编写"><a href="#6-7-函数的分文件编写" class="headerlink" title="6.7 函数的分文件编写"></a>6.7 函数的分文件编写</h3><p>让代码结构更加清晰，一般分为四个步骤：</p><ol><li>创建后缀为.hpp的头文件</li><li>创建后缀为.cpp的源文件</li><li>在头文件中写函数的声明</li><li>在源文件中写函数的定义</li></ol><p>通过  #include ”……“  包含自定义的头文件</p><h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7. 指针"></a>7. 指针</h2><h3 id="7-1-指针的基本概念"><a href="#7-1-指针的基本概念" class="headerlink" title="7.1 指针的基本概念"></a>7.1 指针的基本概念</h3><p>可以通过指针间接访问内存</p><ul><li>内存编号从0开始记录，为十六进制数字</li><li>指针变量用于保存地址</li><li>指针本质上是一个对象</li></ul><h3 id="7-2-指针变量的定义和使用"><a href="#7-2-指针变量的定义和使用" class="headerlink" title="7.2 指针变量的定义和使用"></a>7.2 指针变量的定义和使用</h3><p>指针类型声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">数据类型* 指针变量名；<br>数据类型* 指针变量名 = 指针变量；<br></code></pre></td></tr></table></figure><p>取地址与解地址：</p><p>符号* 本质上为算术运算符，即先查左值后查右值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">数据类型 数据变量名；<br>*数据变量名   <span class="hljs-comment">//取地址为指针类型</span><br><br>指针类型 指针变量名；<br>&amp;指针变量名   <span class="hljs-comment">//解地址为数据类型</span><br></code></pre></td></tr></table></figure><h3 id="7-3-指针所占内存空间"><a href="#7-3-指针所占内存空间" class="headerlink" title="7.3 指针所占内存空间"></a>7.3 指针所占内存空间</h3><p>32位操作系统下：占用4字节内存空间</p><p>64位操作系统下：占用8字节内存空间</p><h3 id="7-4-空指针和野指针"><a href="#7-4-空指针和野指针" class="headerlink" title="7.4 空指针和野指针"></a>7.4 空指针和野指针</h3><ul><li>空指针：指针变量指向内存中编号为0的空间——指针初始状态</li></ul><p>空指针指向的内存不可访问（0~255内存编号由系统使用）</p><ul><li>野指针：指针变量指向非法空间</li></ul><ol><li>指针未初始化</li><li>指针局部初始化</li></ol><p>野指针指向内存不可访问（无访问权限）</p><h3 id="7-5-const修饰指针"><a href="#7-5-const修饰指针" class="headerlink" title="7.5 const修饰指针"></a>7.5 const修饰指针</h3><p>const关键字 修饰变量</p><p>*运算符 对右侧变量 (地址) 取值；为右侧变量赋左侧类型的地址——指针声明)</p><ol><li>const修饰指针：常量指针（底层const）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p = &amp;a; <span class="hljs-comment">//const右侧为数据类型（默认变量入栈），const修饰此变量，约束数据   int const* p</span><br>p = &amp;b; <br></code></pre></td></tr></table></figure><ol start="2"><li>const修饰常量：指针常量（顶层const）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a; <span class="hljs-comment">//const右侧为指针变量（指针变量入栈），const修饰指针变量，约束指针  </span><br>*p = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>const既修饰指针又修饰常量</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a; <span class="hljs-comment">//完全约束</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;思考：*运算符本质为重载&#x3D;&#x3D;</p><ol><li><p>&#x3D;&#x3D;左侧为类型，右侧为变量时：指针声明，将左侧默认变量取地址赋给指针变量&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;仅右侧为变量时：解地址&#x3D;&#x3D;</p></li></ol><h3 id="7-6-指针和数组"><a href="#7-6-指针和数组" class="headerlink" title="7.6 指针和数组"></a>7.6 指针和数组</h3><p>利用指针访问数组中的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;<br>cout &lt;&lt; arr[<span class="hljs-number">0</span>] &lt;&lt; endl;                 <span class="hljs-comment">//打印 1</span><br>cout &lt;&lt; *arr &lt;&lt; endl;                   <span class="hljs-comment">//打印 1</span><br><span class="hljs-type">int</span>*p = arr;                            <span class="hljs-comment">//数组名arr不能被修改</span><br>p++;<br>cout &lt;&lt; *p &lt;&lt; endl;                     <span class="hljs-comment">//打印 2，若打印*p++或*(p++) 仍为1</span><br></code></pre></td></tr></table></figure><h3 id="7-7-指针和函数"><a href="#7-7-指针和函数" class="headerlink" title="7.7 指针和函数"></a>7.7 指针和函数</h3><p>利用指针传入函数修改实参的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> temp = *p1;<br>*p1 = * p2;<br>*p2 = temp;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;运算的本质就是操作地址，传入指针相当于自己拥有操作权，否则为系统默认&#x3D;&#x3D;</p><h3 id="7-8-指针和函数"><a href="#7-8-指针和函数" class="headerlink" title="7.8 指针和函数"></a>7.8 指针和函数</h3><p>案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> len)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; ++j) &#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br><span class="hljs-type">int</span> temp = arr[j];<br>arr[j] = arr[j + <span class="hljs-number">1</span>];<br>arr[j + <span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8. 结构体"></a>8. 结构体</h2><h3 id="8-1-结构体基本概念"><a href="#8-1-结构体基本概念" class="headerlink" title="8.1 结构体基本概念"></a>8.1 结构体基本概念</h3><p>结构体属于用户自定义的数据类型，允许用户存储不同的数据类型</p><h3 id="8-2-结构体定义和使用"><a href="#8-2-结构体定义和使用" class="headerlink" title="8.2 结构体定义和使用"></a>8.2 结构体定义和使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> 结构体名 &#123;<br>类型名 成员<span class="hljs-number">1</span>；<br>    类型名 成员<span class="hljs-number">2</span>；<br>    ......<br>&#125;;<br></code></pre></td></tr></table></figure><p>通过结构体创建变量的方式有三种：</p><p>struct 关键字可以省略</p><ul><li>struct 结构体名 变量名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> 结构体名 变量名；<br><span class="hljs-comment">//结构体变量名.成员名 可以访问结构体成员</span><br>变量名.成员<span class="hljs-number">1</span> = ...；<br>变量名.成员<span class="hljs-number">2</span> = ...；<br>......<br></code></pre></td></tr></table></figure><ul><li>struct 结构体名 变量名 &#x3D; {成员1的值，成员2的值，……}</li><li>定义结构体时同步创建变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> 结构体名 &#123;<br>类型名 成员<span class="hljs-number">1</span>；<br>    类型名 成员<span class="hljs-number">2</span>；<br>    ......<br>&#125; 变量名;<br></code></pre></td></tr></table></figure><h3 id="8-3-结构体数组"><a href="#8-3-结构体数组" class="headerlink" title="8.3 结构体数组"></a>8.3 结构体数组</h3><p>将自定义结构体作为数组元素.</p><h3 id="8-4-结构体指针"><a href="#8-4-结构体指针" class="headerlink" title="8.4 结构体指针"></a>8.4 结构体指针</h3><p>通过指针访问结构体成员.</p><ul><li>利用操作符 -&gt; 可以通过结构体指针访问结构体属性.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">struct</span> 结构体名 指针变量名 = &amp;变量名；<br><br><span class="hljs-comment">//结构体指针变量名-&gt;成员名 可以访问结构体成员</span><br>变量名-&gt;成员<span class="hljs-number">1</span> = ...；<br>变量名-&gt;成员<span class="hljs-number">2</span> = ...；<br>......<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;变量未初始化时，C++的行为是未知的，编译器通常会用error来制止这一行为.&#x3D;&#x3D;</p><h3 id="8-5-结构体嵌套结构体"><a href="#8-5-结构体嵌套结构体" class="headerlink" title="8.5 结构体嵌套结构体"></a>8.5 结构体嵌套结构体</h3><p>结构体中的成员可以是另一个结构体  </p><h3 id="8-6-结构体做函数参数"><a href="#8-6-结构体做函数参数" class="headerlink" title="8.6 结构体做函数参数"></a>8.6 结构体做函数参数</h3><p>将结构体作为参数向函数中传递.</p><ul><li>值传递</li><li>地址传递</li></ul><h3 id="8-7-结构体中const使用场景"><a href="#8-7-结构体中const使用场景" class="headerlink" title="8.7 结构体中const使用场景"></a>8.7 结构体中const使用场景</h3><p>使用地址传递节省传递开销，为了只读，需要使用const修饰.</p><h3 id="8-8-结构体案例"><a href="#8-8-结构体案例" class="headerlink" title="8.8 结构体案例"></a>8.8 结构体案例</h3><p>使用地址传递节省传递开销，为了只读，需要使用const修饰.</p><h4 id="8-8-1-案例一"><a href="#8-8-1-案例一" class="headerlink" title="8.8.1 案例一"></a>8.8.1 案例一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>string sName;<br><span class="hljs-type">int</span> score;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Teacher</span> &#123;<br>string tName;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> sArray[<span class="hljs-number">5</span>];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">allocate_print</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Teacher tArray[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>string nameSeed = <span class="hljs-string">&quot;ABCDE&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>tArray[i].tName = <span class="hljs-string">&quot;Teacher_&quot;</span>;<br>tArray[i].tName += nameSeed[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;老师姓名：&quot;</span> &lt;&lt; tArray[i].tName &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; ++j) &#123;<br>tArray[i].sArray[j].sName = <span class="hljs-string">&quot;Student_&quot;</span>;<br>tArray[i].sArray[j].sName += nameSeed[j];<br><span class="hljs-type">int</span> random = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>;<br>tArray[i].sArray[j].score = random;<br>cout &lt;&lt; <span class="hljs-string">&quot;\t学生姓名&quot;</span> &lt;&lt; tArray[i].sArray[j].sName <br>                 &lt;&lt; <span class="hljs-string">&quot; 考试分数：&quot;</span> &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Teacher</span> tArray[<span class="hljs-number">3</span>];<br><span class="hljs-built_in">allocate_print</span>(tArray, <span class="hljs-built_in">size</span>(tArray));<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="8-8-2-案例二"><a href="#8-8-2-案例二" class="headerlink" title="8.8.2 案例二"></a>8.8.2 案例二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hero</span> &#123;<br>string name;<br><span class="hljs-type">int</span> age;<br>    string sex;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort_print</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Hero heroArray[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; ++j) &#123;<br><span class="hljs-keyword">if</span> (heroArray[j].age &gt; heroArray[j + <span class="hljs-number">1</span>].age) &#123;<br><span class="hljs-type">int</span> temp = heroArray[j];<br>heroArray[j] = heroArray[j+<span class="hljs-number">1</span>];<br>heroArray[j+<span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>&#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span>&lt;&lt; heroArray[i].name<br>             &lt;&lt; <span class="hljs-string">&quot;年龄：&quot;</span>&lt;&lt; heroArray[i].age<br>             &lt;&lt; <span class="hljs-string">&quot;性别：&quot;</span>&lt;&lt; heroArray[i].sex &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hero</span> heroArray[<span class="hljs-number">5</span>] = <br>    &#123;<br>        &#123;<span class="hljs-string">&quot;刘备&quot;</span>，<span class="hljs-number">23</span>，<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;关羽&quot;</span>，<span class="hljs-number">22</span>，<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;张飞&quot;</span>，<span class="hljs-number">20</span>，<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;吕布&quot;</span>，<span class="hljs-number">21</span>，<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;貂蝉&quot;</span>，<span class="hljs-number">19</span>，<span class="hljs-string">&quot;女&quot;</span>&#125;,   <br>    &#125;;<br>    <span class="hljs-built_in">bubbleSort_print</span>(heroArray,<span class="hljs-built_in">size</span>(heroArray));<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>基础：语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
