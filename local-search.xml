<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Android 中的特殊视图</title>
    <link href="/2023/3312f87f2ae2/"/>
    <url>/2023/3312f87f2ae2/</url>
    
    <content type="html"><![CDATA[<h2 id="SurfaceView-amp-TextureView"><a href="#SurfaceView-amp-TextureView" class="headerlink" title="SurfaceView &amp; TextureView"></a>SurfaceView &amp; TextureView</h2><h3 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h3><blockquote><p>在 SDK 的文档中，对 Surface 的描述是这样的：“Handle onto a raw buffer that is being managed by the screen compositor”，意思是 “由屏幕显示内容合成器所管理的原始缓冲区的句柄” 。所谓原始缓冲区，是用于保存当前窗口的像素数据的缓存空间，也就是说，通过 Surface 可以获取原始缓冲区以及其中的内容。Surface 对应一块屏幕缓冲区，每个 Window 对应一个 Surface，任何 View 都画在 Surface 上，Surface 中， 借助Canvas画图，原始缓冲区用来保存数据。从代码层面看，Surface 为 BufferQueue 的 Producer 接口实现类，使生产者可以通过它的软件或硬件渲染接口为其提供 GraphicBuffer。</p></blockquote><h3 id="SurfaceView"><a href="#SurfaceView" class="headerlink" title="SurfaceView"></a>SurfaceView</h3><blockquote><p>Surface View 从 Android 1.0 (API level 1) 时就有。它继承自类 View，因此它本质上是一个 View。但与普通 View 不同的是，它有自己的 Surface。我们知道，一般的 Activity 包含的多个 View 会组成 View hierarchy 的树形结构，只有最顶层的 DecorView，也就是根结点视图，才是对 WMS (Window Manager Service) 可见的。这个DecorView 在 WMS 中有一个对应的 WindowState。相应地，在 SF (Surface Flinger) 中对应的 Layer。而 SurfaceView 自带一个 Surface，这个 Surface 在 WMS 中有自己对应的 WindowState，在 SF 中也会有自己的 Layer。也就是说，虽然在 App 端它仍在 View hierarchy 中，但在 Server 端 (WMS和SF) 中，它与宿主窗口是分离的。这样的好处是对这个 Surface 的渲染可以放到单独线程去做，渲染时可以有自己的 GL context 。这对于一些游戏、视频等性能相关的应用非常有益，因为它不会影响主线程对事件的响应。但它也有缺点，因为这个 Surface 不在 View hierarchy 中，它的显示也不受 View 的属性控制，所以不能进行平移，缩放等变换，也不能放在其它 ViewGroup 中，一些 View 中的特性也无法使用，例如 View.setAlpha()。 从 Android7.0 开始，SurfaceView 的窗口位置与其他 View 渲染同步更新。这意味着在屏幕上平移和缩放 SurfaceView 不会导致渲染失真。</p></blockquote><p>​<img src="https://img.hello-yzg.cn/Android+%23+Surface+View+and+Texture+View-001.png" style="zoom: 150%;" /></p><center style="color:#C0C0C0">图1</center><h6 id="个人理解（实现原理）："><a href="#个人理解（实现原理）：" class="headerlink" title="个人理解（实现原理）："></a>个人理解（实现原理）：</h6><p>SurfaceView 继承了 View 的部分特性，例如布局，事件响应等；同时</p><ul><li>持有一个单独的 Surface，重写了来自 View 的渲染实现，在自己的线程中进行绘制，不参与 UI 线程的绘制 Looper</li><li>双缓冲机制使它有两个独立的 GraphicBuffer (图像缓存区) ：frontBuffer 和 backBuffer，每次绘制时，将直接在backBuffer 中进行绘制，绘制完成后与frontBuffer进行交换，post 至 SurfaceFlinger 进行最终合成并显示</li><li>可以直接从内存或者DMA等硬件接口取得图像数据，提升性能</li></ul><h6 id="应用领域（设计需求）："><a href="#应用领域（设计需求）：" class="headerlink" title="应用领域（设计需求）："></a>应用领域（设计需求）：</h6><p>SurfaceView的以上特性使它成为显示实时视频流、游戏动画等需要频繁更新的图像内容的首选。</p><h3 id="GLSurfaceView"><a href="#GLSurfaceView" class="headerlink" title="GLSurfaceView"></a>GLSurfaceView</h3><blockquote><p>GLSurfaceView 从 Android 1.5 (API level 3) 开始加入 ，作为 SurfaceView 的补充。它可以看作是 SurfaceView 的一种典型使用模式。在 SurfaceView 的基础上，它加入了 EGL (Embedded Graphic Library) 的管理，并自带了渲染线程。另外它定义了用户需要实现的 Render 接口，提供了用 Strategy pattern 更改具体 Render 行为的灵活性。作为 GLSurfaceView 的 Client，只需要将实现了渲染函数的 Renderer 的实现类设置给 GLSurfaceView 即可。</p></blockquote><p>扩展 SurfaceView，可以调用 OpenGL ES 类库，多用于开发3D效果</p><h3 id="SurfaceTexture"><a href="#SurfaceTexture" class="headerlink" title="SurfaceTexture"></a>SurfaceTexture</h3><blockquote><p>SurfaceTexture 从 Android 3.0 (API level 11) 加入。和 SurfaceView 不同的是，它对图像流的处理并不直接显示，而是转为 GL 外部纹理 (External Texture)，因此可用于图像流数据的二次处理（如 Camera 滤镜，桌面特效等）。比如 Camera 的预览数据，变成纹理后可以交给 GLSurfaceView 直接显示，也可以通过 SurfaceTexture 交给 TextureView 作为 View hierarchy 中的一个硬件加速层来显示。首先，SurfaceTexture 从图像流 (来自 Camera 预览，视频解码，GL 绘制场景等) 中获得帧数据，当调用 updateTexImage() 时，根据内容流中最近的图像更新 SurfaceTexture 对应的 GL 纹理对象，接下来，就可以像操作普通 GL 纹理一样操作它了。它核心管理着一个 BufferQueue 的 Consumer 和 Producer 两端。Producer 端用于接收内容流的源输出数据，Consumer 端用于拿 GraphicBuffer 并生成纹理。SurfaceTexture.OnFrameAvailableListener 用于让 SurfaceTexture 的使用者知道有新数据到来。JNISurfaceTextureContext 是 OnFrameAvailableListener 从 Native 到 Java 的 JNI 跳板。其中 SurfaceTexture 中的attachToGLContext() 和 detachToGLContext() 可以让多个 GL context 共享同一个内容源。</p></blockquote><p>扩展 Surface，获取图像流后，不绘制 GraphicBuffer 提交 SF 合成，而是生成为 ExternalTexture 提交 GL 渲染。</p><h3 id="TextureView"><a href="#TextureView" class="headerlink" title="TextureView"></a>TextureView</h3><blockquote><p>TextureView 从 Android 4.0 (API level 14) 中引入。它可以将内容流直接投影到 View 中，可以用于实现 Live preview 等功能。和 SurfaceView 不同，它不会在 WMS 中单独创建窗口，而是作为 View hierachy 中的一个普通 View，因此可以和其它普通 View 一样进行移动，旋转，缩放，动画等变化。值得注意的是 TextureView 必须在硬件加速的窗口中。它显示的内容流数据可以来自 App 进程或是远端进程。TextureView 继承自 View，它与其它的 View 一样在 View hierarchy 中管理与绘制。TextureView 重载了 draw() 方法，其中主要把 SurfaceTexture 中收到的图像数据作为纹理更新到对应的 HardwareLayer 中。SurfaceTexture.OnFrameAvailableListener 用于通知 TextureView 内容流有新图像到来。SurfaceTextureListener 接口用于让TextureView 的使用者知道 SurfaceTexture 已准备好，这样就可以把 SurfaceTexture 交给相应的内容源。SurfaceTexture 可以用作非直接输出的内容流，这样就提供二次处理的机会。与 SurfaceView 直接输出相比，这样会有若干帧的延迟。同时，由于它本身管理 BufferQueue，因此内存消耗也会稍微大一些。</p></blockquote><h6 id="个人理解（实现原理）：-1"><a href="#个人理解（实现原理）：-1" class="headerlink" title="个人理解（实现原理）："></a>个人理解（实现原理）：</h6><p>TextureView 继承了 View 的大部分特性，例如布局，事件响应等；同时</p><ul><li>作为用于图像投影的普通 View 在 UI 线程中进行绘制，具有 view 的大部分特性</li><li>内容数据要先由 SurfaceTexture 输出为 GL 外部纹理，再加入 View hierachy 作为一个硬件加速层实现 GL 投影，复杂的数据交换导致了绘制延时</li><li>接收类型为外部纹理 (GL特有) 使得其本身必须能够与GPU进行数据交换，即开启硬件加速，开销较大</li></ul><h6 id="应用领域（设计需求）：-1"><a href="#应用领域（设计需求）：-1" class="headerlink" title="应用领域（设计需求）："></a>应用领域（设计需求）：</h6><p>SurfaceView的以上特性使它成为供 GL 进行图像内容再处理的首选，但并不常用。</p><h2 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h2><ul><li><p><strong>在 Android 7.0 上系统 SurfaceView 的性能比 TextureView 更有优势</strong>，支持对象的内容位置和包含的应用内容同步更新，平移、缩放不会产生黑边。 <strong>在7.0以下系统如果使用场景有动画效果，可以选择性使用 TextureView</strong>。</p></li><li><p>由于失效 (invalidation) 和缓冲的特性，<strong>TextureView 增加了额外1~3帧的延迟显示画面更新</strong>。</p></li><li><p>TextureView 总是使用 GL 合成，而 SurfaceView 可以使用硬件 overlay 后端，可以占用更少的内存。</p></li><li><p>TextureView 的内部缓冲队列导致比 SurfaceView 使用更多的内存。</p></li><li><p>SurfaceView 内部自持有 Surface，Surface 创建、销毁、改变时由系统处理，通过 SurfaceHolder  回调通知。</p></li><li><p>当画布创建好时，可以将 Surface 绑定到 MediaPlayer 中。SurfaceView 如果为用户可见的时候，创建 SurfaceView 的 SurfaceHolder 用于显示视频流解析的帧图片，如果发现 SurfaceView 变为用户不可见的时候，则立即销毁 SurfaceView 的 SurfaceHolder，以达到节约系统资源的目的。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>基础：View</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello C++ !</title>
    <link href="/2023/975ba186bf91/"/>
    <url>/2023/975ba186bf91/</url>
    
    <content type="html"><![CDATA[<h2 id="1-C-初识"><a href="#1-C-初识" class="headerlink" title="1. C++初识"></a>1. C++初识</h2><h3 id="1-1-HellofromC"><a href="#1-1-HellofromC" class="headerlink" title="1.1 HellofromC++"></a>1.1 HellofromC++</h3><h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><p>单行 &#x2F;&#x2F; </p><p>多行 &#x2F;*  *&#x2F;</p><h3 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h3><p>数据类型 变量名 &#x3D; 初始值；（写入内容，避免Null与Any）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//取变量名</span><br><span class="hljs-meta">#x  </span><br></code></pre></td></tr></table></figure><h3 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4 常量"></a>1.4 常量</h3><p>记录程序中不可更改的数据</p><h4 id="1-4-1-define-宏常量（预编译，不占用内存）"><a href="#1-4-1-define-宏常量（预编译，不占用内存）" class="headerlink" title="1.4.1 #define 宏常量（预编译，不占用内存）"></a>1.4.1 #define 宏常量（预编译，不占用内存）</h4><p>#define 常量名 常量值；</p><h4 id="1-4-2-const修饰的变量（编译，占用内存）"><a href="#1-4-2-const修饰的变量（编译，占用内存）" class="headerlink" title="1.4.2 const修饰的变量（编译，占用内存）"></a>1.4.2 const修饰的变量（编译，占用内存）</h4><p>变量定义前加const关键字，不可修改</p><h3 id="1-5-关键字"><a href="#1-5-关键字" class="headerlink" title="1.5 关键字"></a>1.5 关键字</h3><p>C++预先保留得标识符</p><h3 id="1-5-标识符命名规则"><a href="#1-5-标识符命名规则" class="headerlink" title="1.5 标识符命名规则"></a>1.5 标识符命名规则</h3><p>由字母、数字、下划线组成；第一个字符不能为数字；字母区分大小写</p><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><p>分配内存空间的关键字</p><h3 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h3><table><thead><tr><th>数据类型</th><th>占用空间</th><th>取值范围</th></tr></thead><tbody><tr><td>short，短整型</td><td>2B</td><td>-2^15~2^15-1</td></tr><tr><td>int，整型</td><td>4B</td><td>-2^31~2^31-1</td></tr><tr><td>long，长整型</td><td>4B (Windows，Linux-32位)， 8B（Linux-64位）</td><td>-2^31~2^31-1</td></tr><tr><td>long long，长长整型</td><td>8B</td><td>-2^63~2^63-1</td></tr></tbody></table><h3 id="2-2-sizeof关键字"><a href="#2-2-sizeof关键字" class="headerlink" title="2.2 sizeof关键字"></a>2.2 sizeof关键字</h3><p>sizeof (数据类型&#x2F;变量名)，单位为字节</p><h3 id="2-3-实型（浮点型）"><a href="#2-3-实型（浮点型）" class="headerlink" title="2.3 实型（浮点型）"></a>2.3 实型（浮点型）</h3><p>单精度 float  7位有效数字</p><p>双精度 double  15~16位有效数字</p><p>默认：C++输出实型 &lt;&#x3D; 6位有效数字</p><p>科学计数法  eg：  3e2 &#x3D; 3 * 10^2     3e-2 &#x3D; 3 * 0.1^2</p><h3 id="2-4-字符型"><a href="#2-4-字符型" class="headerlink" title="2.4 字符型"></a>2.4 字符型</h3><p>char  1B</p><p>表示形式为单引号，传入内存中为ASCII码，强转int后可查看, a - 97, A - 65</p><p>ASCII码：</p><p>​1.非打印控制字符：0~31，用于控制外围设备</p><p>​2.打印字符：32~126，键盘</p><h3 id="2-5-转义字符"><a href="#2-5-转义字符" class="headerlink" title="2.5 转义字符"></a>2.5 转义字符</h3><p>列举几项：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">\a  =  警报<br>\n  =  换行<br>\t  =  水平制表，跳至下一个tab（<span class="hljs-number">8</span>位光标）<br>\\  =  \<br>\<span class="hljs-string">&#x27;  =  &#x27;</span><br>\<span class="hljs-string">&quot;  =  &quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-6-字符串型"><a href="#2-6-字符串型" class="headerlink" title="2.6 字符串型"></a>2.6 字符串型</h3><p>本质为字符数组，表示形式为双引号</p><ul><li>C风格：char Name[] &#x3D; “……”</li><li>C++风格：string Name &#x3D; “……”</li></ul><h3 id="2-7-布尔类型-bool"><a href="#2-7-布尔类型-bool" class="headerlink" title="2.7 布尔类型 bool"></a>2.7 布尔类型 bool</h3><p>bool类型占1B，只有两个值</p><ul><li>true  —真 （本质为1）</li><li>false —假 （本质为0）</li></ul><h3 id="2-8-数据输入"><a href="#2-8-数据输入" class="headerlink" title="2.8 数据输入"></a>2.8 数据输入</h3><p>从键盘获取数据</p><p>cin &gt;&gt; 变量</p><h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h2><p>执行代码的运算</p><table><thead><tr><th>运算符类型</th><th>作用</th></tr></thead><tbody><tr><td>算术运算符</td><td>四则运算</td></tr><tr><td>赋值运算符</td><td>表达式给变量赋值</td></tr><tr><td>比较运算符</td><td>比较表达式，返回真&#x2F;假</td></tr><tr><td>逻辑运算符</td><td>逻辑运算，返回真&#x2F;假</td></tr></tbody></table><h3 id="3-1-算数运算符"><a href="#3-1-算数运算符" class="headerlink" title="3.1 算数运算符"></a>3.1 算数运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">+ - * / % ++ --<br></code></pre></td></tr></table></figure><p>除法运算除数 !&#x3D; 0</p><p>小数不可取模运算</p><p>a++: 存储变量a，对变量a进行递增（副本），语句结束赋值回a</p><p>++a: 对变量a进行递增</p><h3 id="3-2-赋值运算符"><a href="#3-2-赋值运算符" class="headerlink" title="3.2 赋值运算符"></a>3.2 赋值运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">= += -= *= /= %=<br></code></pre></td></tr></table></figure><h3 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">== != &gt; &lt; &gt;= &lt;=<br></code></pre></td></tr></table></figure><p>结果为0或1</p><h3 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h3><table><thead><tr><th>运算符</th><th>术语</th><th>结果</th></tr></thead><tbody><tr><td>！</td><td>非</td><td>a为假，!a为真；a为真，!a为假</td></tr><tr><td>&amp;&amp;</td><td>与</td><td>a与b都为真，a&amp;&amp;b为真，否则为假</td></tr><tr><td>||</td><td>或</td><td>a与b都为假，a||b为假，否则为真</td></tr></tbody></table><h2 id="4-程序流程结构"><a href="#4-程序流程结构" class="headerlink" title="4. 程序流程结构"></a>4. 程序流程结构</h2><p>三种基本的程序运行结构：</p><ul><li>顺序结构：顺序执行，不发生跳转</li><li>选择结构：依据条件选择执行</li><li>循环结构：依据条件循环执行</li></ul><h3 id="4-1-选择结构"><a href="#4-1-选择结构" class="headerlink" title="4.1 选择结构"></a>4.1 选择结构</h3><h4 id="4-1-1-if语句"><a href="#4-1-1-if语句" class="headerlink" title="4.1.1 if语句"></a>4.1.1 if语句</h4><ul><li>单行格式if语句</li><li>多行格式if语句</li><li>多条件的if语句</li></ul><h4 id="4-1-2-三目运算符"><a href="#4-1-2-三目运算符" class="headerlink" title="4.1.2 三目运算符"></a>4.1.2 三目运算符</h4><p>取 MAX(a, b) 赋值于 c</p><ul><li>c &#x3D; a &gt; b ? a : b</li></ul><h4 id="4-1-3-switch语句"><a href="#4-1-3-switch语句" class="headerlink" title="4.1.3 switch语句"></a>4.1.3 switch语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span>(表达式：整型或字符型)&#123;<br><span class="hljs-keyword">case</span> 结果<span class="hljs-number">1</span>: 执行语句; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> 结果<span class="hljs-number">2</span>: 执行语句; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> 结果<span class="hljs-number">3</span>: 执行语句; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>: 执行语句; <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结构清晰，执行效率高</p><h3 id="4-2-循环结构"><a href="#4-2-循环结构" class="headerlink" title="4.2 循环结构"></a>4.2 循环结构</h3><h4 id="4-2-1-while循环语句"><a href="#4-2-1-while循环语句" class="headerlink" title="4.2.1 while循环语句"></a>4.2.1 while循环语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(循环条件)&#123;循环语句&#125;<br></code></pre></td></tr></table></figure><p>只要循环条件的结果为真，就执行循环语句</p><p>注意事项：避免死循环的出现，即必须提供退出循环的接口</p><ul><li><p>案例：猜数字 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<span class="hljs-comment">//根据系统时间生成随机数</span><br><br><span class="hljs-type">int</span> num = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span>; <span class="hljs-comment">//生成0~99随机数(伪随机数)</span><br>cout &lt;&lt; num &lt;&lt; endl;<br><br><span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>cin &gt;&gt; val;<br><span class="hljs-keyword">if</span> (val &gt; num) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;猜测过大&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &lt; num) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;猜测过小&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;您猜对了&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//跳出当前循环</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-2-2-do……while循环语句"><a href="#4-2-2-do……while循环语句" class="headerlink" title="4.2.2 do……while循环语句"></a>4.2.2 do……while循环语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span>&#123;循环语句&#125;<span class="hljs-keyword">while</span>(循环条件)<br></code></pre></td></tr></table></figure><p>与while语句的区别为先执行一次循环语句，再判断循环条件</p><ul><li><p>案例：水仙花数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> num = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-type">int</span> a = num % <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = num / <span class="hljs-number">10</span> % <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> c = num / <span class="hljs-number">10</span> / <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> d = a*a*a + b*b*b + c*c*c;<br>    <span class="hljs-keyword">if</span> (num == d) &#123;<br>        cout &lt;&lt; num &lt;&lt; endl;<br>    &#125;<br>    num++;<br>&#125; <span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-2-3-for循环语句"><a href="#4-2-3-for循环语句" class="headerlink" title="4.2.3 for循环语句"></a>4.2.3 for循环语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(起始表达式；条件表达式；末尾循环体)&#123;循环语句&#125;<br></code></pre></td></tr></table></figure><ul><li>案例：敲桌子</li></ul><h4 id="4-2-4-嵌套循环"><a href="#4-2-4-嵌套循环" class="headerlink" title="4.2.4 嵌套循环"></a>4.2.4 嵌套循环</h4><p>在循环中嵌套循环，用于处理“多维”问题</p><p>外层执行一次，内层执行一周</p><ul><li><p>案例：乘法口诀表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; ++i) <span class="hljs-comment">//行&#123;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) <span class="hljs-comment">//列&#123;</span><br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; i * j&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-3-跳转语句"><a href="#4-3-跳转语句" class="headerlink" title="4.3 跳转语句"></a>4.3 跳转语句</h3><h4 id="4-3-1-break语句"><a href="#4-3-1-break语句" class="headerlink" title="4.3.1 break语句"></a>4.3.1 break语句</h4><p>使用时机：</p><ul><li>switch选择语句</li><li>循环语句</li></ul><h4 id="4-3-2-continue语句"><a href="#4-3-2-continue语句" class="headerlink" title="4.3.2 continue语句"></a>4.3.2 continue语句</h4><p>在循环语句中，跳过本次循环，继续执行下一次循环</p><h4 id="4-3-3-goto语句"><a href="#4-3-3-goto语句" class="headerlink" title="4.3.3 goto语句"></a>4.3.3 goto语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">goto</span> 标记；<br></code></pre></td></tr></table></figure><p>标记格式为 标记名 + “:”</p><p>若标记存在，则跳转到标记的位置</p><p>不推荐使用，会破环程序空间局部性和代码结构</p><h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>存放相同类型数据的集合</p><ul><li>特点1：每个数据元素的类型相同</li><li>特点2：物理上，内存连续</li></ul><h3 id="5-2-一维数组"><a href="#5-2-一维数组" class="headerlink" title="5.2 一维数组"></a>5.2 一维数组</h3><h4 id="5-2-1-一维数组的定义方式"><a href="#5-2-1-一维数组的定义方式" class="headerlink" title="5.2.1 一维数组的定义方式"></a>5.2.1 一维数组的定义方式</h4><p>三种定义方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span> 数据类型 数组名[数组长度]；<br><br><span class="hljs-comment">//定义时初始化，未初始化的内存会分配 0</span><br><span class="hljs-number">2.</span> 数据类型 数组名[数组长度] = &#123;值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>，值<span class="hljs-number">3</span>，......&#125;<br><span class="hljs-number">3.</span> 数据类型 数组名[] = &#123;值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>，值<span class="hljs-number">3</span>，......&#125;<br><br>eg:  <span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>];<br>通过下标（[序号]，从<span class="hljs-number">0</span>开始）访存，arr[<span class="hljs-number">0</span>]，arr[<span class="hljs-number">1</span>]，arr[<span class="hljs-number">2</span>]，......<br></code></pre></td></tr></table></figure><h4 id="5-2-2-一维数组的数组名"><a href="#5-2-2-一维数组的数组名" class="headerlink" title="5.2.2 一维数组的数组名"></a>5.2.2 一维数组的数组名</h4><ul><li>统计数组长度                                            sizeof(arr)</li><li>获取数组首地址或首元素地址                 arr</li></ul><p>数组名为常量，不可被赋值</p><ul><li><p>案例：五只小猪称体重</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">300</span>,<span class="hljs-number">350</span>,<span class="hljs-number">200</span>,<span class="hljs-number">400</span>,<span class="hljs-number">250</span> &#125;;<br><span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] &gt; max)&#123;<br>        max = arr[i];<br>    &#125;<br>&#125;<br>cout &lt;&lt; max &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li><li><p>案例：数组逆置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;; <span class="hljs-comment">//目标数组</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;逆置前：&quot;</span>  &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i)&#123;<br>    cout &lt;&lt; arr[i] &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; <span class="hljs-comment">//首指针</span><br><span class="hljs-type">int</span> end = <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>; <span class="hljs-comment">//尾指针</span><br><span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>    <span class="hljs-type">int</span> temp = arr[start];<br>    arr[start] = arr[end];<br>    arr[end] = temp;<br>    ++start;<br>    --end;<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;逆置后：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i)&#123;<br>    cout &lt;&lt; arr[i] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="5-2-3-冒泡排序"><a href="#5-2-3-冒泡排序" class="headerlink" title="5.2.3 冒泡排序"></a>5.2.3 冒泡排序</h4><p>对数组内的元素进行排序，具体执行：</p><ol><li>比较相邻的元素，通过交换保证较大元素右侧</li><li>一轮过后，会得到最大元素（尾元素）——”冒泡“</li><li>重复以上步骤，但比较次数-1，因为最大元素已经确定</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span> &#125;;<br>cout &lt;&lt; <span class="hljs-string">&quot;排序前：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i)&#123;<br>    cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//冒泡排序执行 [9-1=8] 轮，每轮确定一个最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i) &#123;<br>    <span class="hljs-comment">//每轮执行 [当前元素个数-1] 次对比</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span> - i - <span class="hljs-number">1</span>; ++j) &#123;<br>        <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-type">int</span> temp = arr[j];<br>            arr[j] = arr[j+<span class="hljs-number">1</span>];<br>            arr[j+<span class="hljs-number">1</span>] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;排序后：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i) &#123;<br>    cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-二维数组"><a href="#5-3-二维数组" class="headerlink" title="5.3 二维数组"></a>5.3 二维数组</h3><p>增加数组维度</p><h4 id="5-3-1-二维数组的定义方式"><a href="#5-3-1-二维数组的定义方式" class="headerlink" title="5.3.1 二维数组的定义方式"></a>5.3.1 二维数组的定义方式</h4><p>四种定义方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span> 数据类型 数组名[行数][列数]；<br><span class="hljs-number">2.</span> 数据类型 数组名[行数][列数] = <span class="hljs-comment">//推荐使用</span><br>&#123; <br>&#123;值<span class="hljs-number">0</span>_1，值<span class="hljs-number">0</span>_2，......&#125;，<br>&#123;值<span class="hljs-number">1</span>_1，值<span class="hljs-number">1</span>_2，......&#125;，<br>......<br>&#125;；<br><span class="hljs-number">3.</span> 数据类型 数组名[行数][列数] = &#123;值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>，值<span class="hljs-number">3</span>，值<span class="hljs-number">4</span>，......&#125;；<br><span class="hljs-number">4.</span> 数据类型 数组名[][列数] = &#123;值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>，值<span class="hljs-number">3</span>，值<span class="hljs-number">4</span>，......&#125;；<br><br>eg:  <span class="hljs-type">int</span> arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]<br>通过下标（[行号][列号]，从<span class="hljs-number">0</span>开始）访存，arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]，arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]，arr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]，......<br></code></pre></td></tr></table></figure><h4 id="5-3-2-二维数组的数组名"><a href="#5-3-2-二维数组的数组名" class="headerlink" title="5.3.2 二维数组的数组名"></a>5.3.2 二维数组的数组名</h4><ul><li>统计数组长度                                                              sizeof(arr)</li><li>统计数组每行长度                                                      sizeof(arr[行号])</li><li>获取数组首地址或首行地址或首元素地址                arr</li></ul><p>数组名为常量，不可被赋值</p><h4 id="5-3-3-二维数组应用案例"><a href="#5-3-3-二维数组应用案例" class="headerlink" title="5.3.3 二维数组应用案例"></a>5.3.3 二维数组应用案例</h4><p>考试成绩统计</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>]=<br>&#123;<br>&#123; <span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span> &#125;,<br>&#123; <span class="hljs-number">90</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span> &#125;,<br>&#123; <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; ++j)&#123;<br>        sum += arr[i][j];<br>        cout &lt;&lt; arr[i][j] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;第 &quot;</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;个同学的总分为：&quot;</span> &lt;&lt; sum &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p>将一段经常使用的代码封装起来，减少重复代码——程序块</p><h3 id="6-2-函数的定义"><a href="#6-2-函数的定义" class="headerlink" title="6.2 函数的定义"></a>6.2 函数的定义</h3><p>函数的定义一般分为五部分：</p><ol><li>返回值类型</li><li>函数名</li><li>参数声明列表——形参</li><li>函数体语句</li><li>return表达式</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">返回值类型 函数名 （参数声明列表）&#123;<br>函数体语句；<br><span class="hljs-keyword">return</span>表达式；<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-函数的调用"><a href="#6-3-函数的调用" class="headerlink" title="6.3 函数的调用"></a>6.3 函数的调用</h3><p>传入具体的参数——实参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">函数名（参数值列表）；<br></code></pre></td></tr></table></figure><p>调用时，实参的值会传递给形参</p><h3 id="6-4-值传递"><a href="#6-4-值传递" class="headerlink" title="6.4 值传递"></a>6.4 值传递</h3><p>函数调用时，实参的值会传递给形参，并不受形参的影响</p><h3 id="6-5-函数的常见样式"><a href="#6-5-函数的常见样式" class="headerlink" title="6.5 函数的常见样式"></a>6.5 函数的常见样式</h3><p>常见的函数样式有四种：</p><ol><li>无参无返</li><li>有参无返</li><li>无参有返</li><li>有参有返</li></ol><h3 id="6-6-函数的声明"><a href="#6-6-函数的声明" class="headerlink" title="6.6 函数的声明"></a>6.6 函数的声明</h3><p>向编译器声明函数信息（一般情况下代码逐行执行，意味着函数定义必须写于调用之前，为了改善这种强秩序，引入声明机制）</p><p>函数的实际主体可以单独定义，但必须唯一</p><h3 id="6-7-函数的分文件编写"><a href="#6-7-函数的分文件编写" class="headerlink" title="6.7 函数的分文件编写"></a>6.7 函数的分文件编写</h3><p>让代码结构更加清晰，一般分为四个步骤：</p><ol><li>创建后缀为.hpp的头文件</li><li>创建后缀为.cpp的源文件</li><li>在头文件中写函数的声明</li><li>在源文件中写函数的定义</li></ol><p>通过  #include ”……“  包含自定义的头文件</p><h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7. 指针"></a>7. 指针</h2><h3 id="7-1-指针的基本概念"><a href="#7-1-指针的基本概念" class="headerlink" title="7.1 指针的基本概念"></a>7.1 指针的基本概念</h3><p>可以通过指针间接访问内存</p><ul><li>内存编号从0开始记录，为十六进制数字</li><li>指针变量用于保存地址</li><li>指针本质上是一个对象</li></ul><h3 id="7-2-指针变量的定义和使用"><a href="#7-2-指针变量的定义和使用" class="headerlink" title="7.2 指针变量的定义和使用"></a>7.2 指针变量的定义和使用</h3><p>指针类型声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">数据类型* 指针变量名；<br>数据类型* 指针变量名 = 指针变量；<br></code></pre></td></tr></table></figure><p>取地址与解地址：</p><p>符号* 本质上为算术运算符，即先查左值后查右值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">数据类型 数据变量名；<br>*数据变量名   <span class="hljs-comment">//取地址为指针类型</span><br><br>指针类型 指针变量名；<br>&amp;指针变量名   <span class="hljs-comment">//解地址为数据类型</span><br></code></pre></td></tr></table></figure><h3 id="7-3-指针所占内存空间"><a href="#7-3-指针所占内存空间" class="headerlink" title="7.3 指针所占内存空间"></a>7.3 指针所占内存空间</h3><p>32位操作系统下：占用4字节内存空间</p><p>64位操作系统下：占用8字节内存空间</p><h3 id="7-4-空指针和野指针"><a href="#7-4-空指针和野指针" class="headerlink" title="7.4 空指针和野指针"></a>7.4 空指针和野指针</h3><ul><li>空指针：指针变量指向内存中编号为0的空间——指针初始状态</li></ul><p>空指针指向的内存不可访问（0~255内存编号由系统使用）</p><ul><li>野指针：指针变量指向非法空间</li></ul><ol><li>指针未初始化</li><li>指针局部初始化</li></ol><p>野指针指向内存不可访问（无访问权限）</p><h3 id="7-5-const修饰指针"><a href="#7-5-const修饰指针" class="headerlink" title="7.5 const修饰指针"></a>7.5 const修饰指针</h3><p>const关键字 修饰变量</p><p>*运算符 对右侧变量 (地址) 取值；为右侧变量赋左侧类型的地址——指针声明)</p><ol><li>const修饰指针：常量指针（底层const）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p = &amp;a; <span class="hljs-comment">//const右侧为数据类型（默认变量入栈），const修饰此变量，约束数据   int const* p</span><br>p = &amp;b; <br></code></pre></td></tr></table></figure><ol start="2"><li>const修饰常量：指针常量（顶层const）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a; <span class="hljs-comment">//const右侧为指针变量（指针变量入栈），const修饰指针变量，约束指针  </span><br>*p = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>const既修饰指针又修饰常量</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a; <span class="hljs-comment">//完全约束</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;思考：*运算符本质为重载&#x3D;&#x3D;</p><ol><li><p>&#x3D;&#x3D;左侧为类型，右侧为变量时：指针声明，将左侧默认变量取地址赋给指针变量&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;仅右侧为变量时：解地址&#x3D;&#x3D;</p></li></ol><h3 id="7-6-指针和数组"><a href="#7-6-指针和数组" class="headerlink" title="7.6 指针和数组"></a>7.6 指针和数组</h3><p>利用指针访问数组中的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;<br>cout &lt;&lt; arr[<span class="hljs-number">0</span>] &lt;&lt; endl;                 <span class="hljs-comment">//打印 1</span><br>cout &lt;&lt; *arr &lt;&lt; endl;                   <span class="hljs-comment">//打印 1</span><br><span class="hljs-type">int</span>*p = arr;                            <span class="hljs-comment">//数组名arr不能被修改</span><br>p++;<br>cout &lt;&lt; *p &lt;&lt; endl;                     <span class="hljs-comment">//打印 2，若打印*p++或*(p++) 仍为1</span><br></code></pre></td></tr></table></figure><h3 id="7-7-指针和函数"><a href="#7-7-指针和函数" class="headerlink" title="7.7 指针和函数"></a>7.7 指针和函数</h3><p>利用指针传入函数修改实参的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> temp = *p1;<br>*p1 = * p2;<br>*p2 = temp;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;运算的本质就是操作地址，传入指针相当于自己拥有操作权，否则为系统默认&#x3D;&#x3D;</p><h3 id="7-8-指针和函数"><a href="#7-8-指针和函数" class="headerlink" title="7.8 指针和函数"></a>7.8 指针和函数</h3><p>案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> len)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; ++j) &#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br><span class="hljs-type">int</span> temp = arr[j];<br>arr[j] = arr[j + <span class="hljs-number">1</span>];<br>arr[j + <span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8. 结构体"></a>8. 结构体</h2><h3 id="8-1-结构体基本概念"><a href="#8-1-结构体基本概念" class="headerlink" title="8.1 结构体基本概念"></a>8.1 结构体基本概念</h3><p>结构体属于用户自定义的数据类型，允许用户存储不同的数据类型</p><h3 id="8-2-结构体定义和使用"><a href="#8-2-结构体定义和使用" class="headerlink" title="8.2 结构体定义和使用"></a>8.2 结构体定义和使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> 结构体名 &#123;<br>类型名 成员<span class="hljs-number">1</span>；<br>    类型名 成员<span class="hljs-number">2</span>；<br>    ......<br>&#125;;<br></code></pre></td></tr></table></figure><p>通过结构体创建变量的方式有三种：</p><p>struct 关键字可以省略</p><ul><li>struct 结构体名 变量名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> 结构体名 变量名；<br><span class="hljs-comment">//结构体变量名.成员名 可以访问结构体成员</span><br>变量名.成员<span class="hljs-number">1</span> = ...；<br>变量名.成员<span class="hljs-number">2</span> = ...；<br>......<br></code></pre></td></tr></table></figure><ul><li>struct 结构体名 变量名 &#x3D; {成员1的值，成员2的值，……}</li><li>定义结构体时同步创建变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> 结构体名 &#123;<br>类型名 成员<span class="hljs-number">1</span>；<br>    类型名 成员<span class="hljs-number">2</span>；<br>    ......<br>&#125; 变量名;<br></code></pre></td></tr></table></figure><h3 id="8-3-结构体数组"><a href="#8-3-结构体数组" class="headerlink" title="8.3 结构体数组"></a>8.3 结构体数组</h3><p>将自定义结构体作为数组元素.</p><h3 id="8-4-结构体指针"><a href="#8-4-结构体指针" class="headerlink" title="8.4 结构体指针"></a>8.4 结构体指针</h3><p>通过指针访问结构体成员.</p><ul><li>利用操作符 -&gt; 可以通过结构体指针访问结构体属性.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">struct</span> 结构体名 指针变量名 = &amp;变量名；<br><br><span class="hljs-comment">//结构体指针变量名-&gt;成员名 可以访问结构体成员</span><br>变量名-&gt;成员<span class="hljs-number">1</span> = ...；<br>变量名-&gt;成员<span class="hljs-number">2</span> = ...；<br>......<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;变量未初始化时，C++的行为是未知的，编译器通常会用error来制止这一行为.&#x3D;&#x3D;</p><h3 id="8-5-结构体嵌套结构体"><a href="#8-5-结构体嵌套结构体" class="headerlink" title="8.5 结构体嵌套结构体"></a>8.5 结构体嵌套结构体</h3><p>结构体中的成员可以是另一个结构体  </p><h3 id="8-6-结构体做函数参数"><a href="#8-6-结构体做函数参数" class="headerlink" title="8.6 结构体做函数参数"></a>8.6 结构体做函数参数</h3><p>将结构体作为参数向函数中传递.</p><ul><li>值传递</li><li>地址传递</li></ul><h3 id="8-7-结构体中const使用场景"><a href="#8-7-结构体中const使用场景" class="headerlink" title="8.7 结构体中const使用场景"></a>8.7 结构体中const使用场景</h3><p>使用地址传递节省传递开销，为了只读，需要使用const修饰.</p><h3 id="8-8-结构体案例"><a href="#8-8-结构体案例" class="headerlink" title="8.8 结构体案例"></a>8.8 结构体案例</h3><p>使用地址传递节省传递开销，为了只读，需要使用const修饰.</p><h4 id="8-8-1-案例一"><a href="#8-8-1-案例一" class="headerlink" title="8.8.1 案例一"></a>8.8.1 案例一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>string sName;<br><span class="hljs-type">int</span> score;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Teacher</span> &#123;<br>string tName;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> sArray[<span class="hljs-number">5</span>];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">allocate_print</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Teacher tArray[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>string nameSeed = <span class="hljs-string">&quot;ABCDE&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>tArray[i].tName = <span class="hljs-string">&quot;Teacher_&quot;</span>;<br>tArray[i].tName += nameSeed[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;老师姓名：&quot;</span> &lt;&lt; tArray[i].tName &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; ++j) &#123;<br>tArray[i].sArray[j].sName = <span class="hljs-string">&quot;Student_&quot;</span>;<br>tArray[i].sArray[j].sName += nameSeed[j];<br><span class="hljs-type">int</span> random = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>;<br>tArray[i].sArray[j].score = random;<br>cout &lt;&lt; <span class="hljs-string">&quot;\t学生姓名&quot;</span> &lt;&lt; tArray[i].sArray[j].sName <br>                 &lt;&lt; <span class="hljs-string">&quot; 考试分数：&quot;</span> &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Teacher</span> tArray[<span class="hljs-number">3</span>];<br><span class="hljs-built_in">allocate_print</span>(tArray, <span class="hljs-built_in">size</span>(tArray));<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="8-8-2-案例二"><a href="#8-8-2-案例二" class="headerlink" title="8.8.2 案例二"></a>8.8.2 案例二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hero</span> &#123;<br>string name;<br><span class="hljs-type">int</span> age;<br>    string sex;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort_print</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Hero heroArray[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; ++j) &#123;<br><span class="hljs-keyword">if</span> (heroArray[j].age &gt; heroArray[j + <span class="hljs-number">1</span>].age) &#123;<br><span class="hljs-type">int</span> temp = heroArray[j];<br>heroArray[j] = heroArray[j+<span class="hljs-number">1</span>];<br>heroArray[j+<span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>&#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span>&lt;&lt; heroArray[i].name<br>             &lt;&lt; <span class="hljs-string">&quot;年龄：&quot;</span>&lt;&lt; heroArray[i].age<br>             &lt;&lt; <span class="hljs-string">&quot;性别：&quot;</span>&lt;&lt; heroArray[i].sex &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hero</span> heroArray[<span class="hljs-number">5</span>] = <br>    &#123;<br>        &#123;<span class="hljs-string">&quot;刘备&quot;</span>，<span class="hljs-number">23</span>，<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;关羽&quot;</span>，<span class="hljs-number">22</span>，<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;张飞&quot;</span>，<span class="hljs-number">20</span>，<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;吕布&quot;</span>，<span class="hljs-number">21</span>，<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;貂蝉&quot;</span>，<span class="hljs-number">19</span>，<span class="hljs-string">&quot;女&quot;</span>&#125;,   <br>    &#125;;<br>    <span class="hljs-built_in">bubbleSort_print</span>(heroArray,<span class="hljs-built_in">size</span>(heroArray));<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OOP</category>
      
      <category>基础：语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
