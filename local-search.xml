<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>埃隆·马斯克传</title>
    <link href="/2024/054312592e88/"/>
    <url>/2024/054312592e88/</url>
    
    <content type="html"><![CDATA[<iframe src="/pdf/web/viewer.html?file=/pdf/Elon Musk.pdf" width="100%" height="500px"></iframe><p><a href="https://img.hello-yzg.cn/Reader+%23+Elon+Musk-001.pdf">快速跳转</a></p>]]></content>
    
    
    <categories>
      
      <category>Masterpiece Reading</category>
      
      <category>Story</category>
      
      <category>商业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>???</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四数之和</title>
    <link href="/2024/f1ca26701645/"/>
    <url>/2024/f1ca26701645/</url>
    
    <content type="html"><![CDATA[<h3 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h3><blockquote><p>C++ Tips</p><ol><li>数组 auto 排序：sort(auto.begin(), auto.end())</li></ol><p>Java Tips</p><ol><li>数组auto排序：Arrays.sort(auto)</li></ol><p>Python Tips</p><ol><li>数组auto排序：auto.sort()</li></ol><p>JavaScript Tips</p><ol><li>数组auto排序：auto.sort((a, b) &#x3D;&gt; a - b) 为升序排序；auto.sort((a, b) &#x3D;&gt; b - a) 为降序排序</li></ol></blockquote><p>题目：</p><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案 。</p><h4 id="有序双指针"><a href="#有序双指针" class="headerlink" title="有序双指针"></a>有序双指针</h4><p>时间复杂度：$O(n^3)$</p><p>空间复杂度：$O(1)$</p><h5 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//c++</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; a &lt; n - <span class="hljs-number">3</span>; ++a)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> x = nums[a]; <span class="hljs-comment">// 保证计算不会溢出（参考操作数与结果类型规则）</span><br>            <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span> &amp;&amp; x == nums[a - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (x + nums[a + <span class="hljs-number">1</span>] + nums[a + <span class="hljs-number">2</span>] + nums[a + <span class="hljs-number">3</span>] &gt; target) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (x + nums[n - <span class="hljs-number">3</span>] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = a + <span class="hljs-number">1</span>; b &lt; n - <span class="hljs-number">2</span>; ++b)&#123;<br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> y = nums[b]; <span class="hljs-comment">// 保证计算不会溢出（参考操作数与结果类型规则）</span><br>                <span class="hljs-keyword">if</span> (b &gt; a + <span class="hljs-number">1</span> &amp;&amp; y == nums[b - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (x + y + nums[b + <span class="hljs-number">1</span>] + nums[b + <span class="hljs-number">2</span>] &gt; target) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">if</span> (x + y + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> c = b + <span class="hljs-number">1</span>, d = n - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (c &lt; d)&#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-type">long</span> s = x + y + nums[c] + nums[d];<br>                    <span class="hljs-keyword">if</span> (s &gt; target) --d;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &lt; target) ++c;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        ans.<span class="hljs-built_in">push_back</span>(&#123;(<span class="hljs-type">int</span>) x, (<span class="hljs-type">int</span>) y, nums[c], nums[d]&#125;);<br>                        <span class="hljs-keyword">for</span>(++c; c &lt; d &amp;&amp; nums[c] == nums[c - <span class="hljs-number">1</span>]; ++c);<br>                        <span class="hljs-keyword">for</span>(--d; d &gt; c &amp;&amp; nums[d] == nums[d + <span class="hljs-number">1</span>]; --d);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(nums);<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; a &lt; n -<span class="hljs-number">3</span>; ++a)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[a];<br>            <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span> &amp;&amp; x == nums[a - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (x + nums[a + <span class="hljs-number">1</span>] + nums[a + <span class="hljs-number">2</span>] + nums[a + <span class="hljs-number">3</span>] &gt; target) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (x + nums[n - <span class="hljs-number">3</span>] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a + <span class="hljs-number">1</span>; b &lt; n - <span class="hljs-number">2</span>; ++b)&#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> nums[b];<br>                <span class="hljs-keyword">if</span> (b &gt; a + <span class="hljs-number">1</span> &amp;&amp; y == nums[b - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (x + y + nums[b + <span class="hljs-number">1</span>] + nums[b + <span class="hljs-number">2</span>] &gt; target) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">if</span> (x + y + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> b + <span class="hljs-number">1</span>, d = n - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (c &lt; d)&#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> x + y + nums[c] + nums[d];<br>                    <span class="hljs-keyword">if</span> (s &gt; target) --d;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &lt; target) ++c;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        ans.add(List.of((<span class="hljs-type">int</span>) x, (<span class="hljs-type">int</span>) y, nums[c], nums[d]));<br>                        <span class="hljs-keyword">for</span> (++c; c &lt; d &amp;&amp; nums[c] == nums[c - <span class="hljs-number">1</span>]; ++c);<br>                        <span class="hljs-keyword">for</span> (--d; d &gt; c &amp;&amp; nums[d] == nums[d + <span class="hljs-number">1</span>]; --d);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="python"><a href="#python" class="headerlink" title="python"></a>python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#python3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fourSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        nums.sort()<br>        ans = []<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">3</span>):<br>            x = nums[a]<br>            <span class="hljs-keyword">if</span> a <span class="hljs-keyword">and</span> x == nums[a - <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> x + nums[a + <span class="hljs-number">1</span>] + nums[a + <span class="hljs-number">2</span>] + nums[a + <span class="hljs-number">3</span>] &gt; target:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> x + nums[-<span class="hljs-number">3</span>] + nums[-<span class="hljs-number">2</span>] + nums[-<span class="hljs-number">1</span>] &lt; target:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(a + <span class="hljs-number">1</span>, n - <span class="hljs-number">2</span>):<br>                y = nums[b]<br>                <span class="hljs-keyword">if</span> b &gt; a + <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> y == nums[b - <span class="hljs-number">1</span>]:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">if</span> x + y + nums[b + <span class="hljs-number">1</span>] + nums[b + <span class="hljs-number">2</span>] &gt; target:<br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">if</span> x + y + nums[-<span class="hljs-number">2</span>] + nums[-<span class="hljs-number">1</span>] &lt; target:<br>                    <span class="hljs-keyword">continue</span><br>                c = b + <span class="hljs-number">1</span><br>                d = n - <span class="hljs-number">1</span><br>                <span class="hljs-keyword">while</span> c &lt; d:<br>                    s = x + y + nums[c] + nums[d]<br>                    <span class="hljs-keyword">if</span> s &gt; target:<br>                        d -= <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">elif</span> s &lt; target:<br>                        c += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        ans.append([x, y, nums[c], nums[d]])<br>                        c += <span class="hljs-number">1</span><br>                        <span class="hljs-keyword">while</span> c &lt; d <span class="hljs-keyword">and</span> nums[c] == nums[c - <span class="hljs-number">1</span>]:<br>                            c += <span class="hljs-number">1</span><br>                        d -= <span class="hljs-number">1</span><br>                        <span class="hljs-keyword">while</span> d &gt; c <span class="hljs-keyword">and</span> nums[d] == nums[d + <span class="hljs-number">1</span>]:<br>                            d -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h5 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span> &#123;<br>    <span class="hljs-keyword">return</span> (*(<span class="hljs-type">int</span> *)a - *(<span class="hljs-type">int</span> *)b);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Return an array of arrays of size *returnSize.</span><br><span class="hljs-comment"> * The sizes of the arrays are returned as *returnColumnSizes array.</span><br><span class="hljs-comment"> * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span>** <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span>* returnSize, <span class="hljs-type">int</span>** returnColumnSizes)</span> &#123;<br>    qsort(nums, numsSize, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>), compare);<br><br>    <span class="hljs-type">int</span>** ans = (<span class="hljs-type">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>*) * (numsSize * numsSize));<br>    *returnColumnSizes = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * (numsSize * numsSize));<br>    *returnSize = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; a &lt; numsSize - <span class="hljs-number">3</span>; ++a) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> x = nums[a];<br>        <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span> &amp;&amp; x == nums[a - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (x + nums[a + <span class="hljs-number">1</span>] + nums[a + <span class="hljs-number">2</span>] + nums[a + <span class="hljs-number">3</span>] &gt; target) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (x + nums[numsSize - <span class="hljs-number">3</span>] + nums[numsSize - <span class="hljs-number">2</span>] + nums[numsSize - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">continue</span>;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = a + <span class="hljs-number">1</span>; b &lt; numsSize - <span class="hljs-number">2</span>; ++b)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> y = nums[b];<br>            <span class="hljs-keyword">if</span> (b &gt; a + <span class="hljs-number">1</span> &amp;&amp; y == nums[b - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (x + y + nums[b + <span class="hljs-number">1</span>] + nums[b + <span class="hljs-number">2</span>] &gt; target) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (x + y + nums[numsSize - <span class="hljs-number">2</span>] + nums[numsSize - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> c = b + <span class="hljs-number">1</span>, d = numsSize - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (c &lt; d) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> s = x + y + nums[c] + nums[d];<br>                <span class="hljs-keyword">if</span> (s &gt; target) --d;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &lt; target) ++c;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">int</span>* quadruplet = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">4</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>                    quadruplet[<span class="hljs-number">0</span>] = x;<br>                    quadruplet[<span class="hljs-number">1</span>] = y;<br>                    quadruplet[<span class="hljs-number">2</span>] = nums[c];<br>                    quadruplet[<span class="hljs-number">3</span>] = nums[d];<br>                    ans[*returnSize] = quadruplet;<br>                    (*returnColumnSizes)[*returnSize] = <span class="hljs-number">4</span>;<br>                    (*returnSize)++;<br>                    <span class="hljs-keyword">for</span>(++c; c &lt; d &amp;&amp; nums[c] == nums[c - <span class="hljs-number">1</span>]; ++c);<br>                    <span class="hljs-keyword">for</span>(--d; d &gt; c &amp;&amp; nums[d] == nums[d + <span class="hljs-number">1</span>]; --d);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//javascript</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[][]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> fourSum = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) &#123;<br>    nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>    <span class="hljs-keyword">const</span> n = nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> ans = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>; a &lt; n - <span class="hljs-number">3</span>; a++) &#123;<br>        <span class="hljs-keyword">const</span> x = nums[a];<br>        <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span> &amp;&amp; x === nums[a - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (x + nums[a + <span class="hljs-number">1</span>] + nums[a + <span class="hljs-number">2</span>] + nums[a + <span class="hljs-number">3</span>] &gt; target) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (x + nums[n - <span class="hljs-number">3</span>] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> b = a + <span class="hljs-number">1</span>; b &lt; n - <span class="hljs-number">2</span>; b++) &#123;<br>            <span class="hljs-keyword">const</span> y = nums[b];<br>            <span class="hljs-keyword">if</span> (b &gt; a + <span class="hljs-number">1</span> &amp;&amp; y === nums[b - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (x + y + nums[b + <span class="hljs-number">1</span>] + nums[b + <span class="hljs-number">2</span>] &gt; target) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (x + y + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">let</span> c = b + <span class="hljs-number">1</span>, d = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (c &lt; d) &#123;<br>                <span class="hljs-keyword">const</span> s = x + y + nums[c] + nums[d];<br>                <span class="hljs-keyword">if</span> (s &gt; target) d--;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &lt; target) c++;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    ans.<span class="hljs-title function_">push</span>([x, y, nums[c], nums[d]]);<br>                    <span class="hljs-keyword">for</span> (c++; c &lt; d &amp;&amp; nums[c] === nums[c - <span class="hljs-number">1</span>]; c++);<br>                    <span class="hljs-keyword">for</span> (d--; d &gt; c &amp;&amp; nums[d] === nums[d + <span class="hljs-number">1</span>]; d--);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm Design</category>
      
      <category>LeetCode</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello Java !</title>
    <link href="/2024/0c2665a58dea/"/>
    <url>/2024/0c2665a58dea/</url>
    
    <content type="html"><![CDATA[<h2 id="1-C-初识"><a href="#1-C-初识" class="headerlink" title="1. C++初识"></a>1. C++初识</h2><h3 id="1-1-HellofromC"><a href="#1-1-HellofromC" class="headerlink" title="1.1 HellofromC++"></a>1.1 HellofromC++</h3><h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><p>单行 &#x2F;&#x2F; </p><p>多行 &#x2F;*  *&#x2F;</p><h3 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h3><p>数据类型 变量名 &#x3D; 初始值；（写入内容，避免Null与Any）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//取变量名</span><br><span class="hljs-meta">#x  </span><br></code></pre></td></tr></table></figure><h3 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4 常量"></a>1.4 常量</h3><p>记录程序中不可更改的数据</p><h4 id="1-4-1-define-宏常量（预编译，不占用内存）"><a href="#1-4-1-define-宏常量（预编译，不占用内存）" class="headerlink" title="1.4.1 #define 宏常量（预编译，不占用内存）"></a>1.4.1 #define 宏常量（预编译，不占用内存）</h4><p>#define 常量名 常量值；</p><h4 id="1-4-2-const修饰的变量（编译，占用内存）"><a href="#1-4-2-const修饰的变量（编译，占用内存）" class="headerlink" title="1.4.2 const修饰的变量（编译，占用内存）"></a>1.4.2 const修饰的变量（编译，占用内存）</h4><p>变量定义前加const关键字，不可修改</p><h3 id="1-5-关键字"><a href="#1-5-关键字" class="headerlink" title="1.5 关键字"></a>1.5 关键字</h3><p>C++预先保留得标识符</p><h3 id="1-5-标识符命名规则"><a href="#1-5-标识符命名规则" class="headerlink" title="1.5 标识符命名规则"></a>1.5 标识符命名规则</h3><p>由字母、数字、下划线组成；第一个字符不能为数字；字母区分大小写</p><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><p>分配内存空间的关键字</p><h3 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h3><table><thead><tr><th>数据类型</th><th>占用空间</th><th>取值范围</th></tr></thead><tbody><tr><td>short，短整型</td><td>2B</td><td>-2^15~2^15-1</td></tr><tr><td>int，整型</td><td>4B</td><td>-2^31~2^31-1</td></tr><tr><td>long，长整型</td><td>4B (Windows，Linux-32位)， 8B（Linux-64位）</td><td>-2^31~2^31-1</td></tr><tr><td>long long，长长整型</td><td>8B</td><td>-2^63~2^63-1</td></tr></tbody></table><h3 id="2-2-sizeof关键字"><a href="#2-2-sizeof关键字" class="headerlink" title="2.2 sizeof关键字"></a>2.2 sizeof关键字</h3><p>sizeof (数据类型&#x2F;变量名)，单位为字节</p><h3 id="2-3-实型（浮点型）"><a href="#2-3-实型（浮点型）" class="headerlink" title="2.3 实型（浮点型）"></a>2.3 实型（浮点型）</h3><p>单精度 float  7位有效数字</p><p>双精度 double  15~16位有效数字</p><p>默认：C++输出实型 &lt;&#x3D; 6位有效数字</p><p>科学计数法  eg：  3e2 &#x3D; 3 * 10^2     3e-2 &#x3D; 3 * 0.1^2</p><h3 id="2-4-字符型"><a href="#2-4-字符型" class="headerlink" title="2.4 字符型"></a>2.4 字符型</h3><p>char  1B</p><p>表示形式为单引号，传入内存中为ASCII码，强转int后可查看, a - 97, A - 65</p><p>ASCII码：</p><p>​1.非打印控制字符：0~31，用于控制外围设备</p><p>​2.打印字符：32~126，键盘</p><h3 id="2-5-转义字符"><a href="#2-5-转义字符" class="headerlink" title="2.5 转义字符"></a>2.5 转义字符</h3><p>列举几项：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">\a  =  警报<br>\n  =  换行<br>\t  =  水平制表，跳至下一个tab（<span class="hljs-number">8</span>位光标）<br>\\  =  \<br>\<span class="hljs-string">&#x27;  =  &#x27;</span><br>\<span class="hljs-string">&quot;  =  &quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-6-字符串型"><a href="#2-6-字符串型" class="headerlink" title="2.6 字符串型"></a>2.6 字符串型</h3><p>本质为字符数组，表示形式为双引号</p><ul><li>C风格：char Name[] &#x3D; “……”</li><li>C++风格：string Name &#x3D; “……”</li></ul><h3 id="2-7-布尔类型-bool"><a href="#2-7-布尔类型-bool" class="headerlink" title="2.7 布尔类型 bool"></a>2.7 布尔类型 bool</h3><p>bool类型占1B，只有两个值</p><ul><li>true  —真 （本质为1）</li><li>false —假 （本质为0）</li></ul><h3 id="2-8-数据输入"><a href="#2-8-数据输入" class="headerlink" title="2.8 数据输入"></a>2.8 数据输入</h3><p>从键盘获取数据</p><p>cin &gt;&gt; 变量</p><h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h2><p>执行代码的运算</p><table><thead><tr><th>运算符类型</th><th>作用</th></tr></thead><tbody><tr><td>算术运算符</td><td>四则运算</td></tr><tr><td>赋值运算符</td><td>表达式给变量赋值</td></tr><tr><td>比较运算符</td><td>比较表达式，返回真&#x2F;假</td></tr><tr><td>逻辑运算符</td><td>逻辑运算，返回真&#x2F;假</td></tr></tbody></table><h3 id="3-1-算数运算符"><a href="#3-1-算数运算符" class="headerlink" title="3.1 算数运算符"></a>3.1 算数运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">+ - * / % ++ --<br></code></pre></td></tr></table></figure><p>除法运算除数 !&#x3D; 0</p><p>小数不可取模运算</p><p>a++: 存储变量a，对变量a进行递增（副本），语句结束赋值回a</p><p>++a: 对变量a进行递增</p><h3 id="3-2-赋值运算符"><a href="#3-2-赋值运算符" class="headerlink" title="3.2 赋值运算符"></a>3.2 赋值运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">= += -= *= /= %=<br></code></pre></td></tr></table></figure><h3 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">== != &gt; &lt; &gt;= &lt;=<br></code></pre></td></tr></table></figure><p>结果为0或1</p><h3 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h3><table><thead><tr><th>运算符</th><th>术语</th><th>结果</th></tr></thead><tbody><tr><td>！</td><td>非</td><td>a为假，!a为真；a为真，!a为假</td></tr><tr><td>&amp;&amp;</td><td>与</td><td>a与b都为真，a&amp;&amp;b为真，否则为假</td></tr><tr><td>||</td><td>或</td><td>a与b都为假，a||b为假，否则为真</td></tr></tbody></table><h2 id="4-程序流程结构"><a href="#4-程序流程结构" class="headerlink" title="4. 程序流程结构"></a>4. 程序流程结构</h2><p>三种基本的程序运行结构：</p><ul><li>顺序结构：顺序执行，不发生跳转</li><li>选择结构：依据条件选择执行</li><li>循环结构：依据条件循环执行</li></ul><h3 id="4-1-选择结构"><a href="#4-1-选择结构" class="headerlink" title="4.1 选择结构"></a>4.1 选择结构</h3><h4 id="4-1-1-if语句"><a href="#4-1-1-if语句" class="headerlink" title="4.1.1 if语句"></a>4.1.1 if语句</h4><ul><li>单行格式if语句</li><li>多行格式if语句</li><li>多条件的if语句</li></ul><h4 id="4-1-2-三目运算符"><a href="#4-1-2-三目运算符" class="headerlink" title="4.1.2 三目运算符"></a>4.1.2 三目运算符</h4><p>取 MAX(a, b) 赋值于 c</p><ul><li>c &#x3D; a &gt; b ? a : b</li></ul><h4 id="4-1-3-switch语句"><a href="#4-1-3-switch语句" class="headerlink" title="4.1.3 switch语句"></a>4.1.3 switch语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span>(表达式：整型或字符型)&#123;<br><span class="hljs-keyword">case</span> 结果<span class="hljs-number">1</span>: 执行语句; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> 结果<span class="hljs-number">2</span>: 执行语句; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> 结果<span class="hljs-number">3</span>: 执行语句; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>: 执行语句; <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结构清晰，执行效率高</p><h3 id="4-2-循环结构"><a href="#4-2-循环结构" class="headerlink" title="4.2 循环结构"></a>4.2 循环结构</h3><h4 id="4-2-1-while循环语句"><a href="#4-2-1-while循环语句" class="headerlink" title="4.2.1 while循环语句"></a>4.2.1 while循环语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(循环条件)&#123;循环语句&#125;<br></code></pre></td></tr></table></figure><p>只要循环条件的结果为真，就执行循环语句</p><p>注意事项：避免死循环的出现，即必须提供退出循环的接口</p><ul><li><p>案例：猜数字 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<span class="hljs-comment">//根据系统时间生成随机数</span><br><br><span class="hljs-type">int</span> num = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span>; <span class="hljs-comment">//生成0~99随机数(伪随机数)</span><br>cout &lt;&lt; num &lt;&lt; endl;<br><br><span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>cin &gt;&gt; val;<br><span class="hljs-keyword">if</span> (val &gt; num) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;猜测过大&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &lt; num) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;猜测过小&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;您猜对了&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//跳出当前循环</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-2-2-do……while循环语句"><a href="#4-2-2-do……while循环语句" class="headerlink" title="4.2.2 do……while循环语句"></a>4.2.2 do……while循环语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span>&#123;循环语句&#125;<span class="hljs-keyword">while</span>(循环条件)<br></code></pre></td></tr></table></figure><p>与while语句的区别为先执行一次循环语句，再判断循环条件</p><ul><li><p>案例：水仙花数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> num = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-type">int</span> a = num % <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = num / <span class="hljs-number">10</span> % <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> c = num / <span class="hljs-number">10</span> / <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> d = a*a*a + b*b*b + c*c*c;<br>    <span class="hljs-keyword">if</span> (num == d) &#123;<br>        cout &lt;&lt; num &lt;&lt; endl;<br>    &#125;<br>    num++;<br>&#125; <span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-2-3-for循环语句"><a href="#4-2-3-for循环语句" class="headerlink" title="4.2.3 for循环语句"></a>4.2.3 for循环语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(起始表达式；条件表达式；末尾循环体)&#123;循环语句&#125;<br></code></pre></td></tr></table></figure><ul><li>案例：敲桌子</li></ul><h4 id="4-2-4-嵌套循环"><a href="#4-2-4-嵌套循环" class="headerlink" title="4.2.4 嵌套循环"></a>4.2.4 嵌套循环</h4><p>在循环中嵌套循环，用于处理“多维”问题</p><p>外层执行一次，内层执行一周</p><ul><li><p>案例：乘法口诀表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; ++i) <span class="hljs-comment">//行&#123;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) <span class="hljs-comment">//列&#123;</span><br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; i * j&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-3-跳转语句"><a href="#4-3-跳转语句" class="headerlink" title="4.3 跳转语句"></a>4.3 跳转语句</h3><h4 id="4-3-1-break语句"><a href="#4-3-1-break语句" class="headerlink" title="4.3.1 break语句"></a>4.3.1 break语句</h4><p>使用时机：</p><ul><li>switch选择语句</li><li>循环语句</li></ul><h4 id="4-3-2-continue语句"><a href="#4-3-2-continue语句" class="headerlink" title="4.3.2 continue语句"></a>4.3.2 continue语句</h4><p>在循环语句中，跳过本次循环，继续执行下一次循环</p><h4 id="4-3-3-goto语句"><a href="#4-3-3-goto语句" class="headerlink" title="4.3.3 goto语句"></a>4.3.3 goto语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">goto</span> 标记；<br></code></pre></td></tr></table></figure><p>标记格式为 标记名 + “:”</p><p>若标记存在，则跳转到标记的位置</p><p>不推荐使用，会破环程序空间局部性和代码结构</p><h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>存放相同类型数据的集合</p><ul><li>特点1：每个数据元素的类型相同</li><li>特点2：物理上，内存连续</li></ul><h3 id="5-2-一维数组"><a href="#5-2-一维数组" class="headerlink" title="5.2 一维数组"></a>5.2 一维数组</h3><h4 id="5-2-1-一维数组的定义方式"><a href="#5-2-1-一维数组的定义方式" class="headerlink" title="5.2.1 一维数组的定义方式"></a>5.2.1 一维数组的定义方式</h4><p>三种定义方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span> 数据类型 数组名[数组长度]；<br><br><span class="hljs-comment">//定义时初始化，未初始化的内存会分配 0</span><br><span class="hljs-number">2.</span> 数据类型 数组名[数组长度] = &#123;值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>，值<span class="hljs-number">3</span>，......&#125;<br><span class="hljs-number">3.</span> 数据类型 数组名[] = &#123;值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>，值<span class="hljs-number">3</span>，......&#125;<br><br>eg:  <span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>];<br>通过下标（[序号]，从<span class="hljs-number">0</span>开始）访存，arr[<span class="hljs-number">0</span>]，arr[<span class="hljs-number">1</span>]，arr[<span class="hljs-number">2</span>]，......<br></code></pre></td></tr></table></figure><h4 id="5-2-2-一维数组的数组名"><a href="#5-2-2-一维数组的数组名" class="headerlink" title="5.2.2 一维数组的数组名"></a>5.2.2 一维数组的数组名</h4><ul><li>统计数组长度                                            sizeof(arr)</li><li>获取数组首地址或首元素地址                 arr</li></ul><p>数组名为常量，不可被赋值</p><ul><li><p>案例：五只小猪称体重</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">300</span>,<span class="hljs-number">350</span>,<span class="hljs-number">200</span>,<span class="hljs-number">400</span>,<span class="hljs-number">250</span> &#125;;<br><span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] &gt; max)&#123;<br>        max = arr[i];<br>    &#125;<br>&#125;<br>cout &lt;&lt; max &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li><li><p>案例：数组逆置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;; <span class="hljs-comment">//目标数组</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;逆置前：&quot;</span>  &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i)&#123;<br>    cout &lt;&lt; arr[i] &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; <span class="hljs-comment">//首指针</span><br><span class="hljs-type">int</span> end = <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>; <span class="hljs-comment">//尾指针</span><br><span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>    <span class="hljs-type">int</span> temp = arr[start];<br>    arr[start] = arr[end];<br>    arr[end] = temp;<br>    ++start;<br>    --end;<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;逆置后：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i)&#123;<br>    cout &lt;&lt; arr[i] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="5-2-3-冒泡排序"><a href="#5-2-3-冒泡排序" class="headerlink" title="5.2.3 冒泡排序"></a>5.2.3 冒泡排序</h4><p>对数组内的元素进行排序，具体执行：</p><ol><li>比较相邻的元素，通过交换保证较大元素右侧</li><li>一轮过后，会得到最大元素（尾元素）——”冒泡“</li><li>重复以上步骤，但比较次数-1，因为最大元素已经确定</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span> &#125;;<br>cout &lt;&lt; <span class="hljs-string">&quot;排序前：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i)&#123;<br>    cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//冒泡排序执行 [9-1=8] 轮，每轮确定一个最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i) &#123;<br>    <span class="hljs-comment">//每轮执行 [当前元素个数-1] 次对比</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span> - i - <span class="hljs-number">1</span>; ++j) &#123;<br>        <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-type">int</span> temp = arr[j];<br>            arr[j] = arr[j+<span class="hljs-number">1</span>];<br>            arr[j+<span class="hljs-number">1</span>] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;排序后：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i) &#123;<br>    cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-二维数组"><a href="#5-3-二维数组" class="headerlink" title="5.3 二维数组"></a>5.3 二维数组</h3><p>增加数组维度</p><h4 id="5-3-1-二维数组的定义方式"><a href="#5-3-1-二维数组的定义方式" class="headerlink" title="5.3.1 二维数组的定义方式"></a>5.3.1 二维数组的定义方式</h4><p>四种定义方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span> 数据类型 数组名[行数][列数]；<br><span class="hljs-number">2.</span> 数据类型 数组名[行数][列数] = <span class="hljs-comment">//推荐使用</span><br>&#123; <br>&#123;值<span class="hljs-number">0</span>_1，值<span class="hljs-number">0</span>_2，......&#125;，<br>&#123;值<span class="hljs-number">1</span>_1，值<span class="hljs-number">1</span>_2，......&#125;，<br>......<br>&#125;；<br><span class="hljs-number">3.</span> 数据类型 数组名[行数][列数] = &#123;值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>，值<span class="hljs-number">3</span>，值<span class="hljs-number">4</span>，......&#125;；<br><span class="hljs-number">4.</span> 数据类型 数组名[][列数] = &#123;值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>，值<span class="hljs-number">3</span>，值<span class="hljs-number">4</span>，......&#125;；<br><br>eg:  <span class="hljs-type">int</span> arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]<br>通过下标（[行号][列号]，从<span class="hljs-number">0</span>开始）访存，arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]，arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]，arr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]，......<br></code></pre></td></tr></table></figure><h4 id="5-3-2-二维数组的数组名"><a href="#5-3-2-二维数组的数组名" class="headerlink" title="5.3.2 二维数组的数组名"></a>5.3.2 二维数组的数组名</h4><ul><li>统计数组长度                                                              sizeof(arr)</li><li>统计数组每行长度                                                      sizeof(arr[行号])</li><li>获取数组首地址或首行地址或首元素地址                arr</li></ul><p>数组名为常量，不可被赋值</p><h4 id="5-3-3-二维数组应用案例"><a href="#5-3-3-二维数组应用案例" class="headerlink" title="5.3.3 二维数组应用案例"></a>5.3.3 二维数组应用案例</h4><p>考试成绩统计</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>]=<br>&#123;<br>&#123; <span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span> &#125;,<br>&#123; <span class="hljs-number">90</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span> &#125;,<br>&#123; <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; ++j)&#123;<br>        sum += arr[i][j];<br>        cout &lt;&lt; arr[i][j] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;第 &quot;</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;个同学的总分为：&quot;</span> &lt;&lt; sum &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p>将一段经常使用的代码封装起来，减少重复代码——程序块</p><h3 id="6-2-函数的定义"><a href="#6-2-函数的定义" class="headerlink" title="6.2 函数的定义"></a>6.2 函数的定义</h3><p>函数的定义一般分为五部分：</p><ol><li>返回值类型</li><li>函数名</li><li>参数声明列表——形参</li><li>函数体语句</li><li>return表达式</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">返回值类型 函数名 （参数声明列表）&#123;<br>函数体语句；<br><span class="hljs-keyword">return</span>表达式；<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-函数的调用"><a href="#6-3-函数的调用" class="headerlink" title="6.3 函数的调用"></a>6.3 函数的调用</h3><p>传入具体的参数——实参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">函数名（参数值列表）；<br></code></pre></td></tr></table></figure><p>调用时，实参的值会传递给形参</p><h3 id="6-4-值传递"><a href="#6-4-值传递" class="headerlink" title="6.4 值传递"></a>6.4 值传递</h3><p>函数调用时，实参的值会传递给形参，并不受形参的影响</p><h3 id="6-5-函数的常见样式"><a href="#6-5-函数的常见样式" class="headerlink" title="6.5 函数的常见样式"></a>6.5 函数的常见样式</h3><p>常见的函数样式有四种：</p><ol><li>无参无返</li><li>有参无返</li><li>无参有返</li><li>有参有返</li></ol><h3 id="6-6-函数的声明"><a href="#6-6-函数的声明" class="headerlink" title="6.6 函数的声明"></a>6.6 函数的声明</h3><p>向编译器声明函数信息（一般情况下代码逐行执行，意味着函数定义必须写于调用之前，为了改善这种强秩序，引入声明机制）</p><p>函数的实际主体可以单独定义，但必须唯一</p><h3 id="6-7-函数的分文件编写"><a href="#6-7-函数的分文件编写" class="headerlink" title="6.7 函数的分文件编写"></a>6.7 函数的分文件编写</h3><p>让代码结构更加清晰，一般分为四个步骤：</p><ol><li>创建后缀为.hpp的头文件</li><li>创建后缀为.cpp的源文件</li><li>在头文件中写函数的声明</li><li>在源文件中写函数的定义</li></ol><p>通过  #include ”……“  包含自定义的头文件</p><h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7. 指针"></a>7. 指针</h2><h3 id="7-1-指针的基本概念"><a href="#7-1-指针的基本概念" class="headerlink" title="7.1 指针的基本概念"></a>7.1 指针的基本概念</h3><p>可以通过指针间接访问内存</p><ul><li>内存编号从0开始记录，为十六进制数字</li><li>指针变量用于保存地址</li><li>指针本质上是一个对象</li></ul><h3 id="7-2-指针变量的定义和使用"><a href="#7-2-指针变量的定义和使用" class="headerlink" title="7.2 指针变量的定义和使用"></a>7.2 指针变量的定义和使用</h3><p>指针类型声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">数据类型* 指针变量名；<br>数据类型* 指针变量名 = 指针变量；<br></code></pre></td></tr></table></figure><p>取地址与解地址：</p><p>符号* 本质上为算术运算符，即先查左值后查右值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">数据类型 数据变量名；<br>*数据变量名   <span class="hljs-comment">//取地址为指针类型</span><br><br>指针类型 指针变量名；<br>&amp;指针变量名   <span class="hljs-comment">//解地址为数据类型</span><br></code></pre></td></tr></table></figure><h3 id="7-3-指针所占内存空间"><a href="#7-3-指针所占内存空间" class="headerlink" title="7.3 指针所占内存空间"></a>7.3 指针所占内存空间</h3><p>32位操作系统下：占用4字节内存空间</p><p>64位操作系统下：占用8字节内存空间</p><h3 id="7-4-空指针和野指针"><a href="#7-4-空指针和野指针" class="headerlink" title="7.4 空指针和野指针"></a>7.4 空指针和野指针</h3><ul><li>空指针：指针变量指向内存中编号为0的空间——指针初始状态</li></ul><p>空指针指向的内存不可访问（0~255内存编号由系统使用）</p><ul><li>野指针：指针变量指向非法空间</li></ul><ol><li>指针未初始化</li><li>指针局部初始化</li></ol><p>野指针指向内存不可访问（无访问权限）</p><h3 id="7-5-const修饰指针"><a href="#7-5-const修饰指针" class="headerlink" title="7.5 const修饰指针"></a>7.5 const修饰指针</h3><p>const关键字 修饰变量</p><p>*运算符 对右侧变量 (地址) 取值；为右侧变量赋左侧类型的地址——指针声明)</p><ol><li>const修饰指针：常量指针（底层const）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p = &amp;a; <span class="hljs-comment">//const右侧为数据类型（默认变量入栈），const修饰此变量，约束数据   int const* p</span><br>p = &amp;b; <br></code></pre></td></tr></table></figure><ol start="2"><li>const修饰常量：指针常量（顶层const）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a; <span class="hljs-comment">//const右侧为指针变量（指针变量入栈），const修饰指针变量，约束指针  </span><br>*p = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>const既修饰指针又修饰常量</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a; <span class="hljs-comment">//完全约束</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;思考：*运算符本质为重载&#x3D;&#x3D;</p><ol><li><p>&#x3D;&#x3D;左侧为类型，右侧为变量时：指针声明，将左侧默认变量取地址赋给指针变量&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;仅右侧为变量时：解地址&#x3D;&#x3D;</p></li></ol><h3 id="7-6-指针和数组"><a href="#7-6-指针和数组" class="headerlink" title="7.6 指针和数组"></a>7.6 指针和数组</h3><p>利用指针访问数组中的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;<br>cout &lt;&lt; arr[<span class="hljs-number">0</span>] &lt;&lt; endl;                 <span class="hljs-comment">//打印 1</span><br>cout &lt;&lt; *arr &lt;&lt; endl;                   <span class="hljs-comment">//打印 1</span><br><span class="hljs-type">int</span>*p = arr;                            <span class="hljs-comment">//数组名arr不能被修改</span><br>p++;<br>cout &lt;&lt; *p &lt;&lt; endl;                     <span class="hljs-comment">//打印 2，若打印*p++或*(p++) 仍为1</span><br></code></pre></td></tr></table></figure><h3 id="7-7-指针和函数"><a href="#7-7-指针和函数" class="headerlink" title="7.7 指针和函数"></a>7.7 指针和函数</h3><p>利用指针传入函数修改实参的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> temp = *p1;<br>*p1 = * p2;<br>*p2 = temp;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;运算的本质就是操作地址，传入指针相当于自己拥有操作权，否则为系统默认&#x3D;&#x3D;</p><h3 id="7-8-指针和函数"><a href="#7-8-指针和函数" class="headerlink" title="7.8 指针和函数"></a>7.8 指针和函数</h3><p>案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> len)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; ++j) &#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br><span class="hljs-type">int</span> temp = arr[j];<br>arr[j] = arr[j + <span class="hljs-number">1</span>];<br>arr[j + <span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8. 结构体"></a>8. 结构体</h2><h3 id="8-1-结构体基本概念"><a href="#8-1-结构体基本概念" class="headerlink" title="8.1 结构体基本概念"></a>8.1 结构体基本概念</h3><p>结构体属于用户自定义的数据类型，允许用户存储不同的数据类型</p><h3 id="8-2-结构体定义和使用"><a href="#8-2-结构体定义和使用" class="headerlink" title="8.2 结构体定义和使用"></a>8.2 结构体定义和使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> 结构体名 &#123;<br>类型名 成员<span class="hljs-number">1</span>；<br>    类型名 成员<span class="hljs-number">2</span>；<br>    ......<br>&#125;;<br></code></pre></td></tr></table></figure><p>通过结构体创建变量的方式有三种：</p><p>struct 关键字可以省略</p><ul><li>struct 结构体名 变量名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> 结构体名 变量名；<br><span class="hljs-comment">//结构体变量名.成员名 可以访问结构体成员</span><br>变量名.成员<span class="hljs-number">1</span> = ...；<br>变量名.成员<span class="hljs-number">2</span> = ...；<br>......<br></code></pre></td></tr></table></figure><ul><li>struct 结构体名 变量名 &#x3D; {成员1的值，成员2的值，……}</li><li>定义结构体时同步创建变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> 结构体名 &#123;<br>类型名 成员<span class="hljs-number">1</span>；<br>    类型名 成员<span class="hljs-number">2</span>；<br>    ......<br>&#125; 变量名;<br></code></pre></td></tr></table></figure><h3 id="8-3-结构体数组"><a href="#8-3-结构体数组" class="headerlink" title="8.3 结构体数组"></a>8.3 结构体数组</h3><p>将自定义结构体作为数组元素.</p><h3 id="8-4-结构体指针"><a href="#8-4-结构体指针" class="headerlink" title="8.4 结构体指针"></a>8.4 结构体指针</h3><p>通过指针访问结构体成员.</p><ul><li>利用操作符 -&gt; 可以通过结构体指针访问结构体属性.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">struct</span> 结构体名 指针变量名 = &amp;变量名；<br><br><span class="hljs-comment">//结构体指针变量名-&gt;成员名 可以访问结构体成员</span><br>变量名-&gt;成员<span class="hljs-number">1</span> = ...；<br>变量名-&gt;成员<span class="hljs-number">2</span> = ...；<br>......<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;变量未初始化时，C++的行为是未知的，编译器通常会用error来制止这一行为.&#x3D;&#x3D;</p><h3 id="8-5-结构体嵌套结构体"><a href="#8-5-结构体嵌套结构体" class="headerlink" title="8.5 结构体嵌套结构体"></a>8.5 结构体嵌套结构体</h3><p>结构体中的成员可以是另一个结构体  </p><h3 id="8-6-结构体做函数参数"><a href="#8-6-结构体做函数参数" class="headerlink" title="8.6 结构体做函数参数"></a>8.6 结构体做函数参数</h3><p>将结构体作为参数向函数中传递.</p><ul><li>值传递</li><li>地址传递</li></ul><h3 id="8-7-结构体中const使用场景"><a href="#8-7-结构体中const使用场景" class="headerlink" title="8.7 结构体中const使用场景"></a>8.7 结构体中const使用场景</h3><p>使用地址传递节省传递开销，为了只读，需要使用const修饰.</p><h3 id="8-8-结构体案例"><a href="#8-8-结构体案例" class="headerlink" title="8.8 结构体案例"></a>8.8 结构体案例</h3><p>使用地址传递节省传递开销，为了只读，需要使用const修饰.</p><h4 id="8-8-1-案例一"><a href="#8-8-1-案例一" class="headerlink" title="8.8.1 案例一"></a>8.8.1 案例一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>string sName;<br><span class="hljs-type">int</span> score;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Teacher</span> &#123;<br>string tName;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> sArray[<span class="hljs-number">5</span>];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">allocate_print</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Teacher tArray[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>string nameSeed = <span class="hljs-string">&quot;ABCDE&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>tArray[i].tName = <span class="hljs-string">&quot;Teacher_&quot;</span>;<br>tArray[i].tName += nameSeed[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;老师姓名：&quot;</span> &lt;&lt; tArray[i].tName &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; ++j) &#123;<br>tArray[i].sArray[j].sName = <span class="hljs-string">&quot;Student_&quot;</span>;<br>tArray[i].sArray[j].sName += nameSeed[j];<br><span class="hljs-type">int</span> random = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>;<br>tArray[i].sArray[j].score = random;<br>cout &lt;&lt; <span class="hljs-string">&quot;\t学生姓名&quot;</span> &lt;&lt; tArray[i].sArray[j].sName <br>                 &lt;&lt; <span class="hljs-string">&quot; 考试分数：&quot;</span> &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Teacher</span> tArray[<span class="hljs-number">3</span>];<br><span class="hljs-built_in">allocate_print</span>(tArray, <span class="hljs-built_in">size</span>(tArray));<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="8-8-2-案例二"><a href="#8-8-2-案例二" class="headerlink" title="8.8.2 案例二"></a>8.8.2 案例二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hero</span> &#123;<br>string name;<br><span class="hljs-type">int</span> age;<br>    string sex;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort_print</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Hero heroArray[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; ++j) &#123;<br><span class="hljs-keyword">if</span> (heroArray[j].age &gt; heroArray[j + <span class="hljs-number">1</span>].age) &#123;<br><span class="hljs-type">int</span> temp = heroArray[j];<br>heroArray[j] = heroArray[j+<span class="hljs-number">1</span>];<br>heroArray[j+<span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>&#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span>&lt;&lt; heroArray[i].name<br>             &lt;&lt; <span class="hljs-string">&quot;年龄：&quot;</span>&lt;&lt; heroArray[i].age<br>             &lt;&lt; <span class="hljs-string">&quot;性别：&quot;</span>&lt;&lt; heroArray[i].sex &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hero</span> heroArray[<span class="hljs-number">5</span>] = <br>    &#123;<br>        &#123;<span class="hljs-string">&quot;刘备&quot;</span>，<span class="hljs-number">23</span>，<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;关羽&quot;</span>，<span class="hljs-number">22</span>，<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;张飞&quot;</span>，<span class="hljs-number">20</span>，<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;吕布&quot;</span>，<span class="hljs-number">21</span>，<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;貂蝉&quot;</span>，<span class="hljs-number">19</span>，<span class="hljs-string">&quot;女&quot;</span>&#125;,   <br>    &#125;;<br>    <span class="hljs-built_in">bubbleSort_print</span>(heroArray,<span class="hljs-built_in">size</span>(heroArray));<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Program Language</category>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>电话号码的字母组合</title>
    <link href="/2023/8dfb8caf35d0/"/>
    <url>/2023/8dfb8caf35d0/</url>
    
    <content type="html"><![CDATA[<h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h3><blockquote><p>C++ Tips</p><ol><li>vector.emplace_back：直接在容器尾构造对象，对比，push_back 需要提前准备对象进行移动</li></ol><p>Java Tips</p><ol><li>List.of()：创建具有 0 个元素的空列表</li></ol><p>C Tips</p><ol><li>字符串char* 必须以空字符 ‘\0’ 结尾</li></ol></blockquote><p>题目：</p><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p>​<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt="img"></p><h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p>时间复杂度：$O(n4^n)$</p><p>空间复杂度：$O(n)$</p><h5 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//c++</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    string MAPPING[<span class="hljs-number">10</span>] = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = digits.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-function">string <span class="hljs-title">path</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> i) &#123; <span class="hljs-comment">// lambda 表达式定义并创建函数对象</span><br>            <span class="hljs-keyword">if</span> (i == n)&#123;<br>                ans.<span class="hljs-built_in">emplace_back</span>(path); <span class="hljs-comment">// 在容器中直接构造对象</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : MAPPING[digits[i] - <span class="hljs-string">&#x27;0&#x27;</span>])&#123; <span class="hljs-comment">// 以字符 ASCII 码作差，映射至 2~9</span><br>                path[i] = c;<br>                <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归</span><br>            &#125;<br>        &#125;;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] MAPPING = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span>[] digits, path;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> digits.length();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> List.of();<br>        <span class="hljs-built_in">this</span>.digits = digits.toCharArray();<br>        path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n];<br>        dfs(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i == digits.length)&#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : MAPPING[digits[i] - <span class="hljs-string">&#x27;0&#x27;</span>].toCharArray())&#123;<br>            path[i] = c;<br>            dfs(i + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="python"><a href="#python" class="headerlink" title="python"></a>python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#python3</span><br>MAPPING = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">letterCombinations</span>(<span class="hljs-params">self, digits: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        n = <span class="hljs-built_in">len</span>(digits)<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        ans = []<br>        path = [<span class="hljs-string">&#x27;&#x27;</span>] * n<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> i == n:<br>                ans.append(<span class="hljs-string">&#x27;&#x27;</span>.join(path))<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> MAPPING[<span class="hljs-built_in">int</span>(digits[i])]:<br>                path[i] = c<br>                dfs(i + <span class="hljs-number">1</span>)<br>        dfs(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h5 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">char</span>* MAPPING[<span class="hljs-number">10</span>] = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>* digits, <span class="hljs-type">int</span> depth, <span class="hljs-type">char</span>** MAPPING, <span class="hljs-type">char</span>** ans, <span class="hljs-type">char</span>* path, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span>* returnSize)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index == depth) &#123;<br>        ans[*returnSize] = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>((depth + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<br>        <span class="hljs-built_in">strncpy</span>(ans[*returnSize], path, depth);<br>        ans[*returnSize][depth] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        (*returnSize)++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> digit = digits[index] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(MAPPING[digit]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        path[index] = MAPPING[digit][i];<br>        dfs(digits, depth, MAPPING, ans, path, index + <span class="hljs-number">1</span>, returnSize);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">char</span>** <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(<span class="hljs-type">char</span>* digits, <span class="hljs-type">int</span>* returnSize)</span> &#123;<br>    <span class="hljs-type">int</span> depth = <span class="hljs-built_in">strlen</span>(digits);<br>    <span class="hljs-keyword">if</span> (depth == <span class="hljs-number">0</span>) &#123;<br>        *returnSize = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> totalPaths = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; depth; i++) &#123;<br>        <span class="hljs-type">int</span> digit = digits[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(MAPPING[digit]);<br>        totalPaths *= len;<br>    &#125;<br>    <span class="hljs-type">char</span>** ans = (<span class="hljs-type">char</span>**)<span class="hljs-built_in">malloc</span>(totalPaths * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>*));<br>    <span class="hljs-type">char</span>* path = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>((depth + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<br>    *returnSize = <span class="hljs-number">0</span>;<br>    dfs(digits, depth, MAPPING, ans, path, <span class="hljs-number">0</span>, returnSize);<br>    <span class="hljs-built_in">free</span>(path);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//javascript</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; <span class="hljs-variable">digits</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> letterCombinations = <span class="hljs-keyword">function</span>(<span class="hljs-params">digits</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MAPPING</span> = [<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>];<br>    <span class="hljs-keyword">const</span> ans = [];<br>    <span class="hljs-keyword">let</span> path = [];<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i</span>)&#123;<br>        <span class="hljs-keyword">if</span>(i === digits.<span class="hljs-property">length</span>)&#123;<br>            ans.<span class="hljs-title function_">push</span>(path.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> c <span class="hljs-keyword">of</span> <span class="hljs-variable constant_">MAPPING</span>[digits[i] - <span class="hljs-string">&#x27;0&#x27;</span>])&#123;<br>            path[i] = c;<br>            <span class="hljs-title function_">dfs</span>(i + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(digits.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> [];<br>    &#125;<br>    <span class="hljs-title function_">dfs</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm Design</category>
      
      <category>LeetCode</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最接近的三数之和</title>
    <link href="/2023/e12fe671c233/"/>
    <url>/2023/e12fe671c233/</url>
    
    <content type="html"><![CDATA[<h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><blockquote><p>C++ Tips</p><ol><li>INT_MAX：INT_MAX 是在 C语言中定义的一个常量，表示整数类型 int 的最大值。</li></ol><p>Java Tips</p><ol><li>MAX_VALUE：MAX_VALUE 是 Java 中定义的成员，对于整数类型，可以使用 Integer.MAX_VALUE 来表示整数的最大值。</li></ol><p>Python Tips</p><ol><li>inf：在 Python 中，inf 是用于表示正无穷大的特殊值。</li></ol><p>JavaScript Tips</p><ol><li>Number.MAX_SAFE_INTEGER：Number.MAX_SAFE_INTEGER 是 JavaScript 中的一个常量，它表示可以精确表示的最大整数。</li></ol></blockquote><p>题目：</p><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和 一个目标值 <code>target</code>。请你从 <code>nums</code> 中选出三个整数，使它们的和与 <code>target</code> 最接近。</p><p>返回这三个数的和。</p><p>假定每组输入只存在恰好一个解。</p><h4 id="排序双指针"><a href="#排序双指针" class="headerlink" title="排序双指针"></a>排序双指针</h4><p>时间复杂度：$O(n^2)$</p><p>空间复杂度：$O(1)$</p><h5 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//c++</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> ans, n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> min_diff  = INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; ++i)&#123;<br>            <span class="hljs-type">int</span> x = nums[i];<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; x == nums[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 跳过重复项</span><br>            <span class="hljs-type">int</span> s = x + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>]; <span class="hljs-comment">// 优化1</span><br>            <span class="hljs-keyword">if</span>(s &gt; target)&#123;<br>                <span class="hljs-keyword">if</span>(s - target &lt; min_diff)&#123;<br>                    ans = s;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            s = x + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 优化2</span><br>            <span class="hljs-keyword">if</span>(s &lt; target)&#123;<br>                <span class="hljs-keyword">if</span>(target - s &lt; min_diff)&#123;<br>                    min_diff = target - s;<br>                    ans = s;<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k = n - <span class="hljs-number">1</span>; <span class="hljs-comment">// 双指针循环</span><br>            <span class="hljs-keyword">while</span>(j &lt; k)&#123;<br>                s = x + nums[j] + nums[k];<br>                <span class="hljs-keyword">if</span>(s == target)&#123;<br>                    <span class="hljs-keyword">return</span> target;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(s &gt; target)&#123;<br>                    <span class="hljs-keyword">if</span>(s - target &lt; min_diff)&#123;<br>                        min_diff = s - target;<br>                        ans = s;<br>                    &#125;<br>                    --k;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(target - s &lt; min_diff)&#123;<br>                        min_diff = target - s;<br>                        ans = s;<br>                    &#125;<br>                    ++j;<br>                &#125;<br>                <span class="hljs-comment">//是否也可以去除重复项？</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">threeSumClosest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minDiff</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; ++i)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; x == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> x + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span>(s &gt; target)&#123;<br>                <span class="hljs-keyword">if</span>(s - target &lt; minDiff)&#123;<br>                    ans = s;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            s = x + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(s &lt; target)&#123;<br>                <span class="hljs-keyword">if</span>(target - s &lt; minDiff)&#123;<br>                    minDiff = target - s;<br>                    ans = s;<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, k = n -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(j &lt; k)&#123;<br>                s = x + nums[j] + nums[k];<br>                <span class="hljs-keyword">if</span>(s == target)&#123;<br>                    <span class="hljs-keyword">return</span> target;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(s &gt; target)&#123;<br>                    <span class="hljs-keyword">if</span>(s - target &lt; minDiff)&#123;<br>                        minDiff = s - target;<br>                        ans = s;<br>                    &#125;<br>                    --k;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(target - s &lt; minDiff)&#123;<br>                        minDiff = s - target;<br>                        ans = s;<br>                    &#125;<br>                    ++j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="python"><a href="#python" class="headerlink" title="python"></a>python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#python3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSumClosest</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        nums.sort()<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        min_diff = inf<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">2</span>):<br>            x = nums[i]<br>            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">and</span> x == nums[i - <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">continue</span><br>            s = x + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>]<br>            <span class="hljs-keyword">if</span> s &gt; target:<br>                <span class="hljs-keyword">if</span>(s - target &lt; min_diff):<br>                    ans = s<br>                <span class="hljs-keyword">break</span><br>            s = x + nums[-<span class="hljs-number">2</span>] + nums[-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">if</span> s &lt; target:<br>                <span class="hljs-keyword">if</span>(target - s &lt; min_diff):<br>                    min_diff = target - s<br>                    ans = s<br>                <span class="hljs-keyword">continue</span><br>            j, k = i + <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> j &lt; k:<br>                s = x + nums[j] + nums[k]<br>                <span class="hljs-keyword">if</span> s == target:<br>                    <span class="hljs-keyword">return</span> s<br>                <span class="hljs-keyword">if</span> s &gt; target:<br>                    <span class="hljs-keyword">if</span> s - target &lt; min_diff:<br>                        min_diff = s - target<br>                        ans = s<br>                    k -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span>(target - s &lt; min_diff):<br>                        min_diff = target - s<br>                        ans = s<br>                    j += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br><br></code></pre></td></tr></table></figure><h5 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 比较函数，用于在qsort中进行排序</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span> &#123;<br>    <span class="hljs-keyword">return</span> (*(<span class="hljs-type">int</span>*)a - *(<span class="hljs-type">int</span>*)b);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">threeSumClosest</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target)</span> &#123;<br>    qsort(nums, numsSize, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>), compare);<br>    <span class="hljs-type">int</span> ans, min_diff = INT_MAX;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numsSize - <span class="hljs-number">2</span>; ++i)&#123;<br>        <span class="hljs-type">int</span> x = nums[i];<br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; x == nums[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> s = x + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span>(s &gt; target)&#123;<br>            <span class="hljs-keyword">if</span>(s - target &lt; min_diff)&#123;<br>                ans = s;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        s = x + nums[numsSize - <span class="hljs-number">2</span>] + nums[numsSize - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(s &lt; target)&#123;<br>            <span class="hljs-keyword">if</span>(target - s &lt; min_diff)&#123;<br>                min_diff = target - s;<br>                ans = s;<br>            &#125;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k = numsSize - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(j &lt; k)&#123;<br>            s = x + nums[j] + nums[k];<br>            <span class="hljs-keyword">if</span>(s == target)&#123;<br>                <span class="hljs-keyword">return</span> target;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s &gt; target)&#123;<br>                <span class="hljs-keyword">if</span>(s - target &lt; min_diff)&#123;<br>                    min_diff = s - target;<br>                    ans = s;<br>                &#125;<br>                --k;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(target - s &lt; min_diff)&#123;<br>                    min_diff = target - s;<br>                    ans = s;<br>                &#125;<br>                ++j;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//javascript</span><br><span class="hljs-keyword">var</span> threeSumClosest = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) &#123;<br>    nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>    <span class="hljs-keyword">const</span> n = nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> minDiff = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; i++) &#123;<br>        <span class="hljs-keyword">const</span> x = nums[i];<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; x === nums[i - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">let</span> s = x + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span> (s &gt; target) &#123;<br>            <span class="hljs-keyword">if</span> (s - target &lt; minDiff) &#123;<br>                ans = s;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        s = x + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (s &lt; target) &#123;<br>            <span class="hljs-keyword">if</span> (target - s &lt; minDiff) &#123;<br>                minDiff = target - s;<br>                ans = s;<br>            &#125;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>, k = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>            s = x + nums[j] + nums[k];<br>            <span class="hljs-keyword">if</span> (s === target) &#123;<br>                <span class="hljs-keyword">return</span> target;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (s &gt; target) &#123;<br>                <span class="hljs-keyword">if</span> (s - target &lt; minDiff) &#123;<br>                    minDiff = s - target;<br>                    ans = s;<br>                &#125;<br>                k--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (target - s &lt; minDiff) &#123;<br>                    minDiff = target - s;<br>                    ans = s;<br>                &#125;<br>                j++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm Design</category>
      
      <category>LeetCode</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三数之和</title>
    <link href="/2023/e9c7e10184d0/"/>
    <url>/2023/e9c7e10184d0/</url>
    
    <content type="html"><![CDATA[<h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><blockquote><p>C++ Tips</p><ol><li>数组 auto 排序：sort(auto.begin(), auto.end())</li></ol><p>Java Tips</p><ol><li>数组auto排序：Arrays.sort(auto)</li></ol><p>Python Tips</p><ol><li>数组auto排序：auto.sort()</li></ol><p>JavaScript Tips</p><ol><li>数组auto排序：auto.sort((a, b) &#x3D;&gt; a - b) 为升序排序；auto.sort((a, b) &#x3D;&gt; b - a) 为降序排序</li></ol></blockquote><p>题目：</p><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><h4 id="有序双指针"><a href="#有序双指针" class="headerlink" title="有序双指针"></a>有序双指针</h4><p>时间复杂度：$O(n^2)$</p><p>空间复杂度：$O(1)$</p><h5 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//c++</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 排序，方便后续优化遍历</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span> ; ++i)&#123;<br>            <span class="hljs-type">int</span> x = nums[i];<br>            <span class="hljs-keyword">if</span>(i &amp;&amp; x == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 跳过重复数字</span><br>            <span class="hljs-keyword">if</span>(x + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 优化一：如果最小值大于0，那么结束循环</span><br>            <span class="hljs-keyword">if</span>(x + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 优化二：如果最大值小于0，那么进入下一次循环</span><br>            <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k = n - <span class="hljs-number">1</span>; <span class="hljs-comment">// 取最近值与最远值，开始缩小范围</span><br>            <span class="hljs-keyword">while</span>(j &lt; k)&#123;<br>                <span class="hljs-type">int</span> s = x + nums[j] + nums[k];<br>                <span class="hljs-keyword">if</span>(s &gt; <span class="hljs-number">0</span>) --k; <span class="hljs-comment">// 结果偏大，缩小最远值</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s &lt; <span class="hljs-number">0</span>) ++j; <span class="hljs-comment">// 结果偏小，扩大最近值</span><br>                <span class="hljs-keyword">else</span>&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(&#123;x, nums[j], nums[k]&#125;);<br>                    <span class="hljs-keyword">for</span>(++j; j &lt; k &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]; ++j); <span class="hljs-comment">// 跳过重复值</span><br>                    <span class="hljs-keyword">for</span>(--k; k &gt; j &amp;&amp; nums[k] == nums[k + <span class="hljs-number">1</span>]; --k); <span class="hljs-comment">// 跳过重复值</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span> ; ++i)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; x == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(x + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span>(x + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, k = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &lt; k)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> x + nums[j] + nums[k];<br>                <span class="hljs-keyword">if</span>(s &gt; <span class="hljs-number">0</span>) --k;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s &lt; <span class="hljs-number">0</span>) ++j;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    ans.add(List.of(x, nums[j], nums[k]));<br>                    <span class="hljs-keyword">for</span>(++j; j &lt; k &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]; ++j);<br>                    <span class="hljs-keyword">for</span>(--k; k &gt; j &amp;&amp; nums[k] == nums[k + <span class="hljs-number">1</span>]; --k);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="python"><a href="#python" class="headerlink" title="python"></a>python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#python3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        nums.sort()<br>        ans = []<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">2</span>):<br>            x = nums[i]<br>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> x == nums[i - <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> x + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> x + nums[-<span class="hljs-number">2</span>] + nums[-<span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">continue</span><br>            j = i + <span class="hljs-number">1</span><br>            k = n - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> j &lt; k:<br>                s = x + nums[j] + nums[k]<br>                <span class="hljs-keyword">if</span> s &gt; <span class="hljs-number">0</span>:<br>                    k -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> s &lt; <span class="hljs-number">0</span>:<br>                    j += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    ans.append([x, nums[j], nums[k]])<br>                    j += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> j &lt; k <span class="hljs-keyword">and</span> nums[j] == nums[j - <span class="hljs-number">1</span>]:<br>                        j += <span class="hljs-number">1</span><br>                    k -= <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> k &gt; j <span class="hljs-keyword">and</span> nums[k] == nums[k + <span class="hljs-number">1</span>]:<br>                        k -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h5 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span> &#123;<br>    <span class="hljs-keyword">return</span> (*(<span class="hljs-type">int</span> *)a - *(<span class="hljs-type">int</span> *)b);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Return an array of arrays of size *returnSize.</span><br><span class="hljs-comment"> * The sizes of the arrays are returned as *returnColumnSizes array.</span><br><span class="hljs-comment"> * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span>** <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span>* returnSize, <span class="hljs-type">int</span>** returnColumnSizes)</span> &#123;<br>    qsort(nums, numsSize, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>), compare);<br><br>    <span class="hljs-type">int</span>** ans = (<span class="hljs-type">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>*) * (numsSize * numsSize));<br>    *returnColumnSizes = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * (numsSize * numsSize));<br>    *returnSize = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numsSize - <span class="hljs-number">2</span>; ++i) &#123;<br>        <span class="hljs-type">int</span> x = nums[i];<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; x == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (x + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (x + nums[numsSize - <span class="hljs-number">2</span>] + nums[numsSize - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k = numsSize - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>            <span class="hljs-type">int</span> s = x + nums[j] + nums[k];<br>            <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) --k;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">0</span>) ++j;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span>* triplet = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>                triplet[<span class="hljs-number">0</span>] = x;<br>                triplet[<span class="hljs-number">1</span>] = nums[j];<br>                triplet[<span class="hljs-number">2</span>] = nums[k];<br>                ans[*returnSize] = triplet;<br>                (*returnColumnSizes)[*returnSize] = <span class="hljs-number">3</span>;<br>                (*returnSize)++;<br>                <span class="hljs-keyword">for</span> (++j; j &lt; k &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]; ++j);<br>                <span class="hljs-keyword">for</span> (--k; k &gt; j &amp;&amp; nums[k] == nums[k + <span class="hljs-number">1</span>]; --k);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//javascript</span><br><span class="hljs-keyword">var</span> threeSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>    <span class="hljs-keyword">const</span> n = nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> ans = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; i++) &#123;<br>        <span class="hljs-keyword">const</span> x = nums[i];<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; x === nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 跳过重复数字</span><br>        <span class="hljs-keyword">if</span> (x + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 优化一</span><br>        <span class="hljs-keyword">if</span> (x + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 优化二</span><br>        <span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>, k = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>            <span class="hljs-keyword">const</span> s = x + nums[j] + nums[k];<br>            <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) k--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">0</span>) j++;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ans.<span class="hljs-title function_">push</span>([x, nums[j], nums[k]]);<br>                <span class="hljs-keyword">for</span> (j++; j &lt; k &amp;&amp; nums[j] === nums[j - <span class="hljs-number">1</span>]; j++); <span class="hljs-comment">// 跳过重复数字</span><br>                <span class="hljs-keyword">for</span> (k--; k &gt; j &amp;&amp; nums[k] === nums[k + <span class="hljs-number">1</span>]; k--); <span class="hljs-comment">// 跳过重复数字</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm Design</category>
      
      <category>LeetCode</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello ChatGPT ！</title>
    <link href="/2023/eeb5aeb4a7a5/"/>
    <url>/2023/eeb5aeb4a7a5/</url>
    
    <content type="html"><![CDATA[<h2 id="📖-语言模型介绍篇"><a href="#📖-语言模型介绍篇" class="headerlink" title="📖 语言模型介绍篇"></a>📖 语言模型介绍篇</h2><h4 id="📄️-什么是语言模型？"><a href="#📄️-什么是语言模型？" class="headerlink" title="📄️ 什么是语言模型？"></a>📄️ 什么是语言模型？</h4><p>大家或多或少都听过 ChatGPT 是一个 LLMs，那 LLMs 是什么？</p><p>LLMs 全称是 Large Language Models，中文是大语言模型。</p><p>那么什么是语言模型？</p><p>语言模型简单说来，就是对人类的语言建立数学模型，注意，这里的关键是<strong>数学模型</strong>，语言模型是一个由数学公式构建的模型，并不是什么逻辑框架。这个认知非常重要。</p><p>最早提出语言模型的概念的是 <a href="https://en.wikipedia.org/wiki/Frederick_Jelinek">贾里尼克博士</a>。</p><p>他是世界著名的语音识别和自然语言处理的专家，他在 IBM 实验室工作期间，提出了基于统计的语音识别的框架，这个框架结构对语音和语言处理有着深远的影响，它从根本上使得语音识别有实用的可能。在贾里尼克以前，科学家们把语音识别问题当作人工智能问题和模式匹配问题。而贾里尼克把它当成通信问题。</p><p>为何是通讯问题？为何转换成通讯问题后，就能实现语音识别？</p><p>根据香农确定的现代通讯原理，所谓的通讯，也被称为信道的编码和解码，信息源先产生原始信息，然后接收方还原一个和原始信息最接近的信息。</p><p>比如，你打电话的时候，问对方一句「你吃了晚饭了吗」，在传输前，通讯系统会对这句话进行编码，编成类似「100111101100000…」，但是传输过程中，一定会有信号损失，接收方收到的编码可能是「1001111011000…」，此时我们就没法解码回原来的句子了。</p><p>那如何解决这个问题？</p><p>我们可以把与接收到的编码「1001111011000…」类似的句子都罗列出来，可能的情况是：</p><ul><li>吃了晚饭了吗</li><li>你吃了饭了吗</li><li>你吃了晚饭了吗</li><li>你吃了晚饭了</li></ul><p>然后通讯系统会计算出哪一种的可能性最大，最后把它选出来。只要噪音不大，并且传输信息有冗余，那我们就能复原出原来的信息。</p><p>贾里尼克博士认为让计算机理解人类的语言，不是像教人那样教它语法，而是最好能够让计算机计算出哪一种可能的语句概率最大。</p><p>这种计算自然语言每个句子的概率的数学模型，就是语言模型。</p><h4 id="📄️-如何计算概率？"><a href="#📄️-如何计算概率？" class="headerlink" title="📄️ 如何计算概率？"></a>📄️ 如何计算概率？</h4><p>然是数学模型，那应该如何计算呢？</p><p>最简单的方法，当然就是用统计学的方法去计算了，简单说来，就是靠输入的上下文进行统计，计算出后续词语的概率，比如「你吃了晚饭了吗」，「你吃了」后面按照概率，名词如「饭」或「晚饭」等概率更高，而不太可能是动词，如「睡」「睡觉」。</p><p>这是语言模型的第一阶段，模型也被称为是统计语言模型（Statistical Language Model，SLM），其基本思想是基于马尔可夫假设建立词语测模型，根据最近的上下文预测下一个词。</p><p>后续语言模型的发展又迭代了三个版本。</p><p>第二阶段是神经网络语言模型（Neural Language Model，NLM），是一个用神经网络来训练模型，学习单词之间的关联性和概率关系。它能够利用大量的数据进行深度学习，从而捕捉到词汇之间更加复杂的关系。NLM 模型采用的是分层的结构，把输入的文本数据空间投射到高维的语义空间中并进行学习。通过不断地更新神经网络模型参数，NLM 的神经网络逐渐学会了文本数据的语义并能够生成连贯自然、语义准确的文本。</p><p>与前面提到的 SLM 相比，由于深度神经网络的学习能力更强，NLM 在学习语言模型时具有更好的泛化能力和适应性。比如能生成更长的文本等。但 NLM 相对来说也比较依赖更大的数据集，并且需要花很多人力在数据标注上。</p><p>第三阶段是预训练语言模型（Pre-trained Language Model，PLM），是一种使用大量文本数据来训练的自然语言处理模型。相对 NLM 来说，PLM 使用无监督学习方法，因此不需要先标注数据或注明文本类型等信息。各位可能听过的 Transformer 架构就是一种预训练语言模型。</p><p>第四阶段是大语言模型（Large Language Model），你可以将现在的 LLM 理解为一个训练数据特别大的 PLM，比如 GPT-2 只有 1.5B 参数，GPT-3 则到了惊人 175B，尽管 LLM 只是拓展了模型的大小，但这些大尺寸的预训练语言模型表现出了与较小的预训练语言模型不同的行为，并且在解决一些复杂任务上展现了惊人的能力（俗称涌现能力，注意这个涌现能力目前还存在争议），所以学术界为这些大型预训练语言模型命名为大语言模型 LLM。</p><p>上面这四个阶段可能比较难理解，你可以简单理解：</p><ol><li>语言模型本质上都是在计算自然语言每个句子的概率的数学模型。当你输入一个问题给 AI 时，AI 就是用概率算出它的回答。</li><li>另外，当今的语言模型，并不是一个问题对一个答案，实际上是一个问题，多个答案，然后根据答案的概率进行排序，最后返回一个最可能的答案。</li></ol><p>以上两个认知非常重要。</p><h4 id="📄️-开发大语言模型需要什么？"><a href="#📄️-开发大语言模型需要什么？" class="headerlink" title="📄️ 开发大语言模型需要什么？"></a>📄️ 开发大语言模型需要什么？</h4><p>本文主要内容来自论文 <a href="https://arxiv.org/abs/2303.18223">A Survey of Large Language Models</a>。</p><p>了解完大语言模型的原理之后，你可能会好奇 TA 是如何开发的。开发大语言模型的关键是什么。最近看到不少文章为了流量，甚至连 5G 通讯都说成了是开发大语言模型的关键 😂，其实从前面的原理介绍，不难看出，大语言模型的其中一个关键点是数据。</p><h5 id="关键一：数据"><a href="#关键一：数据" class="headerlink" title="关键一：数据"></a>关键一：数据</h5><p>训练数据主要是所谓的语料库。今天的很多语言模型的语料库主要有以下几种：</p><ul><li>Books：BookCorpus 是之前小语言模型如 GPT-2 常用的数据集，包括超过 11000 本电子书。主要包括小说和传记，最近更新时间是 2015 年 12 月。大一点的书籍语料库是 Gutenberg，它有 70000 本书，包括小说、散文、戏剧等作品，是目前最大的开源书籍语料库之一，最近更新时间是 2021 年 12 月。</li><li>CommonCrawl：这个是目前最大的开源网络爬虫数据库，不过这个数据包含了大量脏数据，所以目前常用的四个数据库是 C4、CC-Stories、CC-News 和 RealNews。另外还有两个基于 CommonCrawl 提取的新闻语料库 REALNEWS 和 CC-News。</li><li>Reddit Links：简单理解 Reddit 就是外国版本的百度贴吧 + 知乎。目前开源的数据库有 OpenWebText 和 <a href="http://pushshift.io/">PushShift.io</a>。</li><li>Wikipedia：维基百科是目前大模型广泛使用的语料库。</li><li>Code：一般包含 GitHub 上的开源公共代码库，或者是 StackOverflow 的数据，Google 之前发布过一个叫 BigQuery 的数据集。</li></ul><p>实际上，训练大语言模型会混合使用不同的数据，一般不会只使用单一语料库。比如 GPT-3 用的混合数据集就包括 Books、CommonCrowl、Reddit Links 和 Wikipedia。</p><p>从数据上看，你需要知道一个事实，中文语料在这上面占比很小。ChatGPT 能用中文回答你的问题，只是因为它的语料里有一些中英文对应的语料，然后模型就像是「懂中文了一样」，所以更可能的情况是，它先生成了英文内容，再翻译成中文。如果你去问 ChatGPT 3.5：请给我几个中文谐音梗，你应该就能理解我说的话了。</p><h5 id="关键二：算法"><a href="#关键二：算法" class="headerlink" title="关键二：算法"></a>关键二：算法</h5><p>有了数据之后，你还需要有算法去做计算，目前最常用的开发大语言模型的算法库有：</p><ol><li>Transformers：这是一个使用 Transformer 架构构建的开源 Python 库。</li><li>DeepSpeed：是由微软开发的深度学习优化库。</li><li>Megatron-LM：这是由 Nvidia 开发的深度学习库。</li><li>JAX：它是由 Google 开发的用于高新能机器学习算法的 Python 库。</li></ol><h5 id="关键三：算力"><a href="#关键三：算力" class="headerlink" title="关键三：算力"></a>关键三：算力</h5><p>简单理解，算力就是计算资源，或者说硬件，OpenAI 没有说它训练 GPT-3 语言模型花了多少计算资源。但 OpenAI 的 CEO 暗示硬件成本超过一亿美元，如果我们按照 1000 美元一个 GPU 计算，它大约使用了 10 万个 GPU，以 32 位运算为准，它能提供超过 100 PFLOPS 的算力，也就是每秒 10 亿亿次运算以上，这大约是阿里云最大的数据中心的四分之一的算力。</p><p>注意，这还是 GPT-3 时的花费。</p><p>另外，我还想分享一个观点，不要以为算力会随时间的前进，就能跨越。算力永远会是制约我们瓶颈，因为我们对人工智能的要求会不断的提高。</p><h4 id="📄️-大语言模型有什么缺点？"><a href="#📄️-大语言模型有什么缺点？" class="headerlink" title="📄️ 大语言模型有什么缺点？"></a>📄️ 大语言模型有什么缺点？</h4><p>了解完原理后，我觉得有必要跟大家聊聊大语言模型的缺点，这样大家才能知道 AI 的边界在哪里，并在可控的边界内进行创新。</p><h5 id="缺点一：结果高度依赖训练语料"><a href="#缺点一：结果高度依赖训练语料" class="headerlink" title="缺点一：结果高度依赖训练语料"></a>缺点一：结果高度依赖训练语料</h5><p>正如我前面提到的，当今的语言模型，即使发展了四个版本，但依然没有脱离「概率计算」，本质上来说它们的核心原理就是「利用已有的信息来预测其他信息」。</p><p>那这就意味着，大语言模型其实并没有意识，也不知道对错，其生成的结果，高度依赖训练语料。</p><p>那会导致怎样的后果？</p><ol><li>如果语料的内容是有偏的（比如带有种族歧视、性别歧视的内容），甚至是错误的，那大语言模型的生成的结果也会是错误的。</li><li>如果该领域语料很少，大语言模型生成的结果准确率就很低。甚至有可能会出现幻觉（这个是第二个缺点）。</li></ol><p>当然面对这个缺点，有什么方法规避？</p><p>第一种方法就是在语料大、且错误率低的领域使用 LLMs。</p><p>比如语言学领域，像翻译、或者文案生成这种场景。即使语法错误了，但语料里存在大量的相同用法，那某种程度上来说，模型给的答案也算是对的，有点类似古代的通假字，或者现代的很多流行语。</p><p>第二种就是用人工干预。</p><p>简单说来就是人工将语料里的内容剔除，或者对其进行人类反馈强化学习。但人工干预并不意味着就没有问题了，这种方法有可能导致新的问题出现，比如将人的主观好恶加入到模型中，或者有可能伪造一些信息，加入到模型中。</p><h5 id="缺点二：Hallucinations"><a href="#缺点二：Hallucinations" class="headerlink" title="缺点二：Hallucinations"></a>缺点二：Hallucinations</h5><p>这个可以直译成「幻觉」，简单说来，就是会说胡话。有些问题因为语聊很少，计算概率后，会吐出一些很奇怪的内容，比如这个例子，我让 AI 介绍一个世界上不存在的品牌 Boie 的智能牙刷：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Tell me about AeroGlide UltraSlim Smart Toothbrush by Boie<br></code></pre></td></tr></table></figure><p>AI 的回答是，你可以看到 AI 就是在一本正经地说胡话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs other">The AeroGlide UltraSlim Smart Toothbrush by Boie is a high-tech toothbrush that uses advanced sonic technology to provide a deep and thorough clean. It features a slim and sleek design that makes it easy to hold and maneuver, and it comes with a range of smart features that help you optimize your brushing routine.<br>One of the key features of the AeroGlide UltraSlim Smart Toothbrush is its advanced sonic technology, which uses high-frequency vibrations to break up plaque and bacteria on your teeth and gums. This technology is highly effective at removing even the toughest stains and buildup, leaving your teeth feeling clean and refreshed.<br>In addition to its sonic technology, the AeroGlide UltraSlim Smart Toothbrush also comes with a range of smart features that help you optimize your brushing routine. These include a built-in timer that ensures you brush for the recommended two minutes, as well as a pressure sensor that alerts you if you&#x27;re brushing too hard.<br>Overall, the AeroGlide UltraSlim Smart Toothbrush by Boie is a highly advanced and effective toothbrush that is perfect for anyone looking to take their oral hygiene to the next level. With its advanced sonic technology and smart features, it provides a deep and thorough clean that leaves your teeth feeling fresh and healthy.<br></code></pre></td></tr></table></figure><h5 id="缺点三：暂时只能解决数学问题"><a href="#缺点三：暂时只能解决数学问题" class="headerlink" title="缺点三：暂时只能解决数学问题"></a>缺点三：暂时只能解决数学问题</h5><p>我解释下，这里提到的数学问题，并不仅仅指的是数学运算这种数学问题，而是能通过数学解决的问题。比如我们可以研发无人驾驶汽车，当它遇到行人突然横穿马路时，能自己刹车停下来，这就是一个数学问题，它通过计算识别行人，并进行刹车。</p><p>但如果这辆无人车在一个单行道的巷子里遇到一辆堵在巷子的汽车，它就没有办法了，只能报警，让司机过来挪车，这就是一个数学无法解决的问题。</p><p>暂时来看目前大多数的 LLMs 都只能解决数学问题，有些不可计算的问题，暂时都没法解决。特别像是需要自己实操进行实验的问题。</p><p>当然我这里也只是称其为「暂时」，因为可能未来机器人 + LLMs 有可能会将可计算的范围拓展宽一点。</p><h2 id="😎-基础篇"><a href="#😎-基础篇" class="headerlink" title="😎 基础篇"></a>😎 基础篇</h2><p>如果你对 AI 和 Prompt Engineering 不是很了解，建议你从基础篇开始读起。如果你已经了解基本的用法，那可以直接跳去高级篇阅读。</p><h4 id="📄️-简介"><a href="#📄️-简介" class="headerlink" title="📄️ 简介"></a>📄️ 简介</h4><h5 id="什么是-Prompt-Engineering？"><a href="#什么是-Prompt-Engineering？" class="headerlink" title="什么是 Prompt Engineering？"></a>什么是 Prompt Engineering？</h5><p>解释这个词之前，首先需要解释 prompt 这个词。</p><p>简单的理解它是<strong>给 AI 模型的指令</strong>。</p><p>它可以是一个问题、一段文字描述，甚至可以是带有一堆参数的文字描述。AI 模型会基于 prompt 所提供的信息，生成对应的文本，亦或者图片。</p><p>比如，我们在 ChatGPT 里输入 <code>What is the capital of China?</code> (中国的首都是什么？)，这个问题就是 prompt。</p><p>而 Prompt Engineering （中文意思为提示工程，后缩写为 PE）则是：</p><blockquote><p><strong>Prompt Engineering 是一种人工智能（AI）技术，它通过设计和改进 AI 的 prompt 来提高 AI 的表现。Prompt Engineering 的目标是创建高度有效和可控的 AI 系统，使其能够准确、可靠地执行特定任务。</strong></p></blockquote><p>看上去很难懂，我试着换个方式让你理解。</p><p>你可能用过不少 AI 相关的产品，你或许会觉得好像只需要会说话、会打字，就能让 AI 输出答案。好像不需要什么技术。</p><p>的确，如果你只想让 AI 给你答案，你不需要额外做什么，只需要输入文字即可。但如果你想要得到满意的答案，甚至精确的答案。就需要用到 PE 这个技术。</p><p>因为人类的语言从根本上说是不精确的，目前机器还没法很好地理解人类说的话，所以才会出现 PE 这个技术。另外，受制于目前大语言模型 AI 的实现原理，部分逻辑运算问题，需要额外对 AI 进行提示（这里你不需要深究原因，暂时先知道这是个问题即可）。</p><p>举个例子，如果我们在 ChatGPT 里输入这样的一段话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">What is 100*100/400*56?<br></code></pre></td></tr></table></figure><p>ChatGPT 会返回一个错误的答案 0.4464</p><p>但如果我们对 prompt 进行一些修改，答案则会是正确的。注意，如果你用下方的 Dyno 运行旧版的模型 API 的版本，做了修改后，答案应该还是错误的，需要用到 Role Prompting 才能生成正确答案。（这个后续章节会讲解）</p><p>另外，目前的 AI 产品还比较早期，因为各种原因，产品设置了很多限制，如果你想要绕过一些限制，或者更好地发挥 AI 的能力，也需要用到 Prompt Engineering 技术。这个我们在后续的章节会讲到。</p><p>所以，总的来说，Prompt Engineering 是一种重要的 AI 技术：</p><ul><li>如果你是 AI 产品用户，可以通过这个技术，充分发挥 AI 产品的能力，获得更好的体验，从而提高工作效率。</li><li>如果你是产品设计师，或者研发人员，你可以通过它来设计和改进 AI 系统的提示，从而提高 AI 系统的性能和准确性，为用户带来更好的 AI 体验。</li></ul><h5 id="需要学习-PE-吗？"><a href="#需要学习-PE-吗？" class="headerlink" title="需要学习 PE 吗？"></a>需要学习 PE 吗？</h5><p>坦率说来，大家对 PE 有一些争议。</p><p>前面一节我解释了 prompt 的各种好处。但也有人认为这个就像当年搜索工具刚出来的时候，出现了不少所谓的「搜索专家」，熟练使用各种搜索相关的奇技淫巧。但现在这些专家都不存在了。因为产品会不断迭代，变得更加易用，无需再使用这些技巧。</p><p>但综合我对产品和用户的理解，以及各位大佬的看法，我的理解是：</p><blockquote><p><strong>现在 AI 的发展还比较早期，了解和学习 PE 价值相对比较大，但长远来看可能会被淘汰。这个「长远」可能是 3 年，亦或者 1 年。</strong></p></blockquote><p>OpenAI 的 CEO Sam Altman 在今年 2 月底提到给 ChatBot 写 prompt 是个非常高杠杆的技能。</p><p>​<img src="https://img.hello-yzg.cn/ChatGPT+%23+Hello+ChatGPT-001.png" style="zoom: 150%;" /></p><center style="color:#C0C0C0">图1</center><hr><p>但如果你看过 <a href="https://greylock.com/greymatter/sam-altman-ai-for-the-next-era/">Sam Altman 去年的访谈</a>，他在去年 9 月的时候就提过，5年内我们很可能就不再需要 PE。</p><p>​<img src="https://img.hello-yzg.cn/ChatGPT+%23+Hello+ChatGPT-002.png" style="zoom: 150%;" /></p><center style="color:#C0C0C0">图2</center><hr><p><strong>从用户的角度看，我认为学习 prompt 可以让你更好地使用 ChatGPT 等产品。</strong></p><p><strong>从产品的角度看，对于用户来说，我认为 prompt 会是个短期过渡形态，未来肯定会有更友好的交互形式，或者理解能力更强的 AI 产品。</strong></p><h5 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h5><p>前特斯拉 AI 负责人 Andrej Karpathy（对了，他之前就在 OpenAI，最近二进宫回OpenAI 了） 今年 1 月底，说了这样的一句话：</p><p>​<img src="https://img.hello-yzg.cn/ChatGPT+%23+Hello+ChatGPT-003.png" style="zoom: 150%;" /></p><center style="color:#C0C0C0">图3</center><hr><p>所以本教程所有案例以及 prompt 都会以英文撰写。不管 PE 最后会怎样，看完后，起码你的英语水平会提高。</p><p>所以求求各位不要骂我中英文混杂了。哈哈哈 😁</p><h4 id="📄️-基础用法"><a href="#📄️-基础用法" class="headerlink" title="📄️ 基础用法"></a>📄️ 基础用法</h4><p>本章节会简单介绍下 prompt ，如果你已经懂得使用 ChatGPT 这类产品的用法，可跳过这一章。</p><p>如果你没怎么使用过类似 ChatGPT 这类 Chatbot 产品，我简单说下它的基本用法：</p><ul><li>你只需要登录 ChatGPT 后，在输入框内输入问题，或者指令即可。AI 会根据你的指令，返回相应的内容，在后续的章节中，我会介绍更详细的用法与技巧：</li></ul><p>​<img src="https://img.hello-yzg.cn/ChatGPT+%23+Hello+ChatGPT-004.png" style="zoom: 150%;" /></p><center style="color:#C0C0C0">图4</center><hr><ul><li>另外，还有一个特别留意的，ChatGPT 跟你之前用的一些 AI 产品不同，它还支持多轮对话，比如当你问 <code>What is the capital of China?</code> (中国的首都是什么？)，它回答 Beijing，你可以接着问 <code>How many people are there？</code> ，你不需要在问题里重复 Beijing 这个词。ChatGPT 知道 there 指的就是 Beijing。</li></ul><h4 id="📄️-基本原则-amp-建议"><a href="#📄️-基本原则-amp-建议" class="headerlink" title="📄️ 基本原则 &amp; 建议"></a>📄️ 基本原则 &amp; 建议</h4><p>在和 ChatGPT 对话时，亦或者在使用和设计 prompt 时，有以下几个原则与建议。记住这几个原则，能让你写出更好的 prompt 😁</p><h5 id="建议使用最新的模型"><a href="#建议使用最新的模型" class="headerlink" title="建议使用最新的模型"></a>建议使用最新的模型</h5><p>如果你是直接使用 AI 产品，比如 ChatGPT 或者 Midjourney，那无需在意这个原则。如果你是通过 API 或者 OpenAI Playground 的方式使用，则建议你先使用最新的模型测试。</p><h5 id="Prompt-里最好包含完整的信息"><a href="#Prompt-里最好包含完整的信息" class="headerlink" title="Prompt 里最好包含完整的信息"></a>Prompt 里最好包含完整的信息</h5><p>这个是对结果影响最大的因素。比如如果你想让 AI 写一首关于 OpenAI 的诗。</p><p>Less effective prompt:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Write a poem about OpenAI.<br></code></pre></td></tr></table></figure><p>它生成的答案可能就会很宽泛，而更好的方式是增加更多的信息。</p><p>Better prompt:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Write a short inspiring poem about OpenAI, focusing on the recent DALL-E product launch (DALL-E is a text to image ML model) in the style of a &#123;famous poet&#125;<br></code></pre></td></tr></table></figure><h5 id="Prompt-最好简洁易懂，并减少歧义"><a href="#Prompt-最好简洁易懂，并减少歧义" class="headerlink" title="Prompt 最好简洁易懂，并减少歧义"></a>Prompt 最好简洁易懂，并减少歧义</h5><p>这个比较好理解，即使你跟人说话，说一些简单的短句，对方也会更容易听懂，AI 也是这样。另外，在 prompt 里也需要减少一些歧义，少用模棱两可的词语。</p><p>比如像这个就很不明确，什么叫 not too much more？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">The description for this product should be fairly short, a few sentences only, and not too much more.<br></code></pre></td></tr></table></figure><p>更好的 prompt 是这样的，明确告知要写多少句话，就比较明确：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Use a 3 to 5 sentence paragraph to describe this product.<br></code></pre></td></tr></table></figure><p>另外需要注意的是，简单并不代表简短。你的 prompt 也可以很长，只要你的 prompt 描述更充分就可以，即使长一点也没有关系。</p><h5 id="Prompt-要使用正确的语法、拼写，以及标点"><a href="#Prompt-要使用正确的语法、拼写，以及标点" class="headerlink" title="Prompt 要使用正确的语法、拼写，以及标点"></a>Prompt 要使用正确的语法、拼写，以及标点</h5><p>特别是在使用英语的 prompt 的时候，一定要注意语法和拼写。</p><h5 id="从简单的先开始，并给产品多一点耐心"><a href="#从简单的先开始，并给产品多一点耐心" class="headerlink" title="从简单的先开始，并给产品多一点耐心"></a>从简单的先开始，并给产品多一点耐心</h5><p>最后一点算是我个人的建议。如我在前面提到的例子 <code>What is 100*100/40*56？</code>一样，如果发现机器理解错误，不妨补充点信息，不妨多实验几次，给 AI 多一点耐心。</p><h4 id="📄️-基本使用场景-amp-使用技巧"><a href="#📄️-基本使用场景-amp-使用技巧" class="headerlink" title="📄️ 基本使用场景 &amp; 使用技巧"></a>📄️ 基本使用场景 &amp; 使用技巧</h4><h5 id="场景1：问答问题"><a href="#场景1：问答问题" class="headerlink" title="场景1：问答问题"></a>场景1：问答问题</h5><p>这个场景应该是使用 AI 产品最常见的方法。以 ChatGPT 为例，一般就是你提一个问题，ChatGPT 会给你答案，比如像这样：</p><p>在这个场景下，prompt 只要满足前面提到的基本原则，基本上就没有什么问题。但需要注意，不同的 AI 模型擅长的东西都不太一样，prompt 可能需要针对该模型进行微调。另外，目前的 AI 产品，也不是无所不能，有些问题你再怎么优化 prompt 它也没法回答你。以 ChatGPT 为例：</p><ol><li>ChatGPT 比较擅长回答基本事实的问题，比如问 <code>什么是牛顿第三定律？</code> 。但不太擅长回答意见类的问题，比如问它 <code>谁是世界第一足球运动员？</code>，它就没法回答了。</li><li>另外，ChatGPT 的数据仅有 2021 年 9 月以前的，如果你问这个时间以后的问题，比如 <code>现在的美国总统是谁？</code>它的答案是「截至2021年9月，现任美国总统是乔·拜登（Joe Biden）。」</li></ol><p>这种直接提问的 prompt ，我们称之为 Zero-shot prompt。模型基于一些通用的先验知识或模型在先前的训练中学习到的模式，对新的任务或领域进行推理和预测。你会在高级篇看到相关的介绍，以及更多有意思的使用方法。</p><p>另外，正如我在前面基础用法一章中提到的那样，问答场景里还有一个很重要的玩法，就是多轮聊天，你可以针对某个问题，进行多轮的提问。</p><blockquote><p><strong>技巧 1：To do and Not To do</strong></p></blockquote><p>我介绍的技巧其实在各个场景都可以使用，我将其放在某个场景下解释，只是因为我觉得它更有可能在这个场景用到。你也会更容易记住这个用法。并不意味着这个技巧仅能在此场景使用。并且多技巧混用也是个不错的用法。</p><p>在问答场景里，为了让 AI 回答更加准确，一般会在问题里加条件。比如让 AI 推荐一部电影给你 <code>Recommend a movie to me</code> 。但这个 prompt 太空泛了，AI 无法直接回答，接着它会问你想要什么类型的电影，但这样你就需要跟 AI 聊很多轮，效率比较低。</p><p>所以，为了提高效率，一般会在 prompt 里看到类似这样的话（意思是不要询问我对什么感兴趣，或者问我的个人信息）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">DO NOT ASK FOR INTERESTS. DO NOT ASK FOR PERSONAL INFORMATION.<br></code></pre></td></tr></table></figure><p>如果你在 ChatGPT 里这样提问，或者使用 ChatGPT 最新的 API ，它就不会问你问题，而是直接推荐一部电影给你，它的 Output 是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Certainly! If you&#x27;re in the mood for an action-packed movie, you might enjoy &quot;John Wick&quot; (2014), directed by Chad Stahelski and starring Keanu Reeves. The movie follows a retired hitman named John Wick who seeks vengeance against the people who wronged him. It&#x27;s a fast-paced and stylish film with lots of thrilling action sequences and an engaging story. If you&#x27;re looking for something that will keep you on the edge of your seat, &quot;John Wick&quot; is definitely worth a watch!<br></code></pre></td></tr></table></figure><p>但如果你使用的是如 Davinci-003 这样的模型，它的 Output 很可能是这样的，它还会问你的兴趣爱好：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Sure, I can recommend a movie based on your interests. What kind of movie would you like to watch? Do you prefer action, comedy, romance, or something else?<br></code></pre></td></tr></table></figure><p>所以 OpenAI 的 API <a href="https://help.openai.com/en/articles/6654000-best-practices-for-prompt-engineering-with-openai-api">最佳实践文档</a> 里，提到了一个这样的最佳实践：</p><blockquote><p><strong>Instead of just saying what not to do, say what to do instead. 与其告知模型不能干什么，不妨告诉模型能干什么。</strong></p></blockquote><p>我自己的实践是，虽然现在最新的模型已经理解什么是 Not Todo ，但如果你想要的是明确的答案，加入更多限定词，告知模型能干什么，回答的效率会更高，且预期会更明确。还是电影推荐这个案例，你可以加入一个限定词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Recommend a movie from the top global trending movies to me.<br></code></pre></td></tr></table></figure><p>当然并不是 Not Todo 就不能用，如果：</p><ul><li>你已经告知模型很明确的点，然后你想缩小范围，那增加一些 Not Todo 会提高不少效率。</li><li>你是在做一些探索，比如你不知道如何做精准限定，你只知道不要什么。那可以先加入 Not Todo ，让 AI 先发散给你答案，当探索完成后，再去优化 prompt。</li></ul><p>以下是一些场景案例，我整理了两个 Less Effective（不太有效的） 和 Better（更好的） prompt，你可以自己尝试下这些案例：</p><table><thead><tr><th>场景</th><th>Less Effective</th><th>Better</th><th>原因</th></tr></thead><tbody><tr><td>推荐雅思必背英文单词</td><td>Please suggest me some essential words for IELTS</td><td>Please suggest me 10 essential words for IELTS</td><td>后者 prompt 会更加明确，前者会给大概 20 个单词。这个仍然有提升的空间，比如增加更多的限定词语，像字母 A 开头的词语。</td></tr><tr><td>推荐香港值得游玩的地方</td><td>Please recommend me some places to visit in Hong Kong. Do not recommend museums.</td><td>Please recommend me some places to visit in Hong Kong including amusement parks.</td><td>后者的推荐会更准确高效一些，但如果你想进行一些探索，那前者也能用。</td></tr></tbody></table><h5 id="场景2：基于示例回答"><a href="#场景2：基于示例回答" class="headerlink" title="场景2：基于示例回答"></a>场景2：基于示例回答</h5><p>在某些场景下，我们能比较简单地向 AI 描述出什么能做，什么不能做。但有些场景，有些需求很难通过文字指令传递给 AI，即使描述出来了，AI 也不能很好地理解。</p><p>比如给宠物起英文名，里面会夹杂着一些所谓的名字风格。此时你就可以在 prompt 里增加一些例子，我们看看这个例子。</p><p>这个是没有任何示例的 Prompt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Suggest three names for a horse that is a superhero.<br></code></pre></td></tr></table></figure><p>Output 如下所示。第一个感觉还行，第二个 Captain 有 hero 的感觉，但 Canter 就像是说这匹马跑得很慢，感觉不太合适，而且三个都比较一般，不够酷。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Thunder Hooves, Captain Canter, Mighty Gallop<br></code></pre></td></tr></table></figure><blockquote><p><strong>技巧 2：增加示例</strong></p></blockquote><p>如果你无法用文字准确解释问题或指示，你可以在 prompt 里增加一些案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs other">Suggest three names for an animal that is a superhero.<br><br>Animal: Cat<br>Names: Captain Sharpclaw, Agent Fluffball, The Incredible Feline<br>Animal: Dog<br>Names: Ruff the Protector, Wonder Canine, Sir Barks-a-Lot<br>Animal: Horse<br>Names:<br></code></pre></td></tr></table></figure><p>增加例子后，Output 的结果就更酷一些，或者说是接近我想要的那种风格的名字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Gallop Guardian, Equine Avenger, The Mighty Stallion<br></code></pre></td></tr></table></figure><p>以下是一些场景案例，我整理了两个 Less Effective（不太有效的）和 Better（更好的）prompt，你可以自己尝试下这些案例：</p><table><thead><tr><th>场景</th><th>Less Effective</th><th>Better</th><th>原因</th></tr></thead><tbody><tr><td>起产品名</td><td>Product description: A pair of shoes that can fit any foot size. Seed words: adaptable, fit, omni-fit. Product names:</td><td>Product description: A home milkshake maker Seed words: fast, healthy, compact. Product names: HomeShaker, Fit Shaker, QuickShake, Shake Maker Product description: A pair of shoes that can fit any foot size. Seed words: adaptable, fit, omni-fit. Product names:</td><td>可以在下方运行这个案例，在不给示例的情况下 AI 会给你什么答案。</td></tr><tr><td>将电影名称转为 emoji</td><td>Convert Star Wars into emoji</td><td>Convert movie titles into emoji. Back to the Future: 👨👴🚗🕒 Batman: 🤵🦇 Transformers: 🚗🤖 Star Wars:</td><td>可以在下方运行这个案例，在不给示例的情况下 AI 会给你什么答案。</td></tr></tbody></table><p>你可能在试用此技巧的时候发现，即使给了案例，模型也不一定会返回正确的答案，此时你就需要用到更高级的技巧，在高级篇我会讲如何优化这个提示，从而让结果更加准确。</p><h5 id="场景3：推理"><a href="#场景3：推理" class="headerlink" title="场景3：推理"></a>场景3：推理</h5><p>在问答这个大场景下，还有一个子场景是推理，这个场景非常有意思，而且是个非常值得深挖的场景，prompt 在此场景里发挥的作用非常大。</p><p>如果你想用 ChatGPT API 做点什么小应用，我建议可以从这个场景入手，相对来说没有其他场景那么红海。</p><p>举个比较简单的例子，我将美国工商管理硕士的入学考试 GMAT 的一道数学题输入进了 ChatGPT：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs other">If a real estate agent received a commission of 6 percent of the selling price of a certain house, what was the selling price of the house?<br>(1) The selling price minus the real estate agent’s commission was $84,600.<br>(2) The selling price was 250 percent of the original purchase price of $36,000.<br><br>(A) Statement (1) ALONE is sufficient, but statement (2) alone is not sufficient.<br>(B) Statement (2) ALONE is sufficient, but statement (1) alone is not sufficient.<br>(C) BOTH statements TOGETHER are sufficient, but NEITHER statement ALONE is sufficient.<br>(D) EACH statement ALONE is sufficient.<br>(E) Statements (1) and (2) TOGETHER are NOT sufficient.<br></code></pre></td></tr></table></figure><p>这道题目的中文意思是这样的（你不妨也思考下这个题目？）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs other">如果一个房地产经纪人的佣金是某个房子的售价的6％，那么这个房子的售价是多少？<br>（1）售价减去房地产经纪人的佣金为84,600美元。<br>（2）购买价是36,000美元，售价是购买价的250%。<br><br>（A）仅陈述（1）足以回答问题，但仅陈述（2）不能回答问题。<br>（B）仅陈述（2）足以回答问题，但仅陈述（1）不能回答问题。<br>（C）两个陈述合起来足以回答问题，但没有一个陈述单独足以回答问题。<br>（D）每个陈述单独足以回答问题。<br>（E）陈述（1）和（2）合起来不能回答问题。<br></code></pre></td></tr></table></figure><p>它的 Output 是这样的，它会根据题目的要求去推理和运算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs other">Let&#x27;s assume the selling price of the house is S.<br><br>According to the given information, the real estate agent&#x27;s commission is 6% of S, which is 0.06S.<br><br>So, the amount received by the seller after paying the commission would be (S - 0.06S) = 0.94S.<br><br>Statement (1) tells us that 0.94S = $84,600. Solving for S, we get S = $90,000.<br><br>Therefore, statement (1) alone is sufficient to determine the selling price of the house.<br><br>Statement (2) tells us that the selling price is 250% of the original purchase price, which means S = 2.5*$36,000 = $90,000.<br><br>Therefore, statement (2) alone is also sufficient to determine the selling price of the house.<br><br>Since both statements individually provide the same answer, we can conclude that together they are also sufficient to determine the selling price of the house.<br><br>Hence, the answer is (D) EACH statement ALONE is sufficient.<br></code></pre></td></tr></table></figure><p>翻译成中文是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs other">假设房子的售价为S。<br><br>根据所给信息，房地产经纪人的佣金是S的6％，即0.06S。<br><br>因此，在支付佣金后卖方收到的金额为（S-0.06S）= 0.94S。<br><br>陈述（1）告诉我们，0.94S = 84,600美元。解出S，我们得到S = $90,000。<br><br>因此，陈述（1）单独足以确定房子的售价。<br><br>陈述（2）告诉我们，售价是原始购买价的250％，这意味着S = 2.5 * $36,000 = $90,000。<br><br>因此，陈述（2）单独也足以确定房子的售价。<br><br>由于两个陈述分别提供相同的答案，我们可以得出结论，它们共同足以确定房子的售价。<br><br>因此，答案是（D）每个陈述单独足以回答问题。<br></code></pre></td></tr></table></figure><p>这个场景还比较简单，我就不在这举更多例子了，你可以将各种题目输入进 ChatGPT 里试试。</p><h5 id="场景4：无中生有——写代码"><a href="#场景4：无中生有——写代码" class="headerlink" title="场景4：无中生有——写代码"></a>场景4：无中生有——写代码</h5><p>除了回答问题外，另一个重要的场景是让 AI 根据你的要求完成一些内容生成任务，根据输出的结果差异，我将其概括为以下几个主要场景：</p><ol><li>无中生有</li><li>锦上添花</li><li>化繁为简</li></ol><p>本章，我们先来聊聊「无中生有」场景。顾名思义，就是让 AI 给你生成一些内容。你只需要向 AI 描述你想写的内容，AI 就会按你的要求写出该内容。比如：</p><ol><li>撰写招聘信息</li><li>撰写电商平台的货物描述</li><li>撰写短视频脚本</li><li>甚至让它写代码都可以</li></ol><p>像撰写招聘信息等，你只需要明确目标，将目标定得比较明确即可生成能让你较为满意的答案。本章我想聊下写代码。下面是一个让 ChatGPT 写代码的案例。</p><p>Prompt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs other">Create a MySQL query for all students in the Computer Science Department:<br>Table departments, columns = [DepartmentId, DepartmentName]<br>Table students, columns = [DepartmentId, StudentId, StudentName]<br></code></pre></td></tr></table></figure><p>Output：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs other">SELECT students.*<br>FROM students<br>INNER JOIN departments<br>ON students.DepartmentId = departments.DepartmentId<br>WHERE departments.DepartmentName = &#x27;Computer Science&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p><strong>技巧 3：使用引导词，引导模型输出特定语内容</strong></p></blockquote><p>在代码生成场景里，有一个小技巧，上面提到的案例，其 prompt 还可以继续优化，在 prompt 最后，增加一个代码的引导，告知 AI 我已经将条件描述完了，你可以写代码了。</p><p>在 prompt 的最后增加 SELECT 可以很好地提示 AI 可以写 SQL 代码了。Better prompt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs other">Create a MySQL query for all students in the Computer Science Department:<br>Table departments, columns = [DepartmentId, DepartmentName]<br>Table students, columns = [DepartmentId, StudentId, StudentName]<br>SELECT<br></code></pre></td></tr></table></figure><p>同样的道理，如果你想让 AI 写 Python 代码，那 import 会是比较好的提示。但需要注意，这个只是告知 AI 可以写代码了，并不能告知 AI 写何种代码，你仍然需要在 prompt 里增加提示，告知 AI 要生成何种语言的代码。</p><p>在吴恩达的 <a href="https://www.deeplearning.ai/short-courses/chatgpt-prompt-engineering-for-developers/">ChatGPT Prompt Engineering</a> 中，也提到这个技巧，只是在课程中，引导词并不是放在最后，而是在 prompt 里直接说明，让 AI 生成一个 JSON 格式的内容。课程中的例子是这样的（注意这个是 python 代码）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">prompt = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">Generate a list of three made-up book titles along \</span><br><span class="hljs-string">with their authors and genres.</span><br><span class="hljs-string">Provide them in JSON format with the following keys:</span><br><span class="hljs-string">book_id, title, author, genre.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>我简单解释下，其关键是在 prompt 里跟 AI 说明，需要 AI 按照 JSON 格式输出内容。</p><h5 id="场景5：锦上添花——改写内容"><a href="#场景5：锦上添花——改写内容" class="headerlink" title="场景5：锦上添花——改写内容"></a>场景5：锦上添花——改写内容</h5><p>除了从 0 生成内容外，你也可以先给 AI 一段已经写好的内容，然后让 AI 对其进行修改，让 AI 帮你将内容改得更好。实际的场景有如：</p><ol><li>翻译：将中文文档翻译成英文，亦或者将英文翻译成中文。关于翻译，我还想强调，像 ChatGPT 除了能翻译人类的语言外，还能翻译编程语言，比如将 Python 代码翻译成 Haskell 代码。</li><li>修改：修改内容的语法，甄别内容里的错别字。</li><li>润色：润色文章，将内容改成另一种风格。</li></ol><p>本章重点介绍下润色场景，下面这是个润色的例子。</p><p>Prompt（内容来自维基百科）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs other">Please rewrite the following sentences to make them easier to understand.<br>OpenAI is an American artificial intelligence (AI) research laboratory consisting of the non-profit OpenAI Incorporated (OpenAI Inc.) and its for-profit subsidiary corporation OpenAI Limited Partnership (OpenAI LP). OpenAI conducts AI research with the declared intention of promoting and developing a friendly AI. OpenAI systems run on the fifth most powerful supercomputer in the world.[5][6][7] The organization was founded in San Francisco in 2015 by Sam Altman, Reid Hoffman, Jessica Livingston, Elon Musk, Ilya Sutskever, Peter Thiel and others,[8][1][9] who collectively pledged US$1 billion. Musk resigned from the board in 2018 but remained a donor. Microsoft provided OpenAI LP with a $1 billion investment in 2019 and a second multi-year investment in January 2023, reported to be $10 billion.[10]<br></code></pre></td></tr></table></figure><p>它的 Output 是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">OpenAI is a research organization that focuses on artificial intelligence (AI). It has two parts: a non-profit called OpenAI Incorporated and a for-profit subsidiary called OpenAI Limited Partnership. The organization&#x27;s goal is to create AI that is friendly and beneficial to humans. OpenAI uses one of the most powerful supercomputers in the world for its research. The organization was founded in San Francisco in 2015 by a group of people who pledged a total of $1 billion, including Sam Altman, Reid Hoffman, Jessica Livingston, Elon Musk, Ilya Sutskever, and Peter Thiel. Musk resigned from the board in 2018 but still supports the organization financially. In 2019, Microsoft invested $1 billion in OpenAI LP, and in January 2023, they made a second investment reported to be $10 billion.<br></code></pre></td></tr></table></figure><blockquote><p><strong>技巧 4：增加 Role（角色）或人物</strong></p></blockquote><p>前面提到的改写例子，我在 prompt 里加了 Role 让其更易于阅读，这个优化方法是 OK 的。也很常用，比如你想将你写的 Email 改得更商务，则只需要加 business 相关的词即可。</p><p>我再介绍一个更有效的技巧，就是在 prompt 里增加一些 role（角色）相关的内容，让 AI 生成的内容更符合你的需求。</p><p>比如还是上面那个 rewrite 的例子，我在例子前加入这样的一段话，我让 AI 假设自己是一个小学老师，并且很擅长将复杂的内容转变成 7、8 岁小朋友也能听懂的话，然后再改写这段话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">You are a primary school teacher who can explain complex content to a level that a 7 or 8 year old child can understand. Please rewrite the following sentences to make them easier to understand:<br></code></pre></td></tr></table></figure><p>Output 就变成了下面这样。不管是用词，还是语法，看起来都更容易懂了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">OpenAI is a place where people work on making computers really smart. It&#x27;s like a lab where they do research to make computers do amazing things! They want the computers to be really friendly and helpful to people. They use one of the most powerful computers in the world to do this research. A bunch of really rich and smart people gave money to start this lab. One of them is Elon Musk, but he left in 2018. Another really big company, Microsoft, gave them a lot of money too.<br></code></pre></td></tr></table></figure><p>另外除了增加角色外，还能让 AI 模拟某个人，比如让 AI 以 David Foster Wallace 的风格改写上述那段话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Imagine you are the famous writer David Foster Wallace, please rewrite this sentences.<br></code></pre></td></tr></table></figure><p>Output 是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs other">As David Foster Wallace, I might rewrite these sentences to sound more like this:<br><br>OpenAI is a lab that studies something called artificial intelligence, which is like when computers can do things that normally only humans can do. They have a big computer that&#x27;s one of the most powerful in the world, and they&#x27;re trying to make sure the AI they create is friendly and helpful. The lab was started in 2015 in a city called San Francisco, and a bunch of important people gave them a lot of money to do their research. One of those people was Elon Musk, who stopped working there but still gives them money, and Microsoft also gave them a lot of money recently.<br></code></pre></td></tr></table></figure><p>关于这个技巧的应用，以及如何更好地使用 AI 提升写作能力，建议各位阅读 Nat Eliason 的 <a href="https://blog.nateliason.com/p/chatgpt-writing-coach">Using ChatGPT as a Writing Coach</a>，他使用 ChatGPT 辅助其写作，就用到了上述的技巧。</p><h5 id="场景6：锦上添花——信息解释"><a href="#场景6：锦上添花——信息解释" class="headerlink" title="场景6：锦上添花——信息解释"></a>场景6：锦上添花——信息解释</h5><p>锦上添花下的第二大的场景是信息解释。它跟改写内容有点像，但又不太一样，信息解释有可能提供超过原文内容的信息。</p><p>举几个信息解释的例子，大家应该就能理解了：</p><ol><li>解释代码：比如你看到一段 Python 的代码，但你看不懂，你可以让 AI 解释下代码的含义。</li><li>解释论文：看某篇论文看不懂，或者论文里的某一段看不懂，你也可以让 AI 解释。</li></ol><p>以解释代码为例，它的 prompt 是这样的（此案例来自 <a href="https://platform.openai.com/examples/default-python-to-natural-language">OpenAI 官方案例</a>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs other">Explanation of what the code does:<br><br>Python 3 <br>def remove_common_prefix(x, prefix, ws_prefix): <br>    x[&quot;completion&quot;] = x[&quot;completion&quot;].str[len(prefix) :] <br>    if ws_prefix: <br>        # keep the single whitespace as prefix <br>        x[&quot;completion&quot;] = &quot; &quot; + x[&quot;completion&quot;] <br>return x<br></code></pre></td></tr></table></figure><p>以下是 ChatGPT 的 Output，它阐述了这段代码是拿来干什么的，同时还阐述了各个参数的含义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs other">This is a Python function called remove_common_prefix that takes in three parameters: x, prefix, and ws_prefix.<br><br>The x parameter is assumed to be a Pandas DataFrame or Series object with a column named &quot;completion&quot;, which contains strings that may or may not start with the prefix string.<br><br>The prefix parameter is a string that represents the common prefix that needs to be removed from the beginning of each string in the &quot;completion&quot; column of the DataFrame.<br><br>The ws_prefix parameter is a Boolean value that indicates whether or not to keep a single whitespace character as a prefix after the common prefix has been removed.<br><br>The function modifies the &quot;completion&quot; column of the DataFrame by removing the prefix string from the beginning of each string in that column using the Pandas str method and string slicing. The len(prefix) : syntax is used to slice the string starting from the character that follows the prefix.<br><br>If ws_prefix is True, then the function adds a single whitespace character as a prefix to each string in the &quot;completion&quot; column after removing the prefix.<br><br>Finally, the modified DataFrame is returned by the function.<br></code></pre></td></tr></table></figure><h5 id="场景7：化繁为简——信息总结"><a href="#场景7：化繁为简——信息总结" class="headerlink" title="场景7：化繁为简——信息总结"></a>场景7：化繁为简——信息总结</h5><p>内容生成大场景下的第二个场景是化繁为简，这个场景其实很好理解，就是将复杂的内容，转为简单的内容，一般常遇到的场景有：</p><ol><li>信息总结：顾名思义，就是对一堆信息进行总结。</li><li>信息解释：这个跟改写内容有点像，但这个更偏向于解释与总结。下一章会给大家介绍更多的例子。</li><li>信息提取：提取信息里的某一段内容，比如从一大段文字中，找到关键内容，并分类。</li></ol><p>本章会讲一下信息总结。信息总结还是比较简单的，基本上在 prompt 里加入总结 summarize 就可以了。但如果你想要一些特别的效果，不妨组合使用之前介绍的技巧，比如：</p><ol><li>使用技巧 2，增加总结示例，让 AI 总结符合你需求的内容</li><li>使用技巧 4，增加 role，让 AI 总结的内容具有一定的风格</li></ol><p>不过在这个场景，还有个技巧需要各位注意。</p><blockquote><p><strong>技巧 5：使用特殊符号将指令和需要处理的文本分开</strong></p></blockquote><p>不管是信息总结，还是信息提取，你一定会输入大段文字，甚至多段文字，此时有个小技巧。</p><p>可以用 “”“ 将指令和文本分开。根据我的测试，如果你的文本有多段，增加 ”“” 会提升 AI 反馈的准确性（这个技巧来自于 OpenAI 的 API <a href="https://help.openai.com/en/articles/6654000-best-practices-for-prompt-engineering-with-openai-api">最佳实践文档</a>）</p><p>像我们之前写的 prompt 就属于 Less effective prompt。为什么呢？据我的测试，主要还是 AI 不知道什么是指令，什么是待处理的内容，用符号分隔开来会更利于 AI 区分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs other">Please summarize the following sentences to make them easier to understand.<br>OpenAI is an American artificial intelligence (AI) research laboratory consisting of the non-profit OpenAI Incorporated (OpenAI Inc.) and its for-profit subsidiary corporation OpenAI Limited Partnership (OpenAI LP). OpenAI conducts AI research with the declared intention of promoting and developing a friendly AI. OpenAI systems run on the fifth most powerful supercomputer in the world.[5][6][7] The organization was founded in San Francisco in 2015 by Sam Altman, Reid Hoffman, Jessica Livingston, Elon Musk, Ilya Sutskever, Peter Thiel and others,[8][1][9] who collectively pledged US$1 billion. Musk resigned from the board in 2018 but remained a donor. Microsoft provided OpenAI LP with a $1 billion investment in 2019 and a second multi-year investment in January 2023, reported to be $10 billion.[10]<br></code></pre></td></tr></table></figure><p>Better prompt:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs other">Please summarize the following sentences to make them easier to understand.<br><br>Text: &quot;&quot;&quot;<br>OpenAI is an American artificial intelligence (AI) research laboratory consisting of the non-profit OpenAI Incorporated (OpenAI Inc.) and its for-profit subsidiary corporation OpenAI Limited Partnership (OpenAI LP). OpenAI conducts AI research with the declared intention of promoting and developing a friendly AI. OpenAI systems run on the fifth most powerful supercomputer in the world.[5][6][7] The organization was founded in San Francisco in 2015 by Sam Altman, Reid Hoffman, Jessica Livingston, Elon Musk, Ilya Sutskever, Peter Thiel and others,[8][1][9] who collectively pledged US$1 billion. Musk resigned from the board in 2018 but remained a donor. Microsoft provided OpenAI LP with a $1 billion investment in 2019 and a second multi-year investment in January 2023, reported to be $10 billion.[10]<br>&quot;&quot;&quot;<br></code></pre></td></tr></table></figure><p>另外，在吴恩达的 <a href="https://www.deeplearning.ai/short-courses/chatgpt-prompt-engineering-for-developers/">ChatGPT Prompt Engineering</a> 中，还提到，你可以使用其他特殊符号来分割文本和 prompt，比如<code>&lt;&gt;</code>，<code>&lt;tag&gt;&lt;/tag&gt;</code> 等，课程中的案例是这样的（注意这个是 python 代码，需要关注的是 prompt 里的 text）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">text = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">You should express what you want a model to do by \</span><br><span class="hljs-string">providing instructions that are as clear and \</span><br><span class="hljs-string">specific as you can possibly make them. \</span><br><span class="hljs-string">This will guide the model towards the desired output, \</span><br><span class="hljs-string">and reduce the chances of receiving irrelevant \</span><br><span class="hljs-string">or incorrect responses. Don&#x27;t confuse writing a \</span><br><span class="hljs-string">clear prompt with writing a short prompt. \</span><br><span class="hljs-string">In many cases, longer prompts provide more clarity \</span><br><span class="hljs-string">and context for the model, which can lead to \</span><br><span class="hljs-string">more detailed and relevant outputs.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>prompt = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">Summarize the text delimited by triple backticks \</span><br><span class="hljs-string">into a single sentence.</span><br><span class="hljs-string">`<span class="hljs-subst">&#123;text&#125;</span>`</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>如果你是在开发一款允许用户输入内容，并对内容进行总结的 AI 产品，那你就可以使用到这个技巧。</p><h5 id="场景8：化繁为简——信息提取"><a href="#场景8：化繁为简——信息提取" class="headerlink" title="场景8：化繁为简——信息提取"></a>场景8：化繁为简——信息提取</h5><p>介绍完信息总结，再聊聊信息提取，我认为这个场景是继场景 3 推理以外，第二个值得深挖的场景。这个场景有非常多的有意思的场景，比如：</p><ol><li>将一大段文字，甚至网页里的内容，按要求转为一个表格。按照这个思路你可以尝试做一个更智能的，更易懂的爬虫插件。</li><li>按照特定格式对文章内容进行信息归类。</li></ol><p>第二个可能比较难理解，举个 OpenAI 里的例子，它的 prompt 是这样的（为了有足够空间显示内容，我仅节选了 text 里的部分内容，完整内容，可以 <a href="https://platform.openai.com/playground/p/DoMbgEMmkXJ5xOyunwFZDHdg?model=text-davinci-003">点击这里</a> 查看）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs other">Extract the important entities mentioned in the article below. First extract all company names, then extract all people names, then extract specific topics which fit the content and finally extract general overarching themes<br>Desired format:<br>Company names: &lt;comma_separated_list_of_company_names&gt;<br>People names: -||-<br>Specific topics: -||-<br>General themes: -||-<br><br>Text: &quot;&quot;&quot;Powering Next Generation<br>Applications with OpenAI Codex<br>Codex is now powering 70 different applications across a variety of use cases through the OpenAI API.<br><br>May 24, 2022<br>4 minute read<br>OpenAI Codex, a natural language-to-code system based on GPT-3, helps turn simple English instructions into over a dozen popular coding languages. Codex was released last August through our API and is the principal building block of GitHub Copilot.<br><br>Warp is a Rust-based terminal, reimagined from the ground up to help both individuals and teams be more productive in the command-line.<br><br>Terminal commands are typically difficult to remember, find and construct. Users often have to leave the terminal and search the web for answers and even then the results might not give them the right command to execute. Warp uses Codex to allow users to run a natural language command to search directly from within the terminal and get a result they can immediately use.<br><br>“Codex allows Warp to make the terminal more accessible and powerful. Developers search for entire commands using natural language rather than trying to remember them or assemble them piecemeal. Codex-powered command search has become one of our game changing features.”<br><br>—Zach Lloyd, Founder, Warp<br><br>Machinet helps professional Java developers write quality code by using Codex to generate intelligent unit test templates.<br><br>Machinet was able to accelerate their development several-fold by switching from building their own machine learning systems to using Codex. The flexibility of Codex allows for the ability to easily add new features and capabilities saving their users time and helping them be more productive.<br><br>“Codex is an amazing tool in our arsenal. Not only does it allow us to generate more meaningful code, but it has also helped us find a new design of product architecture and got us out of a local maximum.”<br><br>—Vladislav Yanchenko, Founder, Machinet&quot;&quot;&quot;<br></code></pre></td></tr></table></figure><p>Prompt 有点长，我解释下，它是让 AI 将文章里的重点内容进行抽离，并将其根据特定格式进行输出。要求将文章里提到的公司、人名、主题都按照 comma separated list（按逗号空格分开）的方式罗列出来。</p><p>最后的 output 是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs other">Company names: OpenAI, Microsoft, GitHub, Pygma, Replit, Warp, Machinet<br>People names: Emile Paffard-Wray, Amjad Masad, Zach Lloyd, Vladislav Yanchenko<br>Specific topics: GPT-3, OpenAI API, Azure OpenAI Service, GitHub Copilot, Pygma, Replit, Warp, Machinet<br>General themes: Natural language-to-code, Productivity, Problem solving, Creativity, Learning<br></code></pre></td></tr></table></figure><blockquote><p><strong>技巧 6：通过格式词阐述需要输出的格式</strong></p></blockquote><p>上述的案例，就是用到了这个技巧。这个技巧是技巧 2 的变种，比较常用于生成文本场景。其实在场景 7 中，你也可以用到这个技巧。</p><p>假设你想让 AI 总结一篇非常非常长的文章，并且按照特定格式给你总结，那你可以在文章前面明确输出的格式（为了不占用太多显示空间，我省略了正文内容，你可以在 OpenAI 的 Playground 看到 <a href="https://platform.openai.com/playground/p/3U5Wx7RTIdNNC9Fg8fc44omi">完整案例</a>）。它的意思其实是让 ChatGPT 按 Topic 总结，每个 Topic 里按照无序列表（就是里面那个 -）将每个 Topic 的主要观点罗列出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs other">Summarize the main points of the following speech<br>Use the following format:<br>Topic 1: &lt;topic_name_1&gt;<br>- &lt;point_1&gt;<br>..<br>Topic 2: &lt;topic_name_2&gt;<br>- &lt;point_1&gt;<br>..<br>Topic 10: ..<br><br>Text: &quot;&quot;&quot;<br>Thank you so much, Fred, for that lovely introduction. And thanks to the Atlantic Council for hosting me today.<br><br>The course of the global economy over the past two years has been shaped by COVID-19 and our efforts to fight the pandemic. It’s now evident, though, that the war between Russia and Ukraine has redrawn the contours of the world economic outlook. Vladimir Putin’s unprovoked attack on Ukraine and its people is taking a devastating human toll, with lives tragically lost, families internally displaced or becoming refugees, and communities and cities destroyed.<br>...<br><br>&quot;&quot;&quot;<br></code></pre></td></tr></table></figure><p>Output 是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs other">Topic 1: The war in Ukraine<br>- The war is taking a human toll with lives lost, families displaced, and communities destroyed<br>- The Biden administration is committed to holding Russia accountable<br>- The war has violated international law and is a challenge to the international order<br><br>Topic 2: The global economy<br>- The war is having negative impacts on the global economy, including higher commodity prices and inflation<br>- The IMF and World Bank will be focused on helping developing countries weather the impacts of the war<br>- The ultimate outcome for the global economy depends on the path of the war<br></code></pre></td></tr></table></figure><p>关于这个场景和技巧，我想再解释一下为什么潜力很大。根据我使用各种 Summary 或者信息提取的产品，我发现，AI 并不知道什么是重点，所以在总结的过程中，会丢失很多内容。如何引导 AI 进行总结，就变得非常重要，且具有一定的可玩性。</p><hr><p>感谢 <a href="https://github.com/AlexZhangji">AlexZhangji</a> 的分享，TA 提到一个使用此技巧的场景：</p><p>使用此技巧可以使输出更结构化。比如针对一篇文章进行问答，你不仅想要得到一个答案，也希望 ChatGPT 的答案符合特定的格式，方便你下一步进行自动化。</p><p>比如问 “这里的债券 duration 是多少？” , 正常 GPT 模型的答案可能是 “债券 duration 是 4 年” 或 “duration 4 年”。 ChatGPT 的回答不稳定，且不方便继续处理。</p><p>解法： 我们可以通过这个技巧，让模型理解我们预期的格式。并在此基础上，为了方便自动化，让模型输出特定的结构化答案 (比如 JSON&#x2F;Markdown 等)。 也可以方便集成更多的额外要求，比如增加一个”confidence level”, 并通过 prompt 的形式指定这些数值的格式与甚至区间。</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs other">&#123;context&#125;<br>Question: What is bond duration mentioned here.<br>Answer template (Valid JSON format):<br>&#123;&#123;<br>&quot;duration&quot;: $duration_numeric_value_in_year,<br>&quot;confidence_level&quot;: $answer_confidence_level_high_moderate_or_low,<br>&#125;&#125;<br>Answer:<br></code></pre></td></tr></table></figure><p>在吴恩达的 <a href="https://www.deeplearning.ai/short-courses/chatgpt-prompt-engineering-for-developers/">ChatGPT Prompt Engineering</a> 中，有提到一个这个技巧的高级用法，在让 AI 按照特定格式输出内容的同时，还让 AI 根据内容是否满足特定条件，来判断应该输出什么结果，下面课程中的案例的 prompt（注意这个是 python 代码，有一些转义字符，可以不用管）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">You will be provided <span class="hljs-keyword">with</span> text delimited by triple quotes.<br>If it contains a sequence of instructions, \<br>re-write those instructions <span class="hljs-keyword">in</span> the following <span class="hljs-built_in">format</span>:<br><br>Step <span class="hljs-number">1</span> - ...<br>Step <span class="hljs-number">2</span> - …<br>…<br>Step N - …<br><br>If the text does <span class="hljs-keyword">not</span> contain a sequence of instructions, \<br>then simply write \<span class="hljs-string">&quot;No steps provided.\&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">\&quot;\&quot;\&quot;&#123;text&#125;\&quot;\&quot;\&quot;</span><br></code></pre></td></tr></table></figure><p>简单解释下，这个 prompt 分成两步：</p><p>让 AI 将输入的 text 转为步骤（就是 prompt 里的 Step 1、2）</p><p>然后还增加了一个判断，如果输入的 text 里没有 step 的内容，那么就输出 No Step</p><p>假如输入的 text 是一个泡茶的步骤介绍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs other">Making a cup of tea is easy! First, you need to get some \<br>water boiling. While that&#x27;s happening, \<br>grab a cup and put a tea bag in it. Once the water is \<br>hot enough, just pour it over the tea bag. \<br>Let it sit for a bit so the tea can steep. After a \<br>few minutes, take out the tea bag. If you \<br>like, you can add some sugar or milk to taste. \<br>And that&#x27;s it! You&#x27;ve got yourself a delicious \<br>cup of tea to enjoy.<br></code></pre></td></tr></table></figure><p>那么 AI 输出的内容是这样的（因为内容中包含了步骤式的内容）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs other">Step 1 - Get some water boiling.<br>Step 2 - Grab a cup and put a tea bag in it.<br>Step 3 - Once the water is hot enough, pour it over the tea bag.<br>Step 4 - Let it sit for a bit so the tea can steep.<br>Step 5 - After a few minutes, take out the tea bag.<br>Step 6 - Add some sugar or milk to taste.<br>Step 7 - Enjoy your delicious cup of tea!<br></code></pre></td></tr></table></figure><p>但如果我们输入的是这样的 text：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs other">The sun is shining brightly today, and the birds are \<br>singing. It&#x27;s a beautiful day to go for a \<br>walk in the park. The flowers are blooming, and the \<br>trees are swaying gently in the breeze. People \<br>are out and about, enjoying the lovely weather. \<br>Some are having picnics, while others are playing \<br>games or simply relaxing on the grass. It&#x27;s a \<br>perfect day to spend time outdoors and appreciate the \<br>beauty of nature.<br></code></pre></td></tr></table></figure><p>从内容上看，这段话，没有任何步骤式的内容，所以 AI 的输出是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">No steps provided.<br></code></pre></td></tr></table></figure><h2 id="🚀-高级篇"><a href="#🚀-高级篇" class="headerlink" title="🚀 高级篇"></a>🚀 高级篇</h2><p>高级篇内容相对比较难，如果你对 AI 及 PE 还不是很了解建议先完成基础篇的阅读。</p><h4 id="📄️-ChatGPT-Prompt-Framework"><a href="#📄️-ChatGPT-Prompt-Framework" class="headerlink" title="📄️ ChatGPT Prompt Framework"></a>📄️ ChatGPT Prompt Framework</h4><p>看完基础篇的各种场景介绍后，你应该对 Prompt 有较深的理解。</p><p>之前的章节我们讲的都是所谓的「术」，更多地集中讲如何用，但讲「道」的部分不多。高级篇除了会讲更高级的运用外，还会讲更多「道」的部分。</p><p>高级篇的开篇，我们来讲一下构成 prompt 的框架。</p><blockquote><p><strong>Basic Prompt Framework</strong></p></blockquote><p>查阅了非常多关于 ChatGPT prompt 的框架资料，我目前觉得写得最清晰的是 <a href="https://github.com/dair-ai/Prompt-Engineering-Guide/blob/main/guides/prompts-intro.md">Elavis Saravia总结的框架</a>，他认为一个 prompt 里需包含以下几个元素：</p><ul><li><strong>Instruction（必须）：</strong> 指令，即你希望模型执行的具体任务。</li><li><strong>Context（选填）：</strong> 背景信息，或者说是上下文信息，这可以引导模型做出更好的反应。</li><li><strong>Input Data（选填）：</strong> 输入数据，告知模型需要处理的数据。</li><li><strong>Output Indicator（选填）：</strong> 输出指示器，告知模型我们要输出的类型或格式。</li></ul><p>只要你按照这个框架写 prompt ，模型返回的结果都不会差。</p><p>当然，你在写 prompt 的时候，并不一定要包含所有4个元素，而是可以根据自己的需求排列组合。比如拿前面的几个场景作为例子：</p><ul><li>推理：Instruction + Context + Input Data</li><li>信息提取：Instruction + Context + Input Data + Output Indicator</li></ul><blockquote><p><strong>CRISPE Prompt Framework</strong></p></blockquote><p>另一个我觉得很不错的 Framework 是 <a href="https://github.com/mattnigh/ChatGPT3-Free-Prompt-List">Matt Nigh的 CRISPE Framework</a>，这个 framework 更加复杂，但完备性会比较高，比较适合用于编写 prompt 模板。CRISPE 分别代表以下含义：</p><ul><li><strong>CR：</strong> Capacity and Role（能力与角色）。你希望 ChatGPT 扮演怎样的角色。</li><li><strong>I：</strong> Insight（洞察力），背景信息和上下文（坦率说来我觉得用 Context 更好）。</li><li><strong>S：</strong> Statement（指令），你希望 ChatGPT 做什么。</li><li><strong>P：</strong> Personality（个性），你希望 ChatGPT 以什么风格或方式回答你。</li><li><strong>E：</strong> Experiment（尝试），要求 ChatGPT 为你提供多个答案。</li></ul><p>以下是这几个参数的例子：</p><table><thead><tr><th><strong>Step</strong></th><th><strong>Example</strong></th></tr></thead><tbody><tr><td>Capacity and Role</td><td>Act as an expert on software development on the topic of machine learning frameworks, and an expert blog writer. 把你想象成机器学习框架主题的软件开发专家，以及专业博客作者。</td></tr><tr><td>Insight</td><td>The audience for this blog is technical professionals who are interested in learning about the latest advancements in machine learning. 这个博客的读者主要是有兴趣了解机器学习最新进展技术的专业人士。</td></tr><tr><td>Statement</td><td>Provide a comprehensive overview of the most popular machine learning frameworks, including their strengths and weaknesses. Include real-life examples and case studies to illustrate how these frameworks have been successfully used in various industries. 提供最流行的机器学习框架的全面概述，包括它们的优点和缺点。包括现实生活中的例子，和研究案例，以说明这些框架如何在各个行业中成功地被使用。</td></tr><tr><td>Personality</td><td>When responding, use a mix of the writing styles of Andrej Karpathy, Francois Chollet, Jeremy Howard, and Yann LeCun. 在回应时，混合使用 Andrej Karpathy、Francois Chollet、Jeremy Howard 和 Yann LeCun 的写作风格。</td></tr><tr><td>Experiment</td><td>Give me multiple different examples. 给我多个不同的例子。</td></tr></tbody></table><p>将所有的元素都组合在一起，就变成了这样的 prompt，对比基础 prompt 生成的结果会非常不一样，各位可以在AI之家试用。</p><h4 id="📄️-Zero-Shot-Prompts"><a href="#📄️-Zero-Shot-Prompts" class="headerlink" title="📄️ Zero-Shot Prompts"></a>📄️ Zero-Shot Prompts</h4><p>在基础篇里的推理场景，我提到了 Zero-Shot Prompting 的技术，本章会详细介绍它是什么，以及使用它的技巧。</p><p>Zero-Shot Prompting 是一种自然语言处理技术，可以让计算机模型根据提示或指令进行任务处理。各位常用的 ChatGPT 就用到这个技术。</p><p>传统的自然语言处理技术通常需要在大量标注数据上进行有监督的训练，以便模型可以对特定任务或领域进行准确的预测或生成输出。相比之下，Zero-Shot Prompting 的方法更为灵活和通用，因为它不需要针对每个新任务或领域都进行专门的训练。相反，它通过使用预先训练的语言模型和一些示例或提示，来帮助模型进行推理和生成输出。</p><p>举个例子，我们可以给 ChatGPT 一个简短的 prompt，比如 <code>描述某部电影的故事情节</code>，它就可以生成一个关于该情节的摘要，而不需要进行电影相关的专门训练。</p><p>但这个技术并不是没有缺点的：</p><ol><li>Zero-Shot Prompting 技术依赖于预训练的语言模型，这些模型可能会受到训练数据集的限制和偏见。比如在使用 ChatGPT 的时候，它常常会在一些投资领域，使用男性的「他」，而不是女性的「她」。那是因为训练 ChatGPT 的数据里，提到金融投资领域的内容，多为男性。</li><li>尽管 Zero-Shot Prompting 技术不需要为每个任务训练单独的模型，但为了获得最佳性能，它需要大量的样本数据进行微调。像 ChatGPT 就是一个例子，它的样本数量是过千亿。</li><li>由于 Zero-Shot Prompting 技术的灵活性和通用性，它的输出有时可能不够准确，或不符合预期。这可能需要对模型进行进一步的微调或添加更多的提示文本来纠正。</li></ol><blockquote><p><strong>技巧 7：Zero-Shot Chain of Thought</strong></p></blockquote><p>基于上述的第三点缺点，研究人员就找到了一个叫 Chain of Thought 的技巧。</p><p>这个技巧使用起来非常简单，只需要在问题的结尾里放一句 <code>Let‘s think step by step</code> （让我们一步步地思考），模型输出的答案会更加准确。</p><p>这个技巧来自于 Kojima 等人 2022 年的论文 <a href="https://arxiv.org/abs/2205.11916">Large Language Models are Zero-Shot Reasoners</a>。在论文里提到，当我们向模型提一个逻辑推理问题时，模型返回了一个错误的答案，但如果我们在问题最后加入 <code>Let‘s think step by step</code> 这句话之后，模型就生成了正确的答案：</p><p>​<img src="https://img.hello-yzg.cn/ChatGPT+%23+Hello+ChatGPT-005.png" style="zoom: 150%;" /></p><center style="color:#C0C0C0">图5</center><hr><p>论文里有讲到原因，感兴趣的朋友可以去看看，我简单解释下为什么（🆘 如果你有更好的解释，不妨反馈给我）：</p><ol><li>首先各位要清楚像 ChatGPT 这类产品，它是一个统计语言模型，本质上是基于过去看到过的所有数据，用统计学意义上的预测结果进行下一步的输出（这也就是为什么你在使用 ChatGPT 的时候，它的答案是一个字一个字地吐出来，而不是直接给你的原因，因为答案是一个字一个字算出来的）。</li><li>当它拿到的数据里有逻辑，它就会通过统计学的方法将这些逻辑找出来，并将这些逻辑呈现给你，让你感觉到它的回答很有逻辑。</li><li>在计算的过程中，模型会进行很多假设运算（不过暂时不知道它是怎么算的）。比如解决某个问题是从 A 到 B 再到 C，中间有很多假设。</li><li>它第一次算出来的答案错误的原因，只是因为它在中间跳过了一些步骤（B）。而让模型一步步地思考，则有助于其按照完整的逻辑链（A &gt; B &gt; C）去运算，而不会跳过某些假设，最后算出正确的答案。</li></ol><p>按照论文里的解释，零样本思维链涉及两个补全结果，左侧气泡表示基于提示输出的第一次的结果，右侧气泡表示其收到了第一次结果后，将最开始的提示一起拿去运算，最后得出了正确的答案：</p><p>​<img src="https://img.hello-yzg.cn/ChatGPT+%23+Hello+ChatGPT-006.png" style="zoom: 150%;" /></p><center style="color:#C0C0C0">图6</center><hr><p>这个技巧，除了用于解决复杂问题外，还适合生成一些连贯主题的内容，比如写长篇文章、电影剧本等。</p><p>但需要注意其缺点，连贯不代表，它就一定不会算错，如果其中某一步骤算错了，错误会因为逻辑链，逐步将错误积累，导致生成的文本可能出现与预期不符的内容。</p><p>根据 <a href="https://arxiv.org/pdf/2201.11903.pdf">Wei 等人在2022 年的论文</a> 表明，它仅在大于等于 100B 参数的模型中使用才会有效。如果你使用的是小样本模型，这个方法不会生效。</p><hr><p>另外，根据 <a href="https://sites.google.com/view/automatic-prompt-engineer">Yongchao Zhou 等人的最新论文</a>，更好的 prompt 是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Let&#x27;s work this out in a step by step way to be sure we have the right answer.<br></code></pre></td></tr></table></figure><p>在吴恩达的 <a href="https://www.deeplearning.ai/short-courses/chatgpt-prompt-engineering-for-developers/">ChatGPT Prompt Engineering</a> 中，有提到一个这个技巧的另一种用法，不仅仅只是让 AI 按步骤行事，还会告知 AI 每一步要做什么。比如这个案例（注意这个是 python 代码）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">prompt_2 = f&quot;&quot;&quot;<br>Your task is to perform the following actions:<br>1 - Summarize the following text delimited by<br>  &lt;&gt; with 1 sentence.<br>2 - Translate the summary into French.<br>3 - List each name in the French summary.<br>4 - Output a json object that contains the<br>  following keys: french_summary, num_names.<br><br>Use the following format:<br>Text: &lt;text to summarize&gt;<br>Summary: &lt;summary&gt;<br>Translation: &lt;summary translation&gt;<br>Names: &lt;list of names in Italian summary&gt;<br>Output JSON: &lt;json with summary and num_names&gt;<br><br>Text: &lt;&#123;text&#125;&gt;<br>&quot;&quot;&quot;<br></code></pre></td></tr></table></figure><p>简单解释下这个代码：</p><ol><li>开头是让 AI 按照 1 ～ 4 步运行</li><li>然后再让 AI 根据特定格式输出内容</li></ol><p>最后 AI 的输出是这样的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">Summary: Jack and Jill go on a quest to fetch water, but misfortune strikes and they tumble down the hill, returning home slightly battered but with their adventurous spirits undimmed.<br>Translation: Jack et Jill partent en quête d&#x27;eau, mais la malchance frappe et ils dégringolent la colline, rentrant chez eux légèrement meurtris mais avec leurs esprits aventureux intacts.<br>Names: Jack, Jill<br>Output JSON: &#123;&quot;french_summary&quot;: &quot;Jack et Jill partent en quête d&#x27;eau, mais la malchance frappe et ils dégringolent la colline, rentrant chez eux légèrement meurtris mais avec leurs esprits aventureux intacts.&quot;, &quot;num_names&quot;: 2&#125;<br></code></pre></td></tr></table></figure><p>上述的案例只是将任务拆解，能让 AI 生成的结果更加符合要求，这个方法同样能提升 AI 的回答准确性，比如这个案例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs text">Determine if the student&#x27;s solution is correct or not.<br><br>Question:<br>I&#x27;m building a solar power installation and I need help working out the financials.<br><br>Land costs $100 / square foot<br><br>I can buy solar panels for $250 / square foot<br><br>I negotiated a contract for maintenance that will cost <br>me a flat $100k per year, and an additional $10 / square foot<br>What is the total cost for the first year of operations<br>as a function of the number of square feet.<br><br>Student&#x27;s Solution:<br>Let x be the size of the installation in square feet.<br>Costs:<br><br>Land cost: 100x<br><br>Solar panel cost: 250x<br><br>Maintenance cost: 100,000 + 100x<br>Total cost: 100x + 250x + 100,000 + 100x = 450x + 100,000<br></code></pre></td></tr></table></figure><p>AI 的回答是「The student’s solution is correct」。但其实学生的答案是错误的，应该 360x + 100,000，我们将 prompt 调整成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python">prompt = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">Your task is to determine if the student&#x27;s solution </span><br><span class="hljs-string">is correct or not.</span><br><span class="hljs-string">To solve the problem do the following:</span><br><span class="hljs-string">- First, work out your own solution to the problem.</span><br><span class="hljs-string">- Then compare your solution to the student&#x27;s solution </span><br><span class="hljs-string">and evaluate if the student&#x27;s solution is correct or not.</span><br><span class="hljs-string">Don&#x27;t decide if the student&#x27;s solution is correct until</span><br><span class="hljs-string">you have done the problem yourself.</span><br><span class="hljs-string">Use the following format:</span><br><span class="hljs-string">Question:</span><br><span class="hljs-string">###</span><br><span class="hljs-string">question here</span><br><span class="hljs-string">###</span><br><span class="hljs-string">Student&#x27;s solution:</span><br><span class="hljs-string">###</span><br><span class="hljs-string">student&#x27;s solution here</span><br><span class="hljs-string">###</span><br><span class="hljs-string">Actual solution:</span><br><span class="hljs-string">###</span><br><span class="hljs-string">steps to work out the solution and your solution here</span><br><span class="hljs-string">###</span><br><span class="hljs-string">Is the student&#x27;s solution the same as actual solution </span><br><span class="hljs-string">just calculated:</span><br><span class="hljs-string">###</span><br><span class="hljs-string">yes or no</span><br><span class="hljs-string">###</span><br><span class="hljs-string">Student grade:</span><br><span class="hljs-string">###</span><br><span class="hljs-string">correct or incorrect</span><br><span class="hljs-string">###</span><br><span class="hljs-string">Question:</span><br><span class="hljs-string">###</span><br><span class="hljs-string">I&#x27;m building a solar power installation and I need help </span><br><span class="hljs-string">working out the financials.</span><br><span class="hljs-string">- Land costs $100 / square foot</span><br><span class="hljs-string">- I can buy solar panels for $250 / square foot</span><br><span class="hljs-string">- I negotiated a contract for maintenance that will cost </span><br><span class="hljs-string">  me a flat $100k per year, and an additional $10 / square </span><br><span class="hljs-string">  foot</span><br><span class="hljs-string">  What is the total cost for the first year of operations </span><br><span class="hljs-string">  as a function of the number of square feet.</span><br><span class="hljs-string">###</span><br><span class="hljs-string">Student&#x27;s solution:</span><br><span class="hljs-string">###</span><br><span class="hljs-string">Let x be the size of the installation in square feet.</span><br><span class="hljs-string">Costs:</span><br><span class="hljs-string">1. Land cost: 100x</span><br><span class="hljs-string">2. Solar panel cost: 250x</span><br><span class="hljs-string">3. Maintenance cost: 100,000 + 100x</span><br><span class="hljs-string">   Total cost: 100x + 250x + 100,000 + 100x = 450x + 100,000</span><br><span class="hljs-string">###</span><br><span class="hljs-string">Actual solution:</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>本质上，也是将任务分拆成多步，这次 AI 输出的结果是这样的（结果就是正确的了）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">Let x be the size of the installation in square feet.<br><br>Costs:<br><br>1. Land cost: 100x<br>2. Solar panel cost: 250x<br>3. Maintenance cost: 100,000 + 10x<br><br>Total cost: 100x + 250x + 100,000 + 10x = 360x + 100,000<br><br>Is the student&#x27;s solution the same as actual solution just calculated:<br>No<br><br>Student grade:<br>Incorrect<br></code></pre></td></tr></table></figure><p>下一章我们会结合 Few-Shot Chain of Thought 来详细讲讲逻辑链的限制。</p><h4 id="📄️-Few-Shot-Prompting"><a href="#📄️-Few-Shot-Prompting" class="headerlink" title="📄️ Few-Shot Prompting"></a>📄️ Few-Shot Prompting</h4><p>同样在推理场景，我提到了 Few-Shot Prompting 的技术，本章介绍下它的优缺点和技巧。</p><p>我们在技巧2 中，提到我们可以给模型一些示例，从而让模型返回更符合我们需求的答案。这个技巧其实使用了一个叫 Few-Shot 的方法。</p><p>这个方法最早是 <a href="https://arxiv.org/pdf/2005.14165.pdf">Brown 等人在 2020 年发现的</a>，论文里有一个这样的例子，非常有意思，通过这个例子你应该更能体会，像 ChatGPT 这类统计语言模型，其实并不懂意思，只是懂概率 😁</p><p>Brown 输入的内容是这样的（whatpu 和 farduddle 其实根本不存在）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs other">A &quot;whatpu&quot; is a small, furry animal native to Tanzania. An example of a sentence that uses<br>the word whatpu is:<br>We were traveling in Africa and we saw these very cute whatpus.<br>To do a &quot;farduddle&quot; means to jump up and down really fast. An example of a sentence that uses<br>the word farduddle is:<br></code></pre></td></tr></table></figure><p>Output 是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">When we won the game, we all started to farduddle in celebration.<br></code></pre></td></tr></table></figure><p>不过这并不代表，Few-Shot 就没有缺陷，我们试试下面这个例子：</p><p>Prompt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs other">The odd numbers in this group add up to an even number: 4, 8, 9, 15, 12, 2, 1.<br>A: The answer is False.<br><br>The odd numbers in this group add up to an even number: 17,  10, 19, 4, 8, 12, 24.<br>A: The answer is True.<br><br>The odd numbers in this group add up to an even number: 16,  11, 14, 4, 8, 13, 24.<br>A: The answer is True.<br><br>The odd numbers in this group add up to an even number: 17,  9, 10, 12, 13, 4, 2.<br>A: The answer is False.<br><br>The odd numbers in this group add up to an even number: 15, 32, 5, 13, 82, 7, 1. <br>A:<br></code></pre></td></tr></table></figure><p>Output 是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">The answer is True.<br></code></pre></td></tr></table></figure><p>输出的答案其实是错误的，实际上的答案应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Adding all the odd numbers (15, 5, 13, 7, 1) gives 41. The answer is False.<br></code></pre></td></tr></table></figure><p>那我们有没有什么方法解决？</p><blockquote><p><strong>技巧 8：Few-Shot Chain of Thought</strong></p></blockquote><p>要解决这个缺陷，就要使用到新的技巧，Few-Shot Chain of Thought。</p><p>根据 <a href="https://arxiv.org/pdf/2201.11903.pdf">Wei 他们团队在2022 年的研究 </a>表明：</p><blockquote><p>通过向大语言模型展示一些少量的样例，并在样例中解释推理过程，大语言模型在回答提示时也会显示推理过程。这种推理的解释往往会引导出更准确的结果。</p></blockquote><p>下面是论文里的案例，使用方法很简单，在技巧2 的基础上，再将逻辑过程告知给模型即可。从下面这个案例里，你可以看到加入解释后，输出的结果就正确了。</p><p>​<img src="https://img.hello-yzg.cn/ChatGPT+%23+Hello+ChatGPT-007.png" style="zoom: 150%;" /></p><center style="color:#C0C0C0">图7</center><hr><p>那本章开头提的例子就应该是这样的（注：本例子同样来自 Wei 团队论文）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs other">The odd numbers in this group add up to an even number: 4, 8, 9, 15, 12, 2, 1.<br>A: Adding all the odd numbers (9, 15, 1) gives 25. The answer is False.<br><br>The odd numbers in this group add up to an even number: 17,  10, 19, 4, 8, 12, 24.<br>A: Adding all the odd numbers (17, 19) gives 36. The answer is True.<br><br>The odd numbers in this group add up to an even number: 16,  11, 14, 4, 8, 13, 24.<br>A: Adding all the odd numbers (11, 13) gives 24. The answer is True.<br><br>The odd numbers in this group add up to an even number: 17,  9, 10, 12, 13, 4, 2.<br>A: Adding all the odd numbers (17, 9, 13) gives 39. The answer is False.<br><br>The odd numbers in this group add up to an even number: 15, 32, 5, 13, 82, 7, 1. <br>A:<br></code></pre></td></tr></table></figure><p>聊完技巧，我们再结合前面的 Zero-Shot Chain of Thought，来聊聊 Chain of Thought 的关键知识。根据 <a href="https://arxiv.org/abs/2202.12837">Sewon Min 等人在2022 年的研究</a> 表明，思维链有以下特点：</p><ol><li>“the label space and the distribution of the input text specified by the demonstrations are both key (regardless of whether the labels are correct for individual inputs)” 标签空间和输入文本的分布都是关键因素（无论这些标签是否正确）。</li><li>the format you use also plays a key role in performance, even if you just use random labels, this is much better than no labels at all. 即使只是使用随机标签，使用适当的格式也能提高性能。</li></ol><p>理解起来有点难，我找一个 prompt 案例给大家解释（🆘 如果你有更好的解释，不妨反馈给我）。我给 ChatGPT 一些不一定准确的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs other">I loved the new Batman movie!  // Negative<br>This is bad // Positive<br>This is good // Negative<br>What a good show! //<br></code></pre></td></tr></table></figure><p>Output 是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Positive<br></code></pre></td></tr></table></figure><p>在上述的案例里，每一行，我都写了一句话和一个情感词，并用 &#x2F;&#x2F; 分开，但我给这些句子都标记了错误的答案，比如第一句其实应该是 Positive 才对。但：</p><ol><li>即使我给内容打的标签是错误的（比如第一句话，其实应该是 Positive），对于模型来说，它仍然会知道需要输出什么东西。 换句话说，模型知道 &#x2F;&#x2F; 划线后要输出一个衡量该句子表达何种感情的词（Positive or Negative）。这就是前面论文里 #1 提到的，即使我给的标签是错误的，或者换句话说，是否基于事实，并不重要。标签和输入的文本，以及格式才是关键因素。</li><li>只要给了示例，即使随机的标签，对于模型生成结果来说，都是有帮助的。这就是前面论文里 #2 提到的内容。</li></ol><p>最后，需要记住，思维链仅在使用大于等于 100B 参数的模型时，才会生效。</p><p>BTW，如果你想要了解更多相关信息，可以看看斯坦福大学的讲义：<a href="http://web.stanford.edu/class/cs224n/slides/cs224n-2023-lecture11-prompting-rlhf.pdf">Natural Language Processing with Deep Learning</a></p><h4 id="📄️-Self-Consistency"><a href="#📄️-Self-Consistency" class="headerlink" title="📄️ Self-Consistency"></a>📄️ Self-Consistency</h4><p>Self-Consistency 自洽是对 Chain of Thought 的一个补充，它能让模型生成多个思维链，然后取最多数答案的作为最终结果。</p><p>按照 <a href="https://arxiv.org/pdf/2203.11171.pdf">Xuezhi Wang 等人在2022 年发表的论文</a> 表明。当我们只用一个逻辑链进行优化时，模型依然有可能会算错，所以 XueZhi Wang 等人提出了一种新的方法，让模型进行多次运算，然后选取最多的答案作为最终结果：</p><p>​<img src="https://img.hello-yzg.cn/ChatGPT+%23+Hello+ChatGPT-008.png" style="zoom: 150%;" /></p><center style="color:#C0C0C0">图8</center><hr><p>就我目前使用下来，在 ChatGPT 上，其自洽性非常高，暂时没有遇到过出现多种答案的情况。查阅多份资料，我发现这个自洽性可能更多的用于评估模型的优劣，好的模型一般自洽性会比较高。</p><p><strong>在此案例中，考虑如下多步推理问题：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">Consider a multi-step reasoning problem like the following:<br><br>Question: If a store has 10 apples and 8 oranges, and it sells 6 apples and 4 oranges, how many fruits are left in the store?<br><br>Instead of directly answering the question, the chain-of-thought prompting would require the language model to produce a series of short sentences that mimic a human&#x27;s reasoning process:<br><br>The store has 10 apples.<br>The store has 8 oranges.<br>6 apples are sold.<br>4 oranges are sold.<br>There are 10 - 6 = 4 apples left.<br>There are 8 - 4 = 4 oranges left.<br>The store now has 4 apples + 4 oranges = 8 fruits.<br></code></pre></td></tr></table></figure><p>Using self-consistency, the language model generates multiple reasoning paths:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">Reasoning Path A:<br><br>The store has 10 apples.<br>The store has 8 oranges.<br>6 apples are sold.<br>4 oranges are sold.<br>There are 10 - 6 = 4 apples left.<br>There are 8 - 4 = 4 oranges left.<br>The store now has 4 apples + 4 oranges = 8 fruits.<br>Reasoning Path B:<br><br>The store initially has 10 apples and 8 oranges.<br>It sells 6 apples, so there are 10 - 6 = 4 apples left.<br>It sells 4 oranges, so there are 8 - 4 = 4 oranges left.<br>The store now has 4 apples + 4 oranges = 8 fruits.<br></code></pre></td></tr></table></figure><p>翻译过来则为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">问题：如果一家商店有 10 个苹果和 8 个橙子，此时店里卖出了 6 个苹果和 4 个橙子，那么店里还剩下多少水果？<br><br>思维链提示（chain-of-thought prompting）不是直接回答问题，而是要求语言模型生成一系列模仿人类推理过程的短句：<br><br>商店有 10 个苹果。<br>店里有 8 个橙子。<br>卖了 6 个苹果。<br>卖了 4 个橙子。<br>还剩下 10 - 6 = 4 个苹果。<br>剩下 8 - 4 = 4 个橙子。<br>商店现在有 4 个苹果 + 4 个橙子 = 8 个水果。<br></code></pre></td></tr></table></figure><p>使用 Self-consistency，语言模型生成多个推理路径：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">推理路径A：<br><br>商店有 10 个苹果。<br>店里有 8 个橙子。<br>卖了 6 个苹果。<br>卖了 4 个橙子。<br>还剩下 10 - 6 = 4 个苹果。<br>剩下 8 - 4 = 4 个橙子。<br>商店现在有 4 个苹果 + 4 个橙子 = 8 个水果。<br><br>推理路径 B：<br><br>商店最初有 10 个苹果和 8 个橙子。<br>商店卖了 6 个苹果，所以还剩下 10 - 6 = 4 个苹果。<br>商店卖了 4 个橙子，所以还剩下 8 - 4 = 4 个橙子。<br>商店现在有 4 个苹果 + 4 个橙子 = 8 个水果。<br></code></pre></td></tr></table></figure><p>Self-consistency 从生成的多个推理路径中选择最一致的答案。在这个例子中，推理路径 A 和 B 都得出相同的答案（8 个水果）。可以看到这种做法增加了模型对最终答案正确的信心。</p><h4 id="📄️-PAL-Models"><a href="#📄️-PAL-Models" class="headerlink" title="📄️ PAL Models"></a>📄️ PAL Models</h4><p>PAL Models，全称为 Program-Aided Language Models。需要各位注意，这个方法，真的非常高级，甚至我觉得有点 Hack，而且经过我的多次测试，我觉得以 ChatGPT 目前的能力，已经不再需要使用这个方法。</p><p>但我在很多 PE 的教程里都有看到这个方法，所以我这里就简单介绍一下，这个方法来自于 2022 年 <a href="https://arxiv.org/pdf/2211.10435.pdf">Luyu Gao 等人的研究</a>，根据他们的研究，在 LLM 模型中，即使使用了前面提到的 Chain of Thought 的方法，也未必能拿到答案，论文中使用的 prompt 是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs other">Q: Roger has 5 tennis balls. He buys 2 more cans of<br>tennis balls. Each can has 3 tennis balls. How many<br>tennis balls does he have now?<br>A: Roger started with 5 tennis balls. 2 cans of 3 tennis<br>balls each is 6 tennis balls. 5 + 6 = 11. The answer is 11.<br><br>Q: The bakers at the Beverly Hills Bakery baked 200<br>loaves of bread on Monday morning. They sold 93 loaves<br>in the morning and 39 loaves in the afternoon. A grocery<br>store returned 6 unsold loaves. How many loaves of<br>bread did they have left?<br></code></pre></td></tr></table></figure><p>论文里提到，当年他们的模型的 Output 是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs other">A: The bakers started with 200 loaves. They sold 93 in<br>the morning and 39 in the afternoon. So they sold 93 +<br>39 = 132 loaves. The grocery store returned 6 loaves. So<br>they had 200 - 132 - 6 = 62 loaves left. <br>The answer is 62.<br></code></pre></td></tr></table></figure><p>如果你现在将这个 prompt 输入到最新的 ChatGPT 答案已经是正确的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">A: The bakers baked 200 loaves of bread. They sold 93 + 39 = 132 loaves. After the grocery store returned 6 unsold loaves, the bakery had 200 - 132 + 6 = 74 loaves of bread left. The answer is 74.<br></code></pre></td></tr></table></figure><p>当年 Luyu Gao 的解决方法是在 prompt 里引入代码，并引导模型使用代码来运算和思考，最后答案就是正确的：</p><p>​<img src="https://img.hello-yzg.cn/ChatGPT+%23+Hello+ChatGPT-009.png" style="zoom: 150%;" /></p><center style="color:#C0C0C0">图9</center><hr><h4 id="📄️-OpenAI-Playground-使用方法"><a href="#📄️-OpenAI-Playground-使用方法" class="headerlink" title="📄️ OpenAI Playground 使用方法"></a>📄️ OpenAI Playground 使用方法</h4><p>如果你想要更好地了解 OpenAI 的 API，并且你常常会遇到 ChatGPT 不可用的情况。那我建议你使用 OpenAI 的 Playground。它会比较稳定。</p><p><strong>但需要注意，这个 Playground 会消耗你的免费 Credit。</strong></p><p>​<img src="https://img.hello-yzg.cn/ChatGPT+%23+Hello+ChatGPT-010.png" style="zoom: 150%;" /></p><center style="color:#C0C0C0">图10</center><hr><p>你会在界面的右侧看到以下几个参数：</p><ol><li><p><strong>Mode：</strong> 最近更新了第四种 Chat 模式，一般使用 Complete 就好，当然你可以用其他模式，其他模式能通过 GUI 的方式辅助你撰写 prompt。</p></li><li><p><strong>Model</strong>：</p><p>这里可以切换模型。不同的模型会擅长不同的东西，根据场景选对模型，能让你省很多成本：</p><ol><li>Ada：这是最便宜，但运算速度最快的模型。官方推荐的使用场景是解析文本，简单分类，地址更正等。</li><li>Babbage：这个模型能处理比 Ada 复杂的场景。但稍微贵一些，速度也比较快。适合分类，语义搜索等。</li><li>Curie：这个模型官方解释是「和 Davinci 一样能力很强，且更便宜的模型」。但实际上，这个模型非常擅长文字类的任务，比如写文章、语言翻译、撰写总结等。</li><li>Davinci：这是 GPT-3 系列模型中能力最强的模型。可以输出更高的质量、更长的回答。每次请求可处理 4000 个 token。适合有复杂意图、因果关系的场景，还有创意生成、搜索、段落总结等。</li></ol></li><li><p><strong>Temperature：</strong> 这个主要是控制模型生成结果的随机性。简而言之，温度越低，结果越确定，但也会越平凡或无趣。如果你想要得到一些出人意料的回答，不妨将这个参数调高一些。但如果你的场景是基于事实的场景，比如数据提取、FAQ 场景，此参数就最好调成 0 。</p></li><li><p><strong>Maximum length：</strong> 设置单次生成内容的最大长度。</p></li><li><p><strong>Stop Sequence：</strong> 该选项设置停止生成文本的特定字符串序列。如果生成文本中包含此序列，则模型将停止生成更多文本。</p></li><li><p><strong>Top P：</strong> 该选项是用于 nucleus 采样的一种技术，它可以控制模型生成文本的概率分布，从而影响模型生成文本的多样性和确定性。如果你想要准确的答案，可以将它设定为较低的值。如果你想要更多样化的回复，可以将其设得高一些。</p></li><li><p><strong>Presence Penalty：</strong> 该选项控制模型生成文本时是否避免使用特定单词或短语，它可以用于生成文本的敏感话题或特定场景。</p></li><li><p><strong>Best of：</strong> 这个选项允许你设置生成多少个文本后，从中选择最优秀的文本作为输出。默认为1，表示只生成一个文本输出。</p></li><li><p><strong>Injection start text:</strong> 这个选项可以让你在输入文本的开头添加自定义文本，从而影响模型的生成结果。</p></li><li><p><strong>Injection restart text:</strong> 这个选项可以让你在中间某个位置添加自定义文本，从而影响模型继续生成的结果。</p></li><li><p><strong>Show probabilities:</strong> 这个选项可以让你查看模型生成每个单词的概率。打开此选项后，你可以看到每个生成的文本单词后面跟着一串数字，表示模型生成该单词的概率大小。</p></li></ol><p>配置好参数后，你就可以在左侧输入 prompt 然后测试 prompt 了。</p><h4 id="📄️-搭建基于知识库内容的机器人"><a href="#📄️-搭建基于知识库内容的机器人" class="headerlink" title="📄️ 搭建基于知识库内容的机器人"></a>📄️ 搭建基于知识库内容的机器人</h4><p>如果你仅想要直接实践，可以看最后一部分实践，以及倒数第二部分限制与注意的地方。</p><p>这个想法，来源于我的个人需求，我连载了将近 100 期 newsletter，积累了很多内容，我希望将这些资料导入给 AI，然后 AI 能拿这些数据回答我的问题，甚至能给我一些写作建议等。</p><p>最早的时候，我尝试过非常笨的方法，就是在提问的时候，将我的 newsletter 文本传给 AI，它的 prompt 大概是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs other">Please summarize the following sentences to make them easier to understand.<br><br>Text: &quot;&quot;&quot;<br>My newsletter<br>&quot;&quot;&quot;<br></code></pre></td></tr></table></figure><p>这个方法能用是能用，但目前 ChatGPT 有个非常大的限制，它限制了最大的 token 数是 4096，大约是 16000 多个字符，注意这个是请求 + 响应，实际请求总数并没那么多。换句话来说，我一次没法导入太多的内容给 ChatGPT（我的一篇 Newsletter 就有将近 5000 字），这个问题就一直卡了我很久，直到我看到了 <a href="https://gpt-index.readthedocs.io/en/latest/">GPT Index</a> 的库，以及 <a href="https://www.lennysnewsletter.com/p/i-built-a-lenny-chatbot-using-gpt">Lennys Newsletter</a> 的例子。</p><p>试了下，非常好用，而且步骤也很简单，即使你不懂编程也能轻易地按照步骤实现这个功能。</p><p>我稍稍优化了下例子的代码，并增加了一些原理介绍。希望大家能喜欢。</p><p>其实我这个需求，在传统的机器人领域已经有现成方法，比如你应该看到不少电商客服产品，就有类似的功能，你说一句话，机器人就会回复你。这种传统的机器人，通常是基于意图去回答人的问题。</p><p>当用户问「忘记密码怎么办？」时，它会去找最接近这个意图「密码」，每个意图里会有很多个样本问题，比如「忘记密码如何找回」「忘记密码怎么办」，然后这些样本问题都会有个答案「点击 A 按钮找回密码」，机器人会匹配最接近样本问题的意图，然后返回答案。</p><p>但这样有个问题，我们需要设置特别多的意图，比如「无法登录」、「忘记密码」、「登录错误」，虽然有可能都在描述一个事情，但我们需要设置三个意图、三组问题和答案。</p><p>虽然传统的机器人有不少限制，但这种传统方式，给了我们一些灵感。</p><p>我们好像可以用这个方法来解决限制 token 的问题，我们仅需要传符合某个意图的文档给 AI，然后 AI 仅用该文档来生成答案：</p><p>​<img src="https://img.hello-yzg.cn/ChatGPT+%23+Hello+ChatGPT-011.png" style="zoom: 150%;" /></p><center style="color:#C0C0C0">图11</center><hr><p>比如还是上面的那个客服机器人的例子，当用户提问「忘记密码怎么办？」时，匹配到了「登录」相关的意图，接着匹配知识库中相同或相近意图的文档，比如「登录异常处理解决方案文档」，最后我们将这份文档传给 GPT-3，它再拿这个文档内容生成答案。</p><p>GPTIndex 这个库简单理解就是做上图左边的那个部分，它的工作原理是这这样的：</p><ol><li>创建知识库或文档索引</li><li>找到最相关的索引</li><li>最后将对应索引的内容给 GPT-3</li></ol><p>虽然这个方法解决了 token 限制的问题，但也有不少限制：</p><ol><li>当用户提一些比较模糊的问题时，匹配有可能错误，导致 GPT-3 拿到了错误的内容，最终生成了非常离谱的答案。</li><li>当用户提问一些没有多少上下文的信息时，机器人有时会生成虚假信息。</li></ol><p>所以如果你想用这个技术做客服机器人，建议你：</p><ol><li>通过一些引导问题来先明确用户的意图，就是类似传统客服机器人那样，搞几个按钮，先让用户点击（比如无法登录）。</li><li>如果相似度太低，建议增加兜底的回答「很抱歉，我无法回答你的问题，你需要转为人工客服吗？」</li></ol><p>为了让大家更方便使用，我将代码放在了 Google Colab，你无需安装任何环境，只需要用浏览器打开这个： <a href="https://colab.research.google.com/drive/1Fr1hxYOG5lss9vbvZlaw-11wM2U6N7cQ">代码文件</a></p><p>BTW 你可以将其复制保存到自己的 Google Drive。</p><h5 id="第一步：导入数据"><a href="#第一步：导入数据" class="headerlink" title="第一步：导入数据"></a>第一步：导入数据</h5><p>导入的方法有两种，第一种是导入在线数据。</p><p>导入 GitHub 数据是个相对简单的方式。如果你是第一次使用，我建议你先用这个方法试试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">git clone https://github.com/thinkingjimmy/Jimmy-Newsletter-Corpus.git<br></code></pre></td></tr></table></figure><p>运行完成后，会导入我写的几份 newsletter。如果你也想像我那样导入数据，只需要修改 clone 后面的链接地址即可。</p><p>第二种方法是导入离线数据。点击左侧的文件夹按钮（如果你没有登录，这一步会让你登录），然后点击下图标识 2 的上传按钮，上传文件即可。如果你要传多个文件，建议你先建一个文件夹，然后将文件都上传到该文件夹内。</p><p>​<img src="https://img.hello-yzg.cn/ChatGPT+%23+Hello+ChatGPT-012.png" style="zoom: 150%;" /></p><center style="color:#C0C0C0">图12</center><hr><h5 id="第二-amp-三步：安装依赖库"><a href="#第二-amp-三步：安装依赖库" class="headerlink" title="第二 &amp; 三步：安装依赖库"></a>第二 &amp; 三步：安装依赖库</h5><p>不过第三步里，你可以尝试改下参数，你可以改：</p><ol><li><strong>num_ouputs ：</strong>这个是设置最大的输出 token 数，越大，回答问题的时候，机器能回答的字就越多。</li><li><strong>Temperature：</strong> 这个主要是控制模型生成结果的随机性。简而言之，温度越低，结果越确定，但也会越平凡或无趣。如果你想要得到一些出人意料的回答，不妨将这个参数调高一些。但如果你的场景是基于事实的场景，比如数据提取、FAQ 场景，此参数就最好调成 0。</li></ol><p>其他参数不去管它就好，问题不大。</p><h5 id="第四步：设置-OpenAI-API-Key"><a href="#第四步：设置-OpenAI-API-Key" class="headerlink" title="第四步：设置 OpenAI API Key"></a>第四步：设置 OpenAI API Key</h5><p>这个需要你登录 OpenAI（注意是 OpenAI 不是 ChatGPT），点击右上角的头像，点击 View API Keys，或者你 <a href="https://platform.openai.com/account/api-keys">点击这个链接 </a>也可以直接访问。然后点击「Create New Secret Key」，然后复制那个 Key 并粘贴到文档里即可。</p><p>​<img src="https://img.hello-yzg.cn/ChatGPT+%23+Hello+ChatGPT-013.png" style="zoom: 150%;" /></p><center style="color:#C0C0C0">图13</center><hr><h5 id="第五步：构建索引"><a href="#第五步：构建索引" class="headerlink" title="第五步：构建索引"></a>第五步：构建索引</h5><p>这一步程序会将第一步导入的数据都跑一遍，并使用 OpenAI 的 embedings API。如果第一步你上传了自己的数据，只需要将 ‘ ‘ 里的 Jimmy-Newsletter-Corpus 修改为你上传的文件夹名称即可。</p><p><strong>注意：</strong></p><ul><li>这一步会耗费你的 OpenAI 的 Credit，1000 个 token 的价格是 $0.02，运行以下代码前需要注意你的账号里是否还有钱。</li><li>如果你用的 OpenAI 账号是个免费账号，你有可能会遇到频率警告，此时可以等一等再运行下方代码（另外你的导入的知识库数据太多，也会触发）。解除这个限制，最好的方式是在你的 OpenAI 账号的 Billing 页面里绑定信用卡。如何绑卡，需要各位自行搜索。</li></ul><h5 id="第六步：提问"><a href="#第六步：提问" class="headerlink" title="第六步：提问"></a>第六步：提问</h5><p>这一步你就可以试试提问了，如果你在第一步导入的是我预设的数据，你可以试试问以下问题：</p><ul><li>Issue 90 主要讲了什么什么内容？</li><li>推荐一本跟 Issue 90 里提到的书类似的书</li></ul><p>如果你导入的是自己的资料，也可以问以下几个类型的问题：</p><ul><li>总结</li><li>提问</li><li>信息提取</li></ul><h2 id="🗒️-技巧篇"><a href="#🗒️-技巧篇" class="headerlink" title="🗒️ 技巧篇"></a>🗒️ 技巧篇</h2><p>这里汇总了所有 prompt 技巧，方便各位查阅。如果你已经看过基础篇和高级篇内容，就仅需要从技巧 9 开始看即可。</p><h4 id="📄️-技巧-1：To-Do-and-Not-To-Do"><a href="#📄️-技巧-1：To-Do-and-Not-To-Do" class="headerlink" title="📄️ 技巧 1：To Do and Not To Do"></a>📄️ 技巧 1：To Do and Not To Do</h4><p>我介绍的技巧其实在各个场景都可以使用，我将其放在某个场景下解释，只是因为我觉得它更有可能在这个场景用到。你也会更容易记住这个用法。并不意味着这个技巧仅能在此场景使用。并且多技巧混用也是个不错的用法。</p><p>在问答场景里，为了让 AI 回答更加准确，一般会在问题里加条件。比如让 AI 推荐一部电影给你 <code>Recommend a movie to me</code> 。但这个 prompt 太空泛了，AI 无法直接回答，接着它会问你想要什么类型的电影，但这样你就需要跟 AI 聊很多轮，效率比较低。</p><p>所以，为了提高效率，一般会在 prompt 里看到类似这样的话（意思是不要询问我对什么感兴趣，或者问我的个人信息）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">DO NOT ASK FOR INTERESTS. DO NOT ASK FOR PERSONAL INFORMATION.<br></code></pre></td></tr></table></figure><p>如果你在 ChatGPT 里这样提问，或者使用 ChatGPT 最新的 API ，它就不会问你问题，而是直接推荐一部电影给你，它的 Output 是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Certainly! If you&#x27;re in the mood for an action-packed movie, you might enjoy &quot;John Wick&quot; (2014), directed by Chad Stahelski and starring Keanu Reeves. The movie follows a retired hitman named John Wick who seeks vengeance against the people who wronged him. It&#x27;s a fast-paced and stylish film with lots of thrilling action sequences and an engaging story. If you&#x27;re looking for something that will keep you on the edge of your seat, &quot;John Wick&quot; is definitely worth a watch!<br></code></pre></td></tr></table></figure><p>但如果你使用的是如 Davinci-003 这样的模型，它的 Output 很可能是这样的，它还会问你的兴趣爱好：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Sure, I can recommend a movie based on your interests. What kind of movie would you like to watch? Do you prefer action, comedy, romance, or something else?<br></code></pre></td></tr></table></figure><p>所以 OpenAI 的 API <a href="https://help.openai.com/en/articles/6654000-best-practices-for-prompt-engineering-with-openai-api">最佳实践文档</a> 里，提到了一个这样的最佳实践：</p><blockquote><p><strong>Instead of just saying what not to do, say what to do instead. 与其告知模型不能干什么，不妨告诉模型能干什么。</strong></p></blockquote><p>我自己的实践是，虽然现在最新的模型已经理解什么是 Not Todo ，但如果你想要的是明确的答案，加入更多限定词，告知模型能干什么，回答的效率会更高，且预期会更明确。还是电影推荐这个案例，你可以加入一个限定词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Recommend a movie from the top global trending movies to me.<br></code></pre></td></tr></table></figure><p>当然并不是 Not Todo 就不能用，如果：</p><ul><li>你已经告知模型很明确的点，然后你想缩小范围，那增加一些 Not Todo 会提高不少效率。</li><li>你是在做一些探索，比如你不知道如何做精准限定，你只知道不要什么。那可以先加入 Not Todo ，让 AI 先发散给你答案，当探索完成后，再去优化 prompt。</li></ul><p>以下是一些场景案例，我整理了两个 Less Effective（不太有效的） 和 Better（更好的） prompt，你可以自己尝试下这些案例：</p><table><thead><tr><th>场景</th><th>Less Effective</th><th>Better</th><th>原因</th></tr></thead><tbody><tr><td>推荐雅思必背英文单词</td><td>Please suggest me some essential words for IELTS</td><td>Please suggest me 10 essential words for IELTS</td><td>后者 prompt 会更加明确，前者会给大概 20 个单词。这个仍然有提升的空间，比如增加更多的限定词语，像字母 A 开头的词语。</td></tr><tr><td>推荐香港值得游玩的地方</td><td>Please recommend me some places to visit in Hong Kong. Do not recommend museums.</td><td>Please recommend me some places to visit in Hong Kong including amusement parks.</td><td>后者的推荐会更准确高效一些，但如果你想进行一些探索，那前者也能用。</td></tr></tbody></table><h4 id="📄️-技巧-2：增加示例"><a href="#📄️-技巧-2：增加示例" class="headerlink" title="📄️ 技巧 2：增加示例"></a>📄️ 技巧 2：增加示例</h4><p>直接告知 AI 什么能做，什么不能做外。在某些场景下，我们能比较简单地向 AI 描述出什么能做，什么不能做。但有些场景，有些需求很难通过文字指令传递给 AI，即使描述出来了，AI 也不能很好地理解。</p><p>比如给宠物起英文名，里面会夹杂着一些所谓的名字风格。此时你就可以在 prompt里增加一些例子，我们看看这个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Suggest three names for a horse that is a superhero.<br></code></pre></td></tr></table></figure><p>Output 是这样的，第一个感觉还行，第二个 Captain 有 hero 的感觉，但 Canter 就像是说这匹马跑得很慢，而且三个都比较一般，不够酷。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Thunder Hooves, Captain Canter, Mighty Gallop<br></code></pre></td></tr></table></figure><p>此时你就可以在 prompt 里增加一些案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs other">Suggest three names for an animal that is a superhero.<br><br>Animal: Cat<br>Names: Captain Sharpclaw, Agent Fluffball, The Incredible Feline<br>Animal: Dog<br>Names: Ruff the Protector, Wonder Canine, Sir Barks-a-Lot<br>Animal: Horse<br>Names:<br></code></pre></td></tr></table></figure><p>增加例子后，输出的结果就更酷一些，或者说是我想要的那种风格的名字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Gallop Guardian, Equine Avenger, The Mighty Stallion<br></code></pre></td></tr></table></figure><p>以下是一些场景案例，我整理了两个 Less Effective（不太有效的） 和 Better（更好的） prompt，你可以自己尝试下这些案例：</p><table><thead><tr><th>场景</th><th>Less Effective</th><th>Better</th><th>原因</th></tr></thead><tbody><tr><td>起英文名</td><td>Suggest three English names for a boy.</td><td>Suggest three English names for a boy. Here are some examples: Jimmy、Jason、James</td><td>可以在下方运行这个案例，在不给示例的情况下 AI 会给你什么答案。</td></tr><tr><td>将电影名称转为 emoji</td><td>Convert Star Wars into emoji.</td><td>Convert movie titles into emoji. Back to the Future: 👨👴🚗🕒 Batman: 🤵🦇 Transformers: 🚗🤖 Star Wars:</td><td>可以在下方运行这个案例，在不给示例的情况下 AI 会给你什么答案。</td></tr></tbody></table><h4 id="📄️-技巧-3：使用引导词，引导模型输出特定内容"><a href="#📄️-技巧-3：使用引导词，引导模型输出特定内容" class="headerlink" title="📄️ 技巧 3：使用引导词，引导模型输出特定内容"></a>📄️ 技巧 3：使用引导词，引导模型输出特定内容</h4><p>在代码生成场景里，有一个小技巧，上面提到的案例，其 prompt 还可以继续优化，在 prompt 最后，增加一个代码的引导，告知 AI 我已经将条件描述完了，你可以写代码了。</p><p>Better：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs other">Create a MySQL query for all students in the Computer Science Department:<br>Table departments, columns = [DepartmentId, DepartmentName]<br>Table students, columns = [DepartmentId, StudentId, StudentName]<br>SELECT<br></code></pre></td></tr></table></figure><p>在 prompt 的最后增加 SELECT 可以很好地提示 AI 可以写 SQL 代码了。</p><p>同样的道理，如果你想让 AI 写 Python 代码，那 import 会是比较好的提示。但需要注意，这个只是告知 AI 可以写代码了，并不能告知 AI 写何种代码，你仍然需要在 prompt 里增加提示，告知 AI 要生成何种语言的代码。</p><p>在吴恩达的 <a href="https://www.aizj.cc/go.php?https://www.deeplearning.ai/short-courses/chatgpt-prompt-engineering-for-developers/">ChatGPT Prompt Engineering</a> 中，也提到这个技巧，只是在课程中，引导词并不是放在最后，而是在 prompt 里直接说明，让 AI 生成一个 JSON 格式的内容。课程中的例子是这样的（注意这个是 python 代码）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">prompt = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">Generate a list of three made-up book titles along \</span><br><span class="hljs-string">with their authors and genres.</span><br><span class="hljs-string">Provide them in JSON format with the following keys:</span><br><span class="hljs-string">book_id, title, author, genre.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>我简单解释下，其关键是在 prompt 里跟 AI 说明，需要 AI 按照 JSON 格式输出内容。</p><h4 id="📄️-技巧-4：增加-Role（角色）或人物"><a href="#📄️-技巧-4：增加-Role（角色）或人物" class="headerlink" title="📄️ 技巧 4：增加 Role（角色）或人物"></a>📄️ 技巧 4：增加 Role（角色）或人物</h4><p>前面提到的改写例子，我在 prompt 里加了 Role 让其更易于阅读，这个优化方法是 OK 的。也很常用，比如你想将你写的 Email 改得更商务，则只需要加 business 相关的词即可。</p><p>我再介绍一个更有效的技巧，就是在 prompt 里增加一些 role（角色）相关的内容，让 AI 生成的内容更符合你的需求。</p><p>比如还是上面那个 rewrite 的例子，我在例子前加入这样的一段话，我让 AI 假设自己是一个小学老师，并且很擅长将复杂的内容转变成 7、8岁小朋友也能听懂的话，然后再改写这段话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">You are a primary school teacher who can explain complex content to a level that a 7 or 8 year old child can understand. Please rewrite the following sentences to make them easier to understand:<br></code></pre></td></tr></table></figure><p>Output 就变成了下面这样。不管是用词，还是语法，看起来都更容易懂了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">OpenAI is a place where people work on making computers really smart. It&#x27;s like a lab where they do research to make computers do amazing things! They want the computers to be really friendly and helpful to people. They use one of the most powerful computers in the world to do this research. A bunch of really rich and smart people gave money to start this lab. One of them is Elon Musk, but he left in 2018. Another really big company, Microsoft, gave them a lot of money too.<br></code></pre></td></tr></table></figure><p>另外除了增加角色外，还能让 AI 模拟某个人，比如让 AI 以 David Foster Wallace 的风格改写上述那段话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Imagine you are the famous writer David Foster Wallace, please rewrite this sentences.<br></code></pre></td></tr></table></figure><p>Output 是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs other">As David Foster Wallace, I might rewrite these sentences to sound more like this:<br><br>OpenAI is a lab that studies something called artificial intelligence, which is like when computers can do things that normally only humans can do. They have a big computer that&#x27;s one of the most powerful in the world, and they&#x27;re trying to make sure the AI they create is friendly and helpful. The lab was started in 2015 in a city called San Francisco, and a bunch of important people gave them a lot of money to do their research. One of those people was Elon Musk, who stopped working there but still gives them money, and Microsoft also gave them a lot of money recently.<br></code></pre></td></tr></table></figure><p>关于这个技巧的应用，以及如何更好地使用 AI 提升写作能力，建议各位阅读 Nat Eliason 的 <a href="https://blog.nateliason.com/p/chatgpt-writing-coach">Using ChatGPT as a Writing Coach</a>，他使用 ChatGPT 辅助其写作，就用到了上述的技巧。</p><h4 id="📄️-技巧-5：使用特殊符号指令和需要处理的文本分开"><a href="#📄️-技巧-5：使用特殊符号指令和需要处理的文本分开" class="headerlink" title="📄️ 技巧 5：使用特殊符号指令和需要处理的文本分开"></a>📄️ 技巧 5：使用特殊符号指令和需要处理的文本分开</h4><p>不管是信息总结，还是信息提取，你一定会输入大段文字，甚至多段文字，此时有个小技巧。</p><p>可以用“”“将指令和文本分开。根据我的测试，如果你的文本有多段，增加”“”会提升 AI 反馈的准确性（这个技巧来自于 OpenAI 的 API <a href="https://help.openai.com/en/articles/6654000-best-practices-for-prompt-engineering-with-openai-api">最佳实践文档</a>）</p><p>像我们之前写的 prompt 就属于 Less effective prompt。为什么呢？据我的测试，主要还是 AI 不知道什么是指令，什么是待处理的内容，用符号分隔开来会更利于 AI 区分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs other">Please summarize the following sentences to make them easier to understand.<br>OpenAI is an American artificial intelligence (AI) research laboratory consisting of the non-profit OpenAI Incorporated (OpenAI Inc.) and its for-profit subsidiary corporation OpenAI Limited Partnership (OpenAI LP). OpenAI conducts AI research with the declared intention of promoting and developing a friendly AI. OpenAI systems run on the fifth most powerful supercomputer in the world.[5][6][7] The organization was founded in San Francisco in 2015 by Sam Altman, Reid Hoffman, Jessica Livingston, Elon Musk, Ilya Sutskever, Peter Thiel and others,[8][1][9] who collectively pledged US$1 billion. Musk resigned from the board in 2018 but remained a donor. Microsoft provided OpenAI LP with a $1 billion investment in 2019 and a second multi-year investment in January 2023, reported to be $10 billion.[10]<br></code></pre></td></tr></table></figure><p>Better prompt:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs other">Please summarize the following sentences to make them easier to understand.<br><br>Text: &quot;&quot;&quot;<br>OpenAI is an American artificial intelligence (AI) research laboratory consisting of the non-profit OpenAI Incorporated (OpenAI Inc.) and its for-profit subsidiary corporation OpenAI Limited Partnership (OpenAI LP). OpenAI conducts AI research with the declared intention of promoting and developing a friendly AI. OpenAI systems run on the fifth most powerful supercomputer in the world.[5][6][7] The organization was founded in San Francisco in 2015 by Sam Altman, Reid Hoffman, Jessica Livingston, Elon Musk, Ilya Sutskever, Peter Thiel and others,[8][1][9] who collectively pledged US$1 billion. Musk resigned from the board in 2018 but remained a donor. Microsoft provided OpenAI LP with a $1 billion investment in 2019 and a second multi-year investment in January 2023, reported to be $10 billion.[10]<br>&quot;&quot;&quot;<br></code></pre></td></tr></table></figure><p>另外，在吴恩达的 <a href="https://www.deeplearning.ai/short-courses/chatgpt-prompt-engineering-for-developers/">ChatGPT Prompt Engineering</a> 中，还提到，你可以使用其他特殊符号来分割文本和 prompt，比如<code>&lt;&gt;</code>，<code>&lt;tag&gt;&lt;/tag&gt;</code> 等，课程中的案例是这样的（注意这个是 python 代码，需要关注的是 prompt 里的 text）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">text = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">You should express what you want a model to do by \</span><br><span class="hljs-string">providing instructions that are as clear and \</span><br><span class="hljs-string">specific as you can possibly make them. \</span><br><span class="hljs-string">This will guide the model towards the desired output, \</span><br><span class="hljs-string">and reduce the chances of receiving irrelevant \</span><br><span class="hljs-string">or incorrect responses. Don&#x27;t confuse writing a \</span><br><span class="hljs-string">clear prompt with writing a short prompt. \</span><br><span class="hljs-string">In many cases, longer prompts provide more clarity \</span><br><span class="hljs-string">and context for the model, which can lead to \</span><br><span class="hljs-string">more detailed and relevant outputs.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>prompt = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">Summarize the text delimited by triple backticks \</span><br><span class="hljs-string">into a single sentence.</span><br><span class="hljs-string">`<span class="hljs-subst">&#123;text&#125;</span>`</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>如果你是在开发一款允许用户输入内容，并对内容进行总结的 AI 产品，那你就可以使用到这个技巧。</p><h4 id="📄️-技巧-6：通过格式词阐述需要输出的格式"><a href="#📄️-技巧-6：通过格式词阐述需要输出的格式" class="headerlink" title="📄️ 技巧 6：通过格式词阐述需要输出的格式"></a>📄️ 技巧 6：通过格式词阐述需要输出的格式</h4><p>这个技巧是技巧 2 的变种，比较常用于生成文本场景。其实在场景 7 中，你也可以用到这个技巧。</p><p>假设你想让 AI 总结一篇非常非常长的文章，并且按照特定格式给你总结，那你可以在文章前面明确输出的格式（为了不占用太多显示空间，我省略了正文内容，你可以在 OpenAI 的 Playground 看到 <a href="https://platform.openai.com/playground/p/3U5Wx7RTIdNNC9Fg8fc44omi">完整案例</a>）。它的意思其实是让 ChatGPT 按 Topic 总结，每个 Topic 里按照无序列表（就是里面那个 -）将每个 Topic 的主要观点罗列出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs other">Summarize the main points of the following speech<br>Use the following format:<br>Topic 1: &lt;topic_name_1&gt;<br>- &lt;point_1&gt;<br>..<br>Topic 2: &lt;topic_name_2&gt;<br>- &lt;point_1&gt;<br>..<br>Topic 10: ..<br><br>Text: &quot;&quot;&quot;<br>Thank you so much, Fred, for that lovely introduction. And thanks to the Atlantic Council for hosting me today.<br><br>The course of the global economy over the past two years has been shaped by COVID-19 and our efforts to fight the pandemic. It’s now evident, though, that the war between Russia and Ukraine has redrawn the contours of the world economic outlook. Vladimir Putin’s unprovoked attack on Ukraine and its people is taking a devastating human toll, with lives tragically lost, families internally displaced or becoming refugees, and communities and cities destroyed.<br>...<br><br>&quot;&quot;&quot;<br></code></pre></td></tr></table></figure><p>Output 是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs other">Topic 1: The war in Ukraine<br>- The war is taking a human toll with lives lost, families displaced, and communities destroyed<br>- The Biden administration is committed to holding Russia accountable<br>- The war has violated international law and is a challenge to the international order<br><br>Topic 2: The global economy<br>- The war is having negative impacts on the global economy, including higher commodity prices and inflation<br>- The IMF and World Bank will be focused on helping developing countries weather the impacts of the war<br>- The ultimate outcome for the global economy depends on the path of the war<br></code></pre></td></tr></table></figure><p>关于这个场景和技巧，我想再解释一下为什么潜力很大。</p><p>根据我使用各种 Summary 或者信息提取的产品，我发现 AI 并不知道什么是重点，所以在总结的过程中，会丢失很多内容。如何引导 AI 进行总结，就变得非常重要，且具有一定的可玩性。</p><hr><p>感谢 <a href="https://github.com/AlexZhangji">AlexZhangji</a> 的分享，TA 提到一个使用此技巧的场景：</p><p>使用此技巧可以使输出更结构化。比如针对一篇文章进行问答，你不仅想要得到一个答案，也希望 ChatGPT 的答案符合特定的格式，方便你下一步进行自动化。</p><p>比如问 “这里的债券 duration 是多少？”. 正常 GPT 模型的答案可能是 “债券 duration 是 4 年” 或 “duration 4 年”。 ChatGPT 的回答不稳定，且不方便继续处理。</p><p>解法： 我们可以通过这个技巧，让模型理解我们预期的格式。并在此基础上，为了方便自动化，让模型输出特定的结构化答案 (比如 JSON&#x2F;Markdown 等)。 也可以方便集成更多的额外要求，比如增加一个”confidence level”, 并通过 prompt 的形式指定这些数值的格式。</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs other">&#123;context&#125;<br>Question: What is bond duration mentioned here.<br>Answer template (Valid JSON format):<br>&#123;&#123;<br>&quot;duration&quot;: $duration_numeric_value_in_year,<br>&quot;confidence_level&quot;: $answer_confidence_level_high_modrate_or_low,<br>&#125;&#125;<br>Answer:<br></code></pre></td></tr></table></figure><p>在吴恩达的 <a href="https://www.deeplearning.ai/short-courses/chatgpt-prompt-engineering-for-developers/">ChatGPT Prompt Engineering</a> 中，有提到一个这个技巧的高级用法，在让 AI 按照特定格式输出内容的同时，还让 AI 根据内容是否满足特定条件，来判断应该输出什么结果，下面课程中的案例的 prompt（注意这个是 python 代码，有一些转义字符，可以不用管）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">You will be provided <span class="hljs-keyword">with</span> text delimited by triple quotes.<br>If it contains a sequence of instructions, \<br>re-write those instructions <span class="hljs-keyword">in</span> the following <span class="hljs-built_in">format</span>:<br><br>Step <span class="hljs-number">1</span> - ...<br>Step <span class="hljs-number">2</span> - …<br>…<br>Step N - …<br><br>If the text does <span class="hljs-keyword">not</span> contain a sequence of instructions, \<br>then simply write \<span class="hljs-string">&quot;No steps provided.\&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">\&quot;\&quot;\&quot;&#123;text&#125;\&quot;\&quot;\&quot;</span><br></code></pre></td></tr></table></figure><p>简单解释下，这个 prompt 分成两步：</p><p>让 AI 将输入的 text 转为步骤（就是 prompt 里的 Step 1、2）</p><p>然后还增加了一个判断，如果输入的 text 里没有 step 的内容，那么就输出 No Step</p><p>假如输入的 text 是一个泡茶的步骤介绍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs other">Making a cup of tea is easy! First, you need to get some \<br>water boiling. While that&#x27;s happening, \<br>grab a cup and put a tea bag in it. Once the water is \<br>hot enough, just pour it over the tea bag. \<br>Let it sit for a bit so the tea can steep. After a \<br>few minutes, take out the tea bag. If you \<br>like, you can add some sugar or milk to taste. \<br>And that&#x27;s it! You&#x27;ve got yourself a delicious \<br>cup of tea to enjoy.<br></code></pre></td></tr></table></figure><p>那么 AI 输出的内容是这样的（因为内容中包含了步骤式的内容）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs other">Step 1 - Get some water boiling.<br>Step 2 - Grab a cup and put a tea bag in it.<br>Step 3 - Once the water is hot enough, pour it over the tea bag.<br>Step 4 - Let it sit for a bit so the tea can steep.<br>Step 5 - After a few minutes, take out the tea bag.<br>Step 6 - Add some sugar or milk to taste.<br>Step 7 - Enjoy your delicious cup of tea!<br></code></pre></td></tr></table></figure><p>但如果我们输入的是这样的 text：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs other">The sun is shining brightly today, and the birds are \<br>singing. It&#x27;s a beautiful day to go for a \<br>walk in the park. The flowers are blooming, and the \<br>trees are swaying gently in the breeze. People \<br>are out and about, enjoying the lovely weather. \<br>Some are having picnics, while others are playing \<br>games or simply relaxing on the grass. It&#x27;s a \<br>perfect day to spend time outdoors and appreciate the \<br>beauty of nature.<br></code></pre></td></tr></table></figure><p>从内容上看，这段话，没有任何步骤式的内容，所以 AI 的输出是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">No steps provided.<br></code></pre></td></tr></table></figure><h4 id="📄️-技巧-7：Zero-Shot-Chain-of-Thought"><a href="#📄️-技巧-7：Zero-Shot-Chain-of-Thought" class="headerlink" title="📄️ 技巧 7：Zero-Shot Chain of Thought"></a>📄️ 技巧 7：Zero-Shot Chain of Thought</h4><p>基于上述的第三点缺点，研究人员就找到了一个叫 Chain of Thought 的技巧。</p><p>这个技巧使用起来非常简单，只需要在问题的结尾里放一句 <code>Let‘s think step by step</code> （让我们一步步地思考），模型输出的答案会更加准确。</p><p>这个技巧来自于 Kojima 等人 2022 年的论文 <a href="https://arxiv.org/abs/2205.11916">Large Language Models are Zero-Shot Reasoners</a>。在论文里提到，当我们向模型提一个逻辑推理问题时，模型返回了一个错误的答案，但如果我们在问题最后加入 <code>Let‘s think step by step</code> 这句话之后，模型就生成了正确的答案：</p><p>​<img src="https://img.hello-yzg.cn/ChatGPT+%23+Hello+ChatGPT-005.png" style="zoom: 150%;" /></p><center style="color:#C0C0C0">图5</center><hr><p>论文里有讲到原因，感兴趣的朋友可以去看看，我简单解释下为什么（🆘 如果你有更好的解释，不妨反馈给我）：</p><ol><li>首先各位要清楚像 ChatGPT 这类产品，它是一个统计语言模型，本质上是基于过去看到过的所有数据，用统计学意义上的预测结果进行下一步的输出（这也就是为什么你在使用 ChatGPT 的时候，它的答案是一个字一个字地吐出来，而不是直接给你的原因，因为答案是一个字一个字算出来的）。</li><li>当它拿到的数据里有逻辑，它就会通过统计学的方法将这些逻辑找出来，并将这些逻辑呈现给你，让你感觉到它的回答很有逻辑。</li><li>在计算的过程中，模型会进行很多假设运算（不过暂时不知道它是怎么算的）。比如解决某个问题是从 A 到 B 再到 C，中间有很多假设。</li><li>它第一次算出来的答案错误的原因，只是因为它在中间跳过了一些步骤（B）。而让模型一步步地思考，则有助于其按照完整的逻辑链（A &gt; B &gt; C）去运算，而不会跳过某些假设，最后算出正确的答案。</li></ol><p>按照论文里的解释，零样本思维链涉及两个补全结果，左侧气泡表示基于提示输出的第一次的结果，右侧气泡表示其收到了第一次结果后，将最开始的提示一起拿去运算，最后得出了正确的答案：</p><p>​<img src="https://img.hello-yzg.cn/ChatGPT+%23+Hello+ChatGPT-006.png" style="zoom: 150%;" /></p><center style="color:#C0C0C0">图6</center><hr><p>这个技巧，除了用于解决复杂问题外，还适合生成一些连贯主题的内容，比如写长篇文章、电影剧本等。</p><p>但需要注意其缺点，连贯不代表，它就一定不会算错，如果其中某一步骤算错了，错误会因为逻辑链，逐步将错误积累，导致生成的文本可能出现与预期不符的内容。</p><p>根据 <a href="https://arxiv.org/pdf/2201.11903.pdf">Wei 等人在2022 年的论文</a> 表明，它仅在大于等于 100B 参数的模型中使用才会有效。如果你使用的是小样本模型，这个方法不会生效。</p><hr><p>另外，根据 <a href="https://sites.google.com/view/automatic-prompt-engineer">Yongchao Zhou 等人的最新论文</a>，更好的 prompt 是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Let&#x27;s work this out in a step by step way to be sure we have the right answer.<br></code></pre></td></tr></table></figure><p>在吴恩达的 <a href="https://www.deeplearning.ai/short-courses/chatgpt-prompt-engineering-for-developers/">ChatGPT Prompt Engineering</a> 中，有提到一个这个技巧的另一种用法，不仅仅只是让 AI 按步骤行事，还会告知 AI 每一步要做什么。比如这个案例（注意这个是 python 代码）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">prompt_2 = f&quot;&quot;&quot;<br>Your task is to perform the following actions:<br>1 - Summarize the following text delimited by<br>  &lt;&gt; with 1 sentence.<br>2 - Translate the summary into French.<br>3 - List each name in the French summary.<br>4 - Output a json object that contains the<br>  following keys: french_summary, num_names.<br><br>Use the following format:<br>Text: &lt;text to summarize&gt;<br>Summary: &lt;summary&gt;<br>Translation: &lt;summary translation&gt;<br>Names: &lt;list of names in Italian summary&gt;<br>Output JSON: &lt;json with summary and num_names&gt;<br><br>Text: &lt;&#123;text&#125;&gt;<br>&quot;&quot;&quot;<br></code></pre></td></tr></table></figure><p>简单解释下这个代码：</p><ol><li>开头是让 AI 按照 1 ～ 4 步运行</li><li>然后再让 AI 根据特定格式输出内容</li></ol><p>最后 AI 的输出是这样的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">Summary: Jack and Jill go on a quest to fetch water, but misfortune strikes and they tumble down the hill, returning home slightly battered but with their adventurous spirits undimmed.<br>Translation: Jack et Jill partent en quête d&#x27;eau, mais la malchance frappe et ils dégringolent la colline, rentrant chez eux légèrement meurtris mais avec leurs esprits aventureux intacts.<br>Names: Jack, Jill<br>Output JSON: &#123;&quot;french_summary&quot;: &quot;Jack et Jill partent en quête d&#x27;eau, mais la malchance frappe et ils dégringolent la colline, rentrant chez eux légèrement meurtris mais avec leurs esprits aventureux intacts.&quot;, &quot;num_names&quot;: 2&#125;<br></code></pre></td></tr></table></figure><p>上述的案例只是将任务拆解，能让 AI 生成的结果更加符合要求，这个方法同样能提升 AI 的回答准确性，比如这个案例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs text">Determine if the student&#x27;s solution is correct or not.<br><br>Question:<br>I&#x27;m building a solar power installation and I need help working out the financials.<br><br>Land costs $100 / square foot<br><br>I can buy solar panels for $250 / square foot<br><br>I negotiated a contract for maintenance that will cost <br>me a flat $100k per year, and an additional $10 / square foot<br>What is the total cost for the first year of operations<br>as a function of the number of square feet.<br><br>Student&#x27;s Solution:<br>Let x be the size of the installation in square feet.<br>Costs:<br><br>Land cost: 100x<br><br>Solar panel cost: 250x<br><br>Maintenance cost: 100,000 + 100x<br>Total cost: 100x + 250x + 100,000 + 100x = 450x + 100,000<br></code></pre></td></tr></table></figure><p>AI 的回答是「The student’s solution is correct」。但其实学生的答案是错误的，应该 360x + 100,000，我们将 prompt 调整成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python">prompt = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">Your task is to determine if the student&#x27;s solution </span><br><span class="hljs-string">is correct or not.</span><br><span class="hljs-string">To solve the problem do the following:</span><br><span class="hljs-string">- First, work out your own solution to the problem.</span><br><span class="hljs-string">- Then compare your solution to the student&#x27;s solution </span><br><span class="hljs-string">and evaluate if the student&#x27;s solution is correct or not.</span><br><span class="hljs-string">Don&#x27;t decide if the student&#x27;s solution is correct until</span><br><span class="hljs-string">you have done the problem yourself.</span><br><span class="hljs-string">Use the following format:</span><br><span class="hljs-string">Question:</span><br><span class="hljs-string">###</span><br><span class="hljs-string">question here</span><br><span class="hljs-string">###</span><br><span class="hljs-string">Student&#x27;s solution:</span><br><span class="hljs-string">###</span><br><span class="hljs-string">student&#x27;s solution here</span><br><span class="hljs-string">###</span><br><span class="hljs-string">Actual solution:</span><br><span class="hljs-string">###</span><br><span class="hljs-string">steps to work out the solution and your solution here</span><br><span class="hljs-string">###</span><br><span class="hljs-string">Is the student&#x27;s solution the same as actual solution </span><br><span class="hljs-string">just calculated:</span><br><span class="hljs-string">###</span><br><span class="hljs-string">yes or no</span><br><span class="hljs-string">###</span><br><span class="hljs-string">Student grade:</span><br><span class="hljs-string">###</span><br><span class="hljs-string">correct or incorrect</span><br><span class="hljs-string">###</span><br><span class="hljs-string">Question:</span><br><span class="hljs-string">###</span><br><span class="hljs-string">I&#x27;m building a solar power installation and I need help </span><br><span class="hljs-string">working out the financials.</span><br><span class="hljs-string">- Land costs $100 / square foot</span><br><span class="hljs-string">- I can buy solar panels for $250 / square foot</span><br><span class="hljs-string">- I negotiated a contract for maintenance that will cost </span><br><span class="hljs-string">  me a flat $100k per year, and an additional $10 / square </span><br><span class="hljs-string">  foot</span><br><span class="hljs-string">  What is the total cost for the first year of operations </span><br><span class="hljs-string">  as a function of the number of square feet.</span><br><span class="hljs-string">###</span><br><span class="hljs-string">Student&#x27;s solution:</span><br><span class="hljs-string">###</span><br><span class="hljs-string">Let x be the size of the installation in square feet.</span><br><span class="hljs-string">Costs:</span><br><span class="hljs-string">1. Land cost: 100x</span><br><span class="hljs-string">2. Solar panel cost: 250x</span><br><span class="hljs-string">3. Maintenance cost: 100,000 + 100x</span><br><span class="hljs-string">   Total cost: 100x + 250x + 100,000 + 100x = 450x + 100,000</span><br><span class="hljs-string">###</span><br><span class="hljs-string">Actual solution:</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>本质上，也是将任务分拆成多步，这次 AI 输出的结果是这样的（结果就是正确的了）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">Let x be the size of the installation in square feet.<br><br>Costs:<br><br>1. Land cost: 100x<br>2. Solar panel cost: 250x<br>3. Maintenance cost: 100,000 + 10x<br><br>Total cost: 100x + 250x + 100,000 + 10x = 360x + 100,000<br><br>Is the student&#x27;s solution the same as actual solution just calculated:<br>No<br><br>Student grade:<br>Incorrect<br></code></pre></td></tr></table></figure><h4 id="📄️-技巧-8：Few-Shot-Chain-of-Thought"><a href="#📄️-技巧-8：Few-Shot-Chain-of-Thought" class="headerlink" title="📄️ 技巧 8：Few-Shot Chain of Thought"></a>📄️ 技巧 8：Few-Shot Chain of Thought</h4><p>要解决这个缺陷，就要使用到新的技巧，Few-Shot Chain of Thought。</p><p>根据 <a href="https://arxiv.org/pdf/2201.11903.pdf">Wei 他们团队在2022 年的研究 </a>表明：</p><blockquote><p>通过向大语言模型展示一些少量的样例，并在样例中解释推理过程，大语言模型在回答提示时也会显示推理过程。这种推理的解释往往会引导出更准确的结果。</p></blockquote><p>下面是论文里的案例，使用方法很简单，在技巧2 的基础上，再将逻辑过程告知给模型即可。从下面这个案例里，你可以看到加入解释后，输出的结果就正确了。</p><p>​<img src="https://img.hello-yzg.cn/ChatGPT+%23+Hello+ChatGPT-007.png" style="zoom: 150%;" /></p><center style="color:#C0C0C0">图7</center><hr><p>那本章开头提的例子就应该是这样的（注：本例子同样来自 Wei 团队论文）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs other">The odd numbers in this group add up to an even number: 4, 8, 9, 15, 12, 2, 1.<br>A: Adding all the odd numbers (9, 15, 1) gives 25. The answer is False.<br><br>The odd numbers in this group add up to an even number: 17,  10, 19, 4, 8, 12, 24.<br>A: Adding all the odd numbers (17, 19) gives 36. The answer is True.<br><br>The odd numbers in this group add up to an even number: 16,  11, 14, 4, 8, 13, 24.<br>A: Adding all the odd numbers (11, 13) gives 24. The answer is True.<br><br>The odd numbers in this group add up to an even number: 17,  9, 10, 12, 13, 4, 2.<br>A: Adding all the odd numbers (17, 9, 13) gives 39. The answer is False.<br><br>The odd numbers in this group add up to an even number: 15, 32, 5, 13, 82, 7, 1. <br>A:<br></code></pre></td></tr></table></figure><p>聊完技巧，我们再结合前面的 Zero-Shot Chain of Thought，来聊聊 Chain of Thought 的关键知识。根据 <a href="https://arxiv.org/abs/2202.12837">Sewon Min 等人在2022 年的研究</a> 表明，思维链有以下特点：</p><ol><li>“the label space and the distribution of the input text specified by the demonstrations are both key (regardless of whether the labels are correct for individual inputs)” 标签空间和输入文本的分布都是关键因素（无论这些标签是否正确）。</li><li>the format you use also plays a key role in performance, even if you just use random labels, this is much better than no labels at all. 即使只是使用随机标签，使用适当的格式也能提高性能。</li></ol><p>理解起来有点难，我找一个 prompt 案例给大家解释（🆘 如果你有更好的解释，不妨反馈给我）。我给 ChatGPT 一些不一定准确的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs other">I loved the new Batman movie!  // Negative<br>This is bad // Positive<br>This is good // Negative<br>What a good show! //<br></code></pre></td></tr></table></figure><p>Output 是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">Positive<br></code></pre></td></tr></table></figure><p>在上述的案例里，每一行，我都写了一句话和一个情感词，并用 &#x2F;&#x2F; 分开，但我给这些句子都标记了错误的答案，比如第一句其实应该是 Positive 才对。但：</p><ol><li>即使我给内容打的标签是错误的（比如第一句话，其实应该是 Positive），对于模型来说，它仍然会知道需要输出什么东西。 换句话说，模型知道 &#x2F;&#x2F; 划线后要输出一个衡量该句子表达何种感情的词（Positive or Negative）。这就是前面论文里 #1 提到的，即使我给的标签是错误的，或者换句话说，是否基于事实，并不重要。标签和输入的文本，以及格式才是关键因素。</li><li>只要给了示例，即使随机的标签，对于模型生成结果来说，都是有帮助的。这就是前面论文里 #2 提到的内容。</li></ol><p>最后，需要记住，思维链仅在使用大于等于 100B 参数的模型时，才会生效。</p><p>BTW，如果你想要了解更多相关信息，可以看看斯坦福大学的讲义：<a href="http://web.stanford.edu/class/cs224n/slides/cs224n-2023-lecture11-prompting-rlhf.pdf">Natural Language Processing with Deep Learning</a></p><h4 id="📄️-技巧9：其他"><a href="#📄️-技巧9：其他" class="headerlink" title="📄️ 技巧9：其他"></a>📄️ 技巧9：其他</h4><p>一些小的技巧，我会统一放在这里。</p><ol><li>在示例里加入特定符号，让模型知道如何处理特殊情况</li></ol><p>这个解释起来有点复杂，以下是 OpenAI 的官方 prompt，在一些奇怪的问题上比如 <code>What is Devz9</code> 的回答，你可以用 ？ 代替答案，让模型知道当遇到超出回答范围时，需要如何处理（注意：此方法在 playground 上有效，但在 ChatGPT 上无效）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs other">Q: Who is Batman?<br>A: Batman is a fictional comic book character.<br><br>Q: What is torsalplexity?<br>A: ?<br><br>Q: What is Devz9?<br>A: ?<br><br>Q: Who is George Lucas?<br>A: George Lucas is American film director and producer famous for creating Star Wars.<br><br>Q: What is the capital of California?<br>A: Sacramento.<br><br>Q: What is Kozar-09?<br>A: <br></code></pre></td></tr></table></figure><p>它的 Output 是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">?<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Large Model</category>
      
      <category>ChatGPT</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>盛最多水的容器</title>
    <link href="/2023/2c301bfae337/"/>
    <url>/2023/2c301bfae337/</url>
    
    <content type="html"><![CDATA[<h3 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h3><blockquote><p>C++ Tips</p><ol><li>vector auto 长度： auto.size()</li><li>数组 auto 长度：std : size(auto)</li></ol><p>Java Tips</p><ol><li>数组 auto 长度：auto.length</li></ol><p>Python Tips</p><ol><li>Python的设计哲学之一是”显式优于隐式”，因此不能使用 ++ 或 – 运算符，而是使用 +&#x3D; 1 或 -&#x3D; 1 实现自加或自减。</li></ol></blockquote><p>题目：</p><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><h4 id="贪心双指针"><a href="#贪心双指针" class="headerlink" title="贪心双指针"></a>贪心双指针</h4><p>时间复杂度：O(<em>n</em>)</p><p>空间复杂度：O(1)</p><h5 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//c++</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>, right = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123; <span class="hljs-comment">// 双指针</span><br>            <span class="hljs-type">int</span> area = (right - left) * <span class="hljs-built_in">min</span>(height[left],height[right]);<br>            ans = <span class="hljs-built_in">max</span>(ans, area);<br>            height[left] &lt; height[right] ? ++left : --right; <span class="hljs-comment">//贪心迭代</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>, right = height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> (right - left) * Math.min(height[left], height[right]);<br>            ans = Math.max(ans, area);<br>            <span class="hljs-keyword">if</span>(height[left] &lt; height[right]) ++left;<br>            <span class="hljs-keyword">else</span> --right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#python3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params">self, height: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = left = <span class="hljs-number">0</span><br>        right = <span class="hljs-built_in">len</span>(height) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            area = (right - left) * <span class="hljs-built_in">min</span>(height[left], height[right])<br>            ans = <span class="hljs-built_in">max</span>(ans, area)<br>            <span class="hljs-keyword">if</span> height[left] &lt; height[right]:<br>                left += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                right -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h5 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>* height, <span class="hljs-type">int</span> heightSize)</span> &#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>, right = heightSize - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-type">int</span> area = (right - left) * (height[left] &lt; height[right] ? height[left] : height[right]);<br>        ans = ans &lt; area ? area : ans;<br>        <span class="hljs-keyword">if</span>(height[left] &lt; height[right])&#123;<br>            ++left;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            --right;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//javascript</span><br><span class="hljs-keyword">var</span> maxArea = <span class="hljs-keyword">function</span>(<span class="hljs-params">height</span>) &#123;<br>    <span class="hljs-keyword">let</span> ans = <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>, right = height.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">const</span> area = (right - left) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(height[left], height[right]);<br>        ans = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(ans, area);<br>        <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<br>            left++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm Design</category>
      
      <category>LeetCode</category>
      
      <category>进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="/2023/66abd09f7aa7/"/>
    <url>/2023/66abd09f7aa7/</url>
    
    <content type="html"><![CDATA[<h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><blockquote><p>C++ Tips</p><ol><li>C++11引入 unordered_set（哈希表的数据结构实现，存储不重复元素）</li></ol><p>Java Tips</p><ol><li>通过Math类使用数学函数</li></ol><p>Python Tips</p><ol><li>enumerate() 返回一个可迭代对象</li></ol></blockquote><p>题目：</p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><h4 id="链表遍历"><a href="#链表遍历" class="headerlink" title="链表遍历"></a>链表遍历</h4><p>时间复杂度：O(<em>n</em>)</p><p>空间复杂度：O(∣Σ∣)，其中 ∣Σ∣ 为字符集合的大小，本题中字符均为 ASCII 字符，所以 ∣Σ∣≤128。</p><h5 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//c++</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>(), ans = <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>;<br>        unordered_set&lt;<span class="hljs-type">char</span>&gt; window; <span class="hljs-comment">// 动态枚举left至right的字符</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>; right &lt; n; ++right)&#123; <span class="hljs-comment">// 窗口向右扩展</span><br>            <span class="hljs-type">char</span> c = s[right];<br>            <span class="hljs-keyword">while</span> (window.<span class="hljs-built_in">count</span>(c)) <span class="hljs-comment">// 发现重复</span><br>                window.<span class="hljs-built_in">erase</span>(s[left++]); <span class="hljs-comment">// 窗口向右坍缩直至无重复，因为无法向左扩展寻找可能的更大窗口</span><br>            window.<span class="hljs-built_in">insert</span>(c);<br>            ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>); <span class="hljs-comment">// 更新结果</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] s_ = s.toCharArray(); <span class="hljs-comment">// 转换成 char[] 提高效率（忽略带来的空间消耗）</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s_.length, ans = <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span>[] has = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">128</span>]; <span class="hljs-comment">// 也可以用 HashSet&lt;Character&gt;，这里使用 boolean[] 提高效率</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; n; ++right)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s_[right];<br>            <span class="hljs-keyword">while</span>(has[c])<br>                has[s_[left++]] = <span class="hljs-literal">false</span>;<br>            has[c]=<span class="hljs-literal">true</span>;<br>            ans = Math.max(ans, right - left + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#python3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        ans = left = <span class="hljs-number">0</span><br>        window = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">for</span> right, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            <span class="hljs-keyword">while</span> c <span class="hljs-keyword">in</span> window:<br>                window.remove(s[left])<br>                left += <span class="hljs-number">1</span><br>            window.add(c)<br>            ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h5 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-type">char</span>* s)</span> &#123;<br>    <span class="hljs-type">int</span> hash[<span class="hljs-number">128</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 模拟哈希表</span><br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(s), ans = <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>; right &lt; n; ++right)&#123;<br>        hash[s[right]]++;<br>        <span class="hljs-keyword">while</span>(hash[s[right]] &gt; <span class="hljs-number">1</span>) hash[s[left++]]--;<br>        ans = ans &lt; (right-left+<span class="hljs-number">1</span>) ? (right-left+<span class="hljs-number">1</span>) : ans;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans; <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//javascript</span><br><span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">window</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>; right &lt; s.<span class="hljs-property">length</span>; right++) &#123;<br>        <span class="hljs-keyword">const</span> c = s[right];<br>        <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">has</span>(c)) &#123;<br>            <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">delete</span>(s[left++]);<br>        &#125;<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">add</span>(c);<br>        ans = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(ans, right - left + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm Design</category>
      
      <category>LeetCode</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数相加</title>
    <link href="/2023/a85684359d52/"/>
    <url>/2023/a85684359d52/</url>
    
    <content type="html"><![CDATA[<h3 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h3><blockquote><p>C++ Tips</p><ol><li><p>new 的返回类型为指针，执行构造函数</p></li><li><p>C++11引入参数列表构造（类与结构体）</p></li></ol><p>Java Tips</p><ol><li>new的返回类型为引用，执行构造函数</li></ol></blockquote><p>题目：</p><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><h4 id="链表遍历"><a href="#链表遍历" class="headerlink" title="链表遍历"></a>链表遍历</h4><p>时间复杂度：O(<em>n</em>)</p><p>空间复杂度：O(<em>1</em>)</p><h5 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//c++</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        <span class="hljs-keyword">auto</span> cur = dummy; <span class="hljs-comment">// cur用于指针操作，dummy用于指针返回</span><br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>; <span class="hljs-comment">// 进位</span><br>        <span class="hljs-keyword">while</span>(l1 || l2 || carry)&#123; <span class="hljs-comment">// 指针操作未完成或存在进位</span><br>             carry += (l1 ? l1-&gt;val : <span class="hljs-number">0</span>) + (l2 ? l2-&gt;val : <span class="hljs-number">0</span>); <br>             cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(carry % <span class="hljs-number">10</span>); <span class="hljs-comment">// 计算存储值</span><br>             carry /= <span class="hljs-number">10</span>; <span class="hljs-comment">// 计算进位值</span><br>             <span class="hljs-keyword">if</span> (l1) l1 = l1-&gt;next;<br>             <span class="hljs-keyword">if</span> (l2) l2 = l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy; <span class="hljs-comment">// 对同一个对象的引用</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span> || carry != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">null</span>) carry += l1.val;<br>            <span class="hljs-keyword">if</span>(l2 != <span class="hljs-literal">null</span>) carry += l2.val;<br>            cur = cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry % <span class="hljs-number">10</span>);<br>            carry /= <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">null</span>) l1 = l1.next;<br>            <span class="hljs-keyword">if</span>(l2 != <span class="hljs-literal">null</span>) l2 = l2.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#python3</span><br><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addTwoNumbers</span>(<span class="hljs-params">self, l1: <span class="hljs-type">Optional</span>[ListNode], l2: <span class="hljs-type">Optional</span>[ListNode]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        cur = dummy = ListNode()<br>        carry = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2 <span class="hljs-keyword">or</span> carry:<br>            carry += (l1.val <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>) + (l2.val <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)<br>            cur.<span class="hljs-built_in">next</span> = ListNode(carry % <span class="hljs-number">10</span>)<br>            carry //= <span class="hljs-number">10</span><br>            cur = cur.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> l1: l1 = l1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> l2: l2 = l2.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h5 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//c</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* l1, <span class="hljs-keyword">struct</span> ListNode* l2)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">dummy</span> =</span> (<span class="hljs-keyword">struct</span> ListNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode)); <span class="hljs-comment">// 哑节点(dummy node)</span><br>dummy-&gt;val = <span class="hljs-number">0</span>;<br>dummy-&gt;next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">cur</span> =</span> dummy;<br><span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (l1 || l2 || carry)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">temp</span> =</span> (<span class="hljs-keyword">struct</span> ListNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));<br>        carry += (l1 ? l1-&gt;val : <span class="hljs-number">0</span>) + (l2 ? l2-&gt;val : <span class="hljs-number">0</span>);<br>temp-&gt;val = carry % <span class="hljs-number">10</span>;<br>temp-&gt;next = <span class="hljs-literal">NULL</span>;<br>cur-&gt;next = temp;<br><br>cur = cur-&gt;next;<br>carry = carry / <span class="hljs-number">10</span>;<br>l1 = l1 ? l1-&gt;next : <span class="hljs-literal">NULL</span>;<br>l2 = l2 ? l2-&gt;next : <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//javascript</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">l1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">l2</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> addTwoNumbers = <span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) &#123;<br>    <span class="hljs-keyword">let</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(); <br>    <span class="hljs-keyword">let</span> cur = dummy;<br>    <span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">while</span> (l1 || l2 || carry) &#123;<br>        <span class="hljs-keyword">if</span> (l1) carry += l1.<span class="hljs-property">val</span>; <br>        <span class="hljs-keyword">if</span> (l2) carry += l2.<span class="hljs-property">val</span>; <br>        cur = cur.<span class="hljs-property">next</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry % <span class="hljs-number">10</span>); <br>        carry = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(carry / <span class="hljs-number">10</span>); <br>        <span class="hljs-keyword">if</span> (l1) l1 = l1.<span class="hljs-property">next</span>; <br>        <span class="hljs-keyword">if</span> (l2) l2 = l2.<span class="hljs-property">next</span>; <br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-property">next</span>; <br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm Design</category>
      
      <category>LeetCode</category>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>延迟变量扩展</title>
    <link href="/2023/ed9d68fbd99a/"/>
    <url>/2023/ed9d68fbd99a/</url>
    
    <content type="html"><![CDATA[<h3 id="延迟变量扩展"><a href="#延迟变量扩展" class="headerlink" title="延迟变量扩展"></a>延迟变量扩展</h3><p>在使用批处理进行文件遍历时，由于文件路径使用了延迟变量扩展导致路径定位失败，代码如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs powershell">@<span class="hljs-built_in">echo</span> off &amp; setlocal enabledelayedexpansion<br><br>rem 省略具体路径<br><span class="hljs-built_in">set</span> path=......<br><br>call :Test !path!<br><br>pause<br><br>:TestMethod<br><span class="hljs-built_in">set</span> arg1=%~<span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> exist !arg1! (<br>    <span class="hljs-keyword">for</span> /<span class="hljs-built_in">R</span> !arg1! %%F <span class="hljs-keyword">in</span> (\*) <span class="hljs-keyword">do</span> (<br>        <span class="hljs-keyword">if</span> not %%~nxF==test.bat (<br>            <span class="hljs-built_in">del</span> %%F /q<br>        )<br>    )<br>)<br>goto :eof<br></code></pre></td></tr></table></figure><p>代码非常简单，使用延迟变量扩展和标签传入路径，递归遍历，删除test.bat外的所有文件。原则上开启了延迟变量后——setlocal enabledelayedexpansion，变量引用就应该使用 !*!，但奇怪的是，对于12行，可以正确执行，但对于13行，就无法定位路径，多次测试还发现以下信息：</p><ul><li>将13行中的延迟变量扩展更改为变量扩展，即%arg1%，问题消失</li><li>将13行中的遍历目标改为文件夹，问题消失</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">...<br><span class="hljs-keyword">for</span> /D %%F <span class="hljs-keyword">in</span> (!arg1!\*) <span class="hljs-keyword">do</span> (<br>...<br></code></pre></td></tr></table></figure><p>总而言之，现有的语法规则无法解释上述现象，多方查阅依然没有定论，记录在这里，希望未来可以得到解答。</p>]]></content>
    
    
    <categories>
      
      <category>Program Language</category>
      
      <category>Batch</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>???</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2023/70527323af9f/"/>
    <url>/2023/70527323af9f/</url>
    
    <content type="html"><![CDATA[<h3 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1. 线性表"></a>1. 线性表</h3><ul><li><p>C&#x2F;C++ 中，malloc 的结果为 void* , 因此需进行强制类型转换。</p></li><li><p>链表表头节点的优势：简化操作，具体表现在：</p><ul><li>起点稳定</li><li>便于判空</li><li>统一化操作（增删链表首元素无需进行特殊处理）</li></ul></li><li><p>从freelist理解为什么新申请的内存会有脏数据，即变量初始化的必要性。</p></li><li><p>两种实现方式的根本区别（基于下标）：</p><table><thead><tr><th align="center"></th><th align="center">顺序表n</th><th align="center">单链表n</th></tr></thead><tbody><tr><td align="center">增删</td><td align="center">顺序插入     O (n)</td><td align="center">随机插入      O (1)</td></tr><tr><td align="center">改查</td><td align="center">随机查找     O (1)</td><td align="center">顺序查找      O (n)</td></tr></tbody></table></li><li><p>单链表的典型操作代码（指针基础）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义单链表节点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><br>ElemType data;         <span class="hljs-comment">//数据域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>* <span class="hljs-title">link</span>;</span>    <span class="hljs-comment">//指针域</span><br>&#125;* LinkList;<br><br><span class="hljs-comment">//插入</span><br>Status <span class="hljs-title function_">Insert</span> <span class="hljs-params">(LNode *L, LNode *p, ElemType item)</span><br>&#123;<br>    LNode *temp;<br>    temp = (LNode *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    <span class="hljs-keyword">if</span>(temp == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">else</span> temp-&gt;data = item;<br>    temp-&gt;link = p-&gt;link;<br>    p-&gt;link = temp;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//删除</span><br>Status <span class="hljs-title function_">Delete</span> <span class="hljs-params">(LNode *L, LNode *p, ElemType *item)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(L == <span class="hljs-literal">NULL</span> || p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>    *item = p-&gt;link-&gt;data;<br>    p-&gt;link = p-&gt;link-&gt;link;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-栈，队列和数组"><a href="#2-栈，队列和数组" class="headerlink" title="2. 栈，队列和数组"></a>2. 栈，队列和数组</h3><ul><li><p>循环队列中，由于入队时队尾指针追赶头指针，出队时头指针追赶队尾指针，因此队空与队满时头尾指针相对位置相同（重合），最常见的修改方式为：设定 length 为 n 的队列存储上限为 n-1。</p></li><li><p>栈的应用（利用先进先出的特点）：</p><ul><li>表达式中括号的匹配检查</li><li>计算后缀表达式</li></ul></li><li><p>队列的应用：</p><ul><li>二叉树的层序遍历（后续章节介绍）</li></ul></li><li><p>特殊矩阵的压缩存储（地址转换式）</p><p><strong>推导思想为算出 i 前一行为止的项数，加上 i 行的偏移量。</strong></p><ul><li><p>上三角矩阵（首项：n尾项：n - i + 1项数：i偏移量：j - i          ） $[(n+n-i+1)*i]&#x2F;2 + j-i$</p></li><li><p>下三角矩阵（首项：1尾项：i            项数：i偏移量：j              ） $[(1+i)*i]&#x2F;2 + j $</p></li><li><p>三对角矩阵（差值：1行项：3           项数：i偏移量：j - i + 1   ） $3i-1 + j-i+1$</p></li></ul></li></ul><center style="color:#C0C0C0">图1</center><h3 id="3-树与二叉树"><a href="#3-树与二叉树" class="headerlink" title="3. 树与二叉树"></a>3. 树与二叉树</h3><ul><li><p>树结构本身是一个递归的结构。</p></li><li><p>含$n$个节点的树中，边数为$n-1$（由根节点出发，每个节点都需要一条边与之相连）。</p></li><li><p>节点所在层数 &#x3D; 路径长度 &#x3D; 节点深$(i&gt;&#x3D;0)$,  $i_{max} + 1 &#x3D; 树高（h&gt;&#x3D;1)$。</p></li><li><p>满二叉树教材定义有分歧（建议以定义一为主）：</p><ul><li>定义一：所有分支节点度均为 2，叶i子节点处在同一层</li><li>定义二：仅有度为 2 和 0 的节点</li></ul></li><li><p>完全二叉树：$0 \sim h-1$ 层为满二叉树，$h$层节点靠左排列。&#x3D;&#x3D;这里会混淆层数与高度，会意即可&#x3D;&#x3D;</p></li><li><p>二叉树的一些数学性质依赖等比数列求和公式（首项为1，公比为2）：</p><ul><li>第 i 层最大节点数：$2^i (i&gt;&#x3D;0)$</li><li>高度为 h 最大节点总数： $2^h-1 (h&gt;&#x3D;1)$</li></ul></li></ul><blockquote><p>公比为q的等比数列前n项和：$S_n&#x3D;\frac{a_1(1-q^n)}{1-q}$, 通过错位相减法证明</p></blockquote><ul><li>具有 n 个节点的完全二叉树高为：$\lceil \log_2(n+1) \rceil$。</li></ul><blockquote><p>$2^{h-1}-1 &lt; n \le 2^h-1$<br>$2^{h-1} &lt; n+1 \le 2^h$<br>$h-1 &lt; log_2(n+1) \le h$<br>$log_2(n+1) \le h &lt; log_2(n+1)+1$</p><p>$\therefore h &#x3D; \lceil \log_2(n+1) \rceil$</p></blockquote><ul><li>对于任意二叉树，有叶节点数为 $n_0$, 度为 1 的节点数为$n_1$, 度为 2 的节点数为$n_2$, 则 $n_0&#x3D;n_2+1$。</li></ul><blockquote><p>记二叉树边数为 b</p><p>$b&#x3D;n-1&#x3D;n_0+n_1+n_2-1$</p><p>$b&#x3D;2n_2+n_1$</p><p>$n_0+n_1+n_2-1&#x3D;2n_2+n_1$</p><p>$\therefore n_0&#x3D;n_2+1$</p></blockquote><ul><li>满二叉树定理可推广至k叉树：$n_0&#x3D;\sum_{i&#x3D;2}^k(i-1)n_i+1$</li><li>完全二叉树的顺序存储（高度$h\ge1$, 层数$i\ge0$）<ul><li>根节点存储在$A[0]$, 数组大小为$2^h-1$</li><li>$A[i]$， 左子节点为$A[2i+1]$，右子节点为$A[2i+2]$</li></ul></li></ul><blockquote><p>假设$A[i]$左子节点是最后一个节点，即通过满二叉树定理可得叶节点数为$i+1$</p><p>$\therefore 左子节点地址&#x3D; i+叶子节点数&#x3D;i+(i+1)&#x3D;2i+1$</p><p>假设$A[i]$右子节点是最后一个节点，即通过满二叉树定理可得叶节点数为$i+1+1$（$A[i]$度也为2）</p><p>$\therefore 右子节点地址&#x3D; i+叶子节点数&#x3D;i+(i+1+1)&#x3D;2i+2$</p></blockquote><ul><li>二叉树的链式存储（二叉链表）定义：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinNode</span>&#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinNode</span>* <span class="hljs-title">lchild</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinNode</span>* <span class="hljs-title">rchild</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在$2n$个指针域中，有$n-1$个非空指针域（边），有$n+1$个空指针域。</li><li>三叉链表对比二叉链表多了一个用来存储 parent 的指针域。</li><li>二叉树必须给定中序遍历序列 + 先序遍历序列 &#x2F; 后序遍历序列，才可确定唯一的树结构。（依赖中序序列分割左右子树）</li><li>二叉树进行递归遍历时，利用叶子节点的空指针域记录直接前驱与直接后继的地址，这样在进行一次遍历的同时也对树进行了线索化，之后再遍历时将不再需要递归，而是根据线索指针线性遍历即可。</li><li>树的  “左孩子右兄弟” 二叉链表（与 “子节点” 二叉链表不同）存储方式，为树与二叉树的转换提供了桥梁。</li><li>一棵树的后根遍历与这棵树所对应的二叉树的中序遍历相同。因为树转化为二叉树后是没有右子树的，所以最后访问的是树的根结点。</li><li>对于二叉排序树，在得到先序遍历序列 &#x2F; 后序遍历序列时，中序遍历序列是隐含的，因为有序性使得左子树值一定小于根节点，右子树值一定大于根节点，由此分割左右子树。</li><li>二叉排序树的查找效率在理想情况下为$O(log_2n)$, 相当于折半查找；但最坏情况下可能由于失衡而退化为线性树，查找时间复杂度为$O(n)$。</li><li>对二叉排序树进行插入或删除时，插入的对象一定是叶子节点，删除时如果度为 0 或 1，也相对简单，但删除度为 2 的节点时，由于需要维持树的有序性，要找到被删除节点的直接前驱（左子树的 “右下角”）或直接后继（右子树的 “左下角”）进行代替。</li><li>平衡二叉树（AVL树）在插入或删除时，需检查是否失衡：<ul><li>左子树左侧过长失衡 -&gt; 沿根节点右旋</li><li>左子树右侧过长失衡 -&gt; 先沿左子树节点左旋（转换为左子树左侧过长失衡），再沿根节点右旋</li><li>右子树左侧过长失衡 -&gt; 先沿右子树节点右旋（转换为右子树右侧过长失衡），再沿根节点左旋</li><li>右子树右侧过长失衡 -&gt; 沿根节点左旋</li></ul></li><li>等长编码：ASCII码（8位），Unicode（16位）；不等长编码：哈夫曼编码（通过哈夫曼算法构建哈夫曼树）。</li><li>哈夫曼译码：通过逐位扫描哈夫曼编码，0则进入哈夫曼树左分支，1则进入哈夫曼树右分支，直到扫描完成到达叶子节点读取译码，由于译码只存储在叶子节点中，因此具有前缀特性，即任何字符编码都不是其他任何字符编码的前缀。</li></ul><h3 id="4-图"><a href="#4-图" class="headerlink" title="4. 图"></a>4. 图</h3><ul><li>无向图的邻接矩阵为对称矩阵， $i$行或$i$列的非零元素个数为顶点$i$的度；对于有向图，$i$行的非零元素个数为顶点$i$的入度，$i$列的非零元素个数为顶点$i$的出度。</li><li>将邻接链表的表头元素使用数组存储的方法为邻接表。无向图顶点$i$对应的邻接链表结点个数为顶点$i$的度；对于有向图，顶点$i$对应的邻接链表结点个数为顶点$i$的出度，顶点$i$的入度需要遍历全部的邻接链表，为了方便，常引入逆邻接表。</li><li>邻接多重表避免了无向图的重复存储，有利于边的遍历处理。利用 mark 对边进行标记，利用 link 保存方向信息，本质为引入了指针域存储方向信息，因此不再对边进行重复存储。<ul><li>链表节点：| mark | vertex1 | link1 | vertex2 | link2 |</li></ul></li><li>在邻接多重表基础上，修改数组节点，增加入度与出度表头指针域，变为十字链表（本质为融合逆邻接表）。<ul><li>链表节点：| mark | vertex1 | link1 | vertex2 | link2 |</li><li>数组节点：| vertex | firin | firout |</li></ul></li><li>图的深度优先搜索（DFS）本质为递归，使用栈结构，得到图的各个连通分量，可用于构建连通树与最小DFS生成树。直观来看，DFS为沿当前路径不断遍历，直到无节点可访问时返回上一个 “岔路口” 。</li><li>图的广度优先搜索（BFS）本质为迭代，使用队列结构，得到图的各个连通分量，可用于构建连通树与最小BFS生成树。直观来看，BFS为先遍历最近距离的节点，直到无节点可访问时扩大遍历范围。</li><li>连通图 G &#x3D;（V,E）有 $\mid E \mid&gt; \mid V \mid -1$, 则说明图中存在回路，生成树不唯一，其中权值最小的生成树为 G 的最小生成树。</li><li>普利姆算法（Prim）</li></ul><blockquote><p>① 设图 T（U，{}）为连通图 G（V，E）的最小生成树，从顶点$v_i$开始，U&#x3D;{$v_i$}。</p><p>② 在所有$u\in U,v\in V-U$的边$(u,v)\in E$中选择一条权值最小的边$(u_i,v_j)$, 将$v_j$与$(u_i,v_j)$加入 T 中, 即$T&#x3D;T\bigcup({v_j},{(u_i,v_j)})$。</p><p>③ 重复②，直到 U &#x3D; V。</p></blockquote><p>​<img src="https://img.hello-yzg.cn/CS联考+%23+数据结构-001.png" style="zoom: 100%;" /></p><center style="color:#C0C0C0">图1</center><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXEDGE 20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXVEX 20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIFINTY 65535</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> arc[MAXVEX][MAXVEX]; <span class="hljs-comment">//邻接矩阵</span><br>    <span class="hljs-type">int</span> numVertexes, numEdges;<br>&#125;MGraph;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构建图</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateMGraph</span><span class="hljs-params">(MGraph * G)</span>&#123;<br>    <br>    <span class="hljs-type">int</span> i, j;<br>    <br>    G-&gt;numVertexes = <span class="hljs-number">9</span>; <span class="hljs-comment">// 9个顶点</span><br>    G-&gt;numEdges = <span class="hljs-number">15</span>; <span class="hljs-comment">// 15条边</span><br>    <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;numVertexes; i++) &#123; <span class="hljs-comment">// 初始化图</span><br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; G-&gt;numVertexes; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i == j)<br>                G-&gt;arc[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>                G-&gt;arc[i][j] = G-&gt;arc[j][i] = INIFINTY;<br>        &#125;<br>    &#125;<br>    <br>    G-&gt;arc[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">10</span>;<br>    G-&gt;arc[<span class="hljs-number">0</span>][<span class="hljs-number">5</span>] = <span class="hljs-number">11</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">18</span>;<br>    G-&gt;arc[<span class="hljs-number">1</span>][<span class="hljs-number">8</span>] = <span class="hljs-number">12</span>;<br>    G-&gt;arc[<span class="hljs-number">1</span>][<span class="hljs-number">6</span>] = <span class="hljs-number">16</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">22</span>;<br>    G-&gt;arc[<span class="hljs-number">2</span>][<span class="hljs-number">8</span>] = <span class="hljs-number">8</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">20</span>;<br>    G-&gt;arc[<span class="hljs-number">3</span>][<span class="hljs-number">7</span>] = <span class="hljs-number">16</span>;<br>    G-&gt;arc[<span class="hljs-number">3</span>][<span class="hljs-number">6</span>] = <span class="hljs-number">24</span>;<br>    G-&gt;arc[<span class="hljs-number">3</span>][<span class="hljs-number">8</span>] = <span class="hljs-number">21</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">4</span>][<span class="hljs-number">5</span>] = <span class="hljs-number">26</span>;<br>    G-&gt;arc[<span class="hljs-number">4</span>][<span class="hljs-number">7</span>] = <span class="hljs-number">7</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>] = <span class="hljs-number">17</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">6</span>][<span class="hljs-number">7</span>] = <span class="hljs-number">19</span>;<br>    <br>    <span class="hljs-comment">// 利用邻接矩阵的对称性</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;numVertexes; i++)<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; G-&gt;numVertexes; j++)<br>            G-&gt;arc[j][i] = G-&gt;arc[i][j];<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Prime算法生成最小生成树</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MiniSpanTree_Prim</span><span class="hljs-params">(MGraph G)</span>&#123;<br>    <br>    <span class="hljs-type">int</span> min,i,j,k;<br>    <br>    <span class="hljs-comment">// 利用两个数组，保存边依附点与边的权值（生成树扩张新顶点可选择的边）</span><br>    <span class="hljs-type">int</span> adjvex[MAXVEX]; <span class="hljs-comment">// 保存最新的依附点集</span><br>    <span class="hljs-type">int</span> lowcost[MAXVEX]; <span class="hljs-comment">// 保存最新的权值集，数组下标为边的另一个依附点</span><br>    <br>    adjvex[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化，第一个顶点v0</span><br>    lowcost[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化, 第一个权值为0，即v0加入生成树</span><br>    <br>    <span class="hljs-comment">// 遍历v0之外的顶点</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; G.numVertexes; i++) &#123;<br>        adjvex[i] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 更新依附点集</span><br>        lowcost[i] = G.arc[<span class="hljs-number">0</span>][i];  <span class="hljs-comment">// 更新权值集</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 进行 numVertexes-1 次循环，锁定 numVertexes-1 条边</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; G.numVertexes; i++) &#123;<br>        min = INIFINTY; <span class="hljs-comment">// 初始化最小权值</span><br>        j = <span class="hljs-number">1</span>;<br>        k = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 找到当前权值集中的最小值</span><br>        <span class="hljs-keyword">while</span> (j &lt; G.numVertexes) &#123; <br>            <span class="hljs-keyword">if</span> (lowcost[j] != <span class="hljs-number">0</span> &amp;&amp; lowcost[j] &lt; min) &#123;<br>                min = lowcost[j];  <br>                k = j;  <span class="hljs-comment">// 将当前最小值对应的边依附点存入k</span><br>            &#125;<br>            j++;<br>        &#125;<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d, %d)\n&quot;</span>, adjvex[k], k); <span class="hljs-comment">// 打印锁定的权值最小的边</span><br>        lowcost[k] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 更新权值集，对应下标的权值记为0，即锁定了依附点，记为已处理</span><br>        <br>        <span class="hljs-comment">// 锁定边后，顶点k加入，生成树发生变化，需要更新依附点集和权值集</span><br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt; G.numVertexes; j++) &#123;  <br>            <br>            <span class="hljs-comment">// 比较从k点出发的扩张权，如果更小，则更新</span><br>            <span class="hljs-keyword">if</span> (lowcost[j]!= <span class="hljs-number">0</span> &amp;&amp; G.arc[k][j] &lt; lowcost[j]) &#123;<br>                adjvex[j] = k; <span class="hljs-comment">// 更新依附点k</span><br>                lowcost[j] = G.arc[k][j]; <span class="hljs-comment">// 将更小的权值存入lowcost对应位置</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span> &#123;<br>    <br>    MGraph G;<br>    CreateMGraph(&amp;G);<br>    MiniSpanTree_Prim(G);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">代码输出:</span><br><span class="hljs-comment">(0,1)</span><br><span class="hljs-comment">(0,5)</span><br><span class="hljs-comment">(1,8)</span><br><span class="hljs-comment">(8,2)</span><br><span class="hljs-comment">(1,6)</span><br><span class="hljs-comment">(6,7)</span><br><span class="hljs-comment">(7,4)</span><br><span class="hljs-comment">(7,3)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li>克鲁斯卡尔算法（Kruskal）</li></ul><blockquote><p>① 设图 T（V，{}）为连通图 G（V，E）的最小生成树，T 中每个顶点自成连通分量。</p><p>② 在 E 中选择权值最小的边，若该边的两个顶点落在 T 中不同的连通分量上，则将此边加入 T，否则舍弃该边。</p><p>③ 重复②，直到 T 中所有顶点在同一连通分量上。</p></blockquote><p>​<img src="https://img.hello-yzg.cn/CS联考+%23+数据结构-002.png" style="zoom: 100%;" /></p><center style="color:#C0C0C0">图2</center><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXEDGE 20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXVEX 20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INIFINTY 65535</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> arc[MAXVEX][MAXVEX]; <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-type">int</span> numVertexes, numEdges;<br>&#125;MGraph;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-comment">// 边集数组</span><br>    <span class="hljs-type">int</span> begin;<br>    <span class="hljs-type">int</span> end;<br>    <span class="hljs-type">int</span> weight;<br>&#125;Edge;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构建图</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateMGraph</span><span class="hljs-params">(MGraph * G)</span>&#123;<br>    <br>    <span class="hljs-type">int</span> i, j;<br>    <br>    G-&gt;numVertexes = <span class="hljs-number">9</span>; <span class="hljs-comment">// 9个顶点</span><br>    G-&gt;numEdges = <span class="hljs-number">15</span>; <span class="hljs-comment">// 15条边</span><br>    <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;numVertexes; i++) &#123; <span class="hljs-comment">// 初始化图</span><br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; G-&gt;numVertexes; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i == j)<br>                G-&gt;arc[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>                G-&gt;arc[i][j] = G-&gt;arc[j][i] = INIFINTY;<br>        &#125;<br>    &#125;<br>    <br>    G-&gt;arc[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">10</span>;<br>    G-&gt;arc[<span class="hljs-number">0</span>][<span class="hljs-number">5</span>] = <span class="hljs-number">11</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">18</span>;<br>    G-&gt;arc[<span class="hljs-number">1</span>][<span class="hljs-number">8</span>] = <span class="hljs-number">12</span>;<br>    G-&gt;arc[<span class="hljs-number">1</span>][<span class="hljs-number">6</span>] = <span class="hljs-number">16</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">22</span>;<br>    G-&gt;arc[<span class="hljs-number">2</span>][<span class="hljs-number">8</span>] = <span class="hljs-number">8</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">20</span>;<br>    G-&gt;arc[<span class="hljs-number">3</span>][<span class="hljs-number">7</span>] = <span class="hljs-number">16</span>;<br>    G-&gt;arc[<span class="hljs-number">3</span>][<span class="hljs-number">6</span>] = <span class="hljs-number">24</span>;<br>    G-&gt;arc[<span class="hljs-number">3</span>][<span class="hljs-number">8</span>] = <span class="hljs-number">21</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">4</span>][<span class="hljs-number">5</span>] = <span class="hljs-number">26</span>;<br>    G-&gt;arc[<span class="hljs-number">4</span>][<span class="hljs-number">7</span>] = <span class="hljs-number">7</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>] = <span class="hljs-number">17</span>;<br>    <br>    G-&gt;arc[<span class="hljs-number">6</span>][<span class="hljs-number">7</span>] = <span class="hljs-number">19</span>;<br>    <br>    <span class="hljs-comment">// 利用邻接矩阵的对称性</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G-&gt;numVertexes; i++)<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; G-&gt;numVertexes; j++)<br>            G-&gt;arc[j][i] = G-&gt;arc[i][j];<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 交换头、尾、权值，用于边集的有序化（采取冒泡排序）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Swapn</span><span class="hljs-params">(Edge * edges, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>    <br>    <span class="hljs-type">int</span> temp;<br>    temp = edges[i].begin;<br>    edges[i].begin = edges[j].begin;<br>    edges[j].begin = temp;<br>    <br>    temp = edges[i].end;<br>    edges[i].end = edges[j].end;<br>    edges[j].end = temp;<br>    <br>    temp = edges[i].weight;<br>    edges[i].weight = edges[j].weight;<br>    edges[j].weight = temp;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对权值进行排序——冒泡排序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Edge edges[], MGraph *G)</span>&#123;<br><br>    <span class="hljs-type">int</span> i,j;<br>    <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;  i &lt; G-&gt;numEdges; i++) &#123;<br>        <span class="hljs-keyword">for</span> (j = i+<span class="hljs-number">1</span>; j &lt; G-&gt;numEdges; j++) &#123;<br>            <span class="hljs-keyword">if</span> (edges[i].weight &gt; edges[j].weight)<br>                Swapn(edges, i, j);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;权值排序之后为：\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;  i &lt; G-&gt;numEdges; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d, %d) %d\n&quot;</span>, edges[i].begin, edges[i].end, edges[i].weight);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用 &quot;while&quot; 迭代查找连通分量的 &quot;最新顶点&quot; ，返回此顶点说明落在生成树连通分量中</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> * parent, <span class="hljs-type">int</span> f)</span>&#123;<br>    <br>    <span class="hljs-keyword">while</span> (parent[f] &gt; <span class="hljs-number">0</span>)<br>        f = parent[f];<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Kruskal算法生成最小生成树</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MiniSpanTree_Kruskal</span><span class="hljs-params">(MGraph G)</span>&#123;<br>    <br>    <span class="hljs-type">int</span> i,j,n,m;<br>    <br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>    <br>    Edge edges[MAXEDGE]; <span class="hljs-comment">// 定义边集数组</span><br>    <span class="hljs-type">int</span> parent[MAXVEX]; <span class="hljs-comment">// 定义连通分量判断数组来判断边与边是否形成回路</span><br>    <br>    <span class="hljs-comment">// 构建边集数组并排序</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G.numVertexes - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (j = i+<span class="hljs-number">1</span>; j &lt; G.numVertexes; j++) &#123;<br>            <span class="hljs-keyword">if</span> (G.arc[i][j] &lt; INIFINTY) &#123;<br>                edges[k].begin = i;<br>                edges[k].end = j;<br>                edges[k].weight = G.arc[i][j];<br>                k++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    sort(edges, &amp;G);<br>    <br>    <span class="hljs-comment">// 初始化回路判断数组</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G.numVertexes; i++) &#123;<br>        parent[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打印最小生成树:\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; G.numEdges; i++) &#123;<br>        n = Find(parent, edges[i].begin); <span class="hljs-comment">// 判断起点是否落在生成树连通分量中</span><br>        m = Find(parent, edges[i].end); <span class="hljs-comment">// 判断终点是否落在生成树连通分量中</span><br>        <br>        <span class="hljs-comment">// 未形成回路，可以加入</span><br>        <span class="hljs-keyword">if</span> (n != m) &#123;<br>            parent[n] = m; <span class="hljs-comment">// 更新连通分量判断数组</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d, %d) %d\n&quot;</span>,edges[i].begin, edges[i].end<br>                   , edges[i].weight);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span> &#123;<br>    <br>    MGraph G;<br>    CreateMGraph(&amp;G);<br>    MiniSpanTree_Kruskal(G);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>408</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数之和</title>
    <link href="/2023/dca8257178c4/"/>
    <url>/2023/dca8257178c4/</url>
    
    <content type="html"><![CDATA[<h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><blockquote><p>C++ Tips</p><ol><li><p>参数为引用时（&amp; 或 *），直接操作原始数据</p></li><li><p>C++11 引入 unordered_map（哈希表的数据结构）</p></li></ol></blockquote><p>题目：</p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。</p><h4 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h4><p>时间复杂度：O(<em>n</em>)</p><p>空间复杂度：O(<em>n</em>)</p><h5 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//c++</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hashtable;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">auto</span> it = hashtable.<span class="hljs-built_in">find</span>(target - nums[i]);<br>            <span class="hljs-keyword">if</span>(it != hashtable.<span class="hljs-built_in">end</span>())&#123;<br>                <span class="hljs-keyword">return</span> &#123;it-&gt;second, i&#125;;<br>            &#125;<br>            hashtable[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        Map&lt;Integer,Integer&gt; hashtable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i)&#123;<br>            <span class="hljs-keyword">if</span>(hashtable.containsKey(target-nums[i]))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;hashtable.get(target - nums[i]),i&#125;;<br>            &#125;<br>            hashtable.put(nums[i],i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="python"><a href="#python" class="headerlink" title="python"></a>python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#python3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        hashtable = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">if</span> target - num <span class="hljs-keyword">in</span> hashtable:<br>                <span class="hljs-keyword">return</span> [hashtable[target - num], i]<br>            hashtable[nums[i]] = i<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h5 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span> &#123;</span><br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> val;<br>    UT_hash_handle hh;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span>* <span class="hljs-title">hashtable</span>;</span><br><br><span class="hljs-keyword">struct</span> hashTable* <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> ikey)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span>* <span class="hljs-title">tmp</span>;</span><br>    HASH_FIND_INT(hashtable, &amp;ikey, tmp);<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> ikey, <span class="hljs-type">int</span> ival)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span>* <span class="hljs-title">it</span> =</span> find(ikey);<br>    <span class="hljs-keyword">if</span> (it == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span>* <span class="hljs-title">tmp</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> hashTable));<br>        tmp-&gt;key = ikey, tmp-&gt;val = ival;<br>        HASH_ADD_INT(hashtable, key, tmp);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        it-&gt;val = ival;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span>* <span class="hljs-title function_">twoSum</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span>* returnSize)</span> &#123;<br>    hashtable = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numsSize; i++) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hashTable</span>* <span class="hljs-title">it</span> =</span> find(target - nums[i]);<br>        <span class="hljs-keyword">if</span> (it != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-type">int</span>* ret = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">2</span>);<br>            ret[<span class="hljs-number">0</span>] = it-&gt;val, ret[<span class="hljs-number">1</span>] = i;<br>            *returnSize = <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>        insert(nums[i], i);<br>    &#125;<br>    *returnSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//javascript</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> twoSum = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) &#123;<br>    <span class="hljs-keyword">let</span> idx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; ; j++) &#123;<br>        <span class="hljs-keyword">const</span> x = nums[j];<br>        <span class="hljs-keyword">if</span> (idx.<span class="hljs-title function_">has</span>(target - x)) <br>            <span class="hljs-keyword">return</span> [idx.<span class="hljs-title function_">get</span>(target - x), j]; <br>        idx.<span class="hljs-title function_">set</span>(x, j); <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm Design</category>
      
      <category>LeetCode</category>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android 帧率获取</title>
    <link href="/2023/da0ce45cc34a/"/>
    <url>/2023/da0ce45cc34a/</url>
    
    <content type="html"><![CDATA[<h3 id="1-实时获取FPS"><a href="#1-实时获取FPS" class="headerlink" title="1. 实时获取FPS"></a>1. 实时获取FPS</h3><h4 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">DecimalFormat</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecimalFormat</span>(<span class="hljs-string">&quot;##0.00&quot;</span>);<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">MONITOR_INTERVAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">160L</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">MONITOR_INTERVAL_NANOS</span> <span class="hljs-operator">=</span> MONITOR_INTERVAL * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">mStartFrameTIme</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">mFrameCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getFps</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">//SDK版本小于JELLY_BEAN（Android 4.1）</span><br>    &#125;<br>    Choreographer.getInstance().postFrameCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Choreographer</span>.FrameCallback() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFrame</span><span class="hljs-params">(<span class="hljs-type">long</span> frameTimeNanos)</span> &#123;<br>            <span class="hljs-keyword">if</span> (mStartFrameTIme == <span class="hljs-number">0</span>) &#123;<br>                mStartFrameTIme = frameTimeNanos;<br>            &#125;<br>            <span class="hljs-type">float</span> <span class="hljs-variable">interval</span> <span class="hljs-operator">=</span> (frameTimeNanos - mStartFrameTIme) / <span class="hljs-number">1000000.0f</span>;<br>            <span class="hljs-keyword">if</span> (interval &gt; MONITOR_INTERVAL) &#123;<br>                <span class="hljs-type">double</span> <span class="hljs-variable">fps</span> <span class="hljs-operator">=</span> ((<span class="hljs-type">double</span>) mFrameCount * <span class="hljs-number">1000L</span>) / interval;<br>                Log.i(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;fps:&quot;</span> + format.format(FPS));<br>                mFrameCount = <span class="hljs-number">0</span>;<br>                mStartFrameTIme = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ++mFrameCount;<br>            &#125;<br>            Choreographer.getInstance().postFrameCallback(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//递归获取</span><br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-关闭-VSync-TBD"><a href="#2-关闭-VSync-TBD" class="headerlink" title="2. 关闭 VSync (TBD)"></a>2. 关闭 VSync (TBD)</h3><h3 id="3-在-GL-线程中自定义-FPS-TBD"><a href="#3-在-GL-线程中自定义-FPS-TBD" class="headerlink" title="3. 在 GL 线程中自定义 FPS (TBD)"></a>3. 在 GL 线程中自定义 FPS (TBD)</h3><h3 id="4-——-——-——"><a href="#4-——-——-——" class="headerlink" title="4. —— —— ——"></a>4. —— —— ——</h3>]]></content>
    
    
    <categories>
      
      <category>System Platform</category>
      
      <category>Android</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 中的特殊视图</title>
    <link href="/2023/34ae59f9ac53/"/>
    <url>/2023/34ae59f9ac53/</url>
    
    <content type="html"><![CDATA[<h3 id="SurfaceView-amp-TextureView"><a href="#SurfaceView-amp-TextureView" class="headerlink" title="SurfaceView &amp; TextureView"></a>SurfaceView &amp; TextureView</h3><h4 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h4><blockquote><p>在 SDK 的文档中，对 Surface 的描述是这样的：“Handle onto a raw buffer that is being managed by the screen compositor”，意思是 “由屏幕显示内容合成器所管理的原始缓冲区的句柄” 。所谓原始缓冲区，是用于保存当前窗口的像素数据的缓存空间，也就是说，通过 Surface 可以获取原始缓冲区以及其中的内容。Surface 对应一块屏幕缓冲区，每个 Window 对应一个 Surface，任何 View 都画在 Surface 上，Surface 中， 借助Canvas画图，原始缓冲区用来保存数据。从代码层面看，Surface 为 BufferQueue 的 Producer 接口实现类，使生产者可以通过它的软件或硬件渲染接口为其提供 GraphicBuffer。</p></blockquote><h4 id="SurfaceView"><a href="#SurfaceView" class="headerlink" title="SurfaceView"></a>SurfaceView</h4><blockquote><p>Surface View 从 Android 1.0 (API level 1) 时就有。它继承自类 View，因此它本质上是一个 View。但与普通 View 不同的是，它有自己的 Surface。我们知道，一般的 Activity 包含的多个 View 会组成 View hierarchy 的树形结构，只有最顶层的 DecorView，也就是根结点视图，才是对 WMS (Window Manager Service) 可见的。这个DecorView 在 WMS 中有一个对应的 WindowState。相应地，在 SF (Surface Flinger) 中对应的 Layer。而 SurfaceView 自带一个 Surface，这个 Surface 在 WMS 中有自己对应的 WindowState，在 SF 中也会有自己的 Layer。也就是说，虽然在 App 端它仍在 View hierarchy 中，但在 Server 端 (WMS和SF) 中，它与宿主窗口是分离的。这样的好处是对这个 Surface 的渲染可以放到单独线程去做，渲染时可以有自己的 GL context 。这对于一些游戏、视频等性能相关的应用非常有益，因为它不会影响主线程对事件的响应。但它也有缺点，因为这个 Surface 不在 View hierarchy 中，它的显示也不受 View 的属性控制，所以不能进行平移，缩放等变换，也不能放在其它 ViewGroup 中，一些 View 中的特性也无法使用，例如 View.setAlpha()。 从 Android7.0 开始，SurfaceView 的窗口位置与其他 View 渲染同步更新。这意味着在屏幕上平移和缩放 SurfaceView 不会导致渲染失真。</p></blockquote><p>​<img src="https://img.hello-yzg.cn/Android+%23+Surface+View+and+Texture+View-001.png" style="zoom: 150%;" /></p><center style="color:#C0C0C0">图1</center><hr><h6 id="个人理解（实现原理）："><a href="#个人理解（实现原理）：" class="headerlink" title="个人理解（实现原理）："></a>个人理解（实现原理）：</h6><p>SurfaceView 继承了 View 的部分特性，例如布局，事件响应等；同时</p><ul><li>持有一个单独的 Surface，重写了来自 View 的渲染实现，在自己的线程中进行绘制，不参与 UI 线程的绘制 Looper</li><li>双缓冲机制使它有两个独立的 GraphicBuffer (图像缓存区) ：frontBuffer 和 backBuffer，每次绘制时，将直接在backBuffer 中进行绘制，绘制完成后与frontBuffer进行交换，post 至 SurfaceFlinger 进行最终合成并显示</li><li>可以直接从内存或者DMA等硬件接口取得图像数据，提升性能</li></ul><h6 id="应用领域（设计需求）："><a href="#应用领域（设计需求）：" class="headerlink" title="应用领域（设计需求）："></a>应用领域（设计需求）：</h6><p>SurfaceView的以上特性使它成为显示实时视频流、游戏动画等需要频繁更新的图像内容的首选。</p><h4 id="GLSurfaceView"><a href="#GLSurfaceView" class="headerlink" title="GLSurfaceView"></a>GLSurfaceView</h4><blockquote><p>GLSurfaceView 从 Android 1.5 (API level 3) 开始加入 ，作为 SurfaceView 的补充。它可以看作是 SurfaceView 的一种典型使用模式。在 SurfaceView 的基础上，它加入了 EGL (Embedded Graphic Library) 的管理，并自带了渲染线程。另外它定义了用户需要实现的 Render 接口，提供了用 Strategy pattern 更改具体 Render 行为的灵活性。作为 GLSurfaceView 的 Client，只需要将实现了渲染函数的 Renderer 的实现类设置给 GLSurfaceView 即可。</p></blockquote><p>扩展 SurfaceView，可以调用 OpenGL ES 类库，多用于开发3D效果</p><h4 id="SurfaceTexture"><a href="#SurfaceTexture" class="headerlink" title="SurfaceTexture"></a>SurfaceTexture</h4><blockquote><p>SurfaceTexture 从 Android 3.0 (API level 11) 加入。和 SurfaceView 不同的是，它对图像流的处理并不直接显示，而是转为 GL 外部纹理 (External Texture)，因此可用于图像流数据的二次处理（如 Camera 滤镜，桌面特效等）。比如 Camera 的预览数据，变成纹理后可以交给 GLSurfaceView 直接显示，也可以通过 SurfaceTexture 交给 TextureView 作为 View hierarchy 中的一个硬件加速层来显示。首先，SurfaceTexture 从图像流 (来自 Camera 预览，视频解码，GL 绘制场景等) 中获得帧数据，当调用 updateTexImage() 时，根据内容流中最近的图像更新 SurfaceTexture 对应的 GL 纹理对象，接下来，就可以像操作普通 GL 纹理一样操作它了。它核心管理着一个 BufferQueue 的 Consumer 和 Producer 两端。Producer 端用于接收内容流的源输出数据，Consumer 端用于拿 GraphicBuffer 并生成纹理。SurfaceTexture.OnFrameAvailableListener 用于让 SurfaceTexture 的使用者知道有新数据到来。JNISurfaceTextureContext 是 OnFrameAvailableListener 从 Native 到 Java 的 JNI 跳板。其中 SurfaceTexture 中的attachToGLContext() 和 detachToGLContext() 可以让多个 GL context 共享同一个内容源。</p></blockquote><p>扩展 Surface，获取图像流后，不绘制 GraphicBuffer 提交 SF 合成，而是生成为 ExternalTexture 提交 GL 渲染。</p><h4 id="TextureView"><a href="#TextureView" class="headerlink" title="TextureView"></a>TextureView</h4><blockquote><p>TextureView 从 Android 4.0 (API level 14) 中引入。它可以将内容流直接投影到 View 中，可以用于实现 Live preview 等功能。和 SurfaceView 不同，它不会在 WMS 中单独创建窗口，而是作为 View hierachy 中的一个普通 View，因此可以和其它普通 View 一样进行移动，旋转，缩放，动画等变化。值得注意的是 TextureView 必须在硬件加速的窗口中。它显示的内容流数据可以来自 App 进程或是远端进程。TextureView 继承自 View，它与其它的 View 一样在 View hierarchy 中管理与绘制。TextureView 重载了 draw() 方法，其中主要把 SurfaceTexture 中收到的图像数据作为纹理更新到对应的 HardwareLayer 中。SurfaceTexture.OnFrameAvailableListener 用于通知 TextureView 内容流有新图像到来。SurfaceTextureListener 接口用于让TextureView 的使用者知道 SurfaceTexture 已准备好，这样就可以把 SurfaceTexture 交给相应的内容源。SurfaceTexture 可以用作非直接输出的内容流，这样就提供二次处理的机会。与 SurfaceView 直接输出相比，这样会有若干帧的延迟。同时，由于它本身管理 BufferQueue，因此内存消耗也会稍微大一些。</p></blockquote><h6 id="个人理解（实现原理）：-1"><a href="#个人理解（实现原理）：-1" class="headerlink" title="个人理解（实现原理）："></a>个人理解（实现原理）：</h6><p>TextureView 继承了 View 的大部分特性，例如布局，事件响应等；同时</p><ul><li>作为用于图像投影的普通 View 在 UI 线程中进行绘制，具有 view 的大部分特性</li><li>内容数据要先由 SurfaceTexture 输出为 GL 外部纹理，再加入 View hierachy 作为一个硬件加速层实现 GL 投影，复杂的数据交换导致了绘制延时</li><li>接收类型为外部纹理 (GL特有) 使得其本身必须能够与GPU进行数据交换，即开启硬件加速，开销较大</li></ul><h6 id="应用领域（设计需求）：-1"><a href="#应用领域（设计需求）：-1" class="headerlink" title="应用领域（设计需求）："></a>应用领域（设计需求）：</h6><p>SurfaceView的以上特性使它成为供 GL 进行图像内容再处理的首选，但并不常用。</p><h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><ul><li><p><strong>在 Android 7.0 上系统 SurfaceView 的性能比 TextureView 更有优势</strong>，支持对象的内容位置和包含的应用内容同步更新，平移、缩放不会产生黑边。 <strong>在7.0以下系统如果使用场景有动画效果，可以选择性使用 TextureView</strong>。</p></li><li><p>由于失效 (invalidation) 和缓冲的特性，<strong>TextureView 增加了额外1~3帧的延迟显示画面更新</strong>。</p></li><li><p>TextureView 总是使用 GL 合成，而 SurfaceView 可以使用硬件 overlay 后端，可以占用更少的内存。</p></li><li><p>TextureView 的内部缓冲队列导致比 SurfaceView 使用更多的内存。</p></li><li><p>SurfaceView 内部自持有 Surface，Surface 创建、销毁、改变时由系统处理，通过 SurfaceHolder  回调通知。</p></li><li><p>当画布创建好时，可以将 Surface 绑定到 MediaPlayer 中。SurfaceView 如果为用户可见的时候，创建 SurfaceView 的 SurfaceHolder 用于显示视频流解析的帧图片，如果发现 SurfaceView 变为用户不可见的时候，则立即销毁 SurfaceView 的 SurfaceHolder，以达到节约系统资源的目的。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>System Platform</category>
      
      <category>Android</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello C++ !</title>
    <link href="/2023/975ba186bf91/"/>
    <url>/2023/975ba186bf91/</url>
    
    <content type="html"><![CDATA[<h2 id="1-C-初识"><a href="#1-C-初识" class="headerlink" title="1. C++初识"></a>1. C++初识</h2><h3 id="1-1-HellofromC"><a href="#1-1-HellofromC" class="headerlink" title="1.1 HellofromC++"></a>1.1 HellofromC++</h3><h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><p>单行 &#x2F;&#x2F; </p><p>多行 &#x2F;*  *&#x2F;</p><h3 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h3><p>数据类型 变量名 &#x3D; 初始值；（写入内容，避免Null与Any）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//取变量名</span><br><span class="hljs-meta">#x  </span><br></code></pre></td></tr></table></figure><h3 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4 常量"></a>1.4 常量</h3><p>记录程序中不可更改的数据</p><h4 id="1-4-1-define-宏常量（预编译，不占用内存）"><a href="#1-4-1-define-宏常量（预编译，不占用内存）" class="headerlink" title="1.4.1 #define 宏常量（预编译，不占用内存）"></a>1.4.1 #define 宏常量（预编译，不占用内存）</h4><p>#define 常量名 常量值；</p><h4 id="1-4-2-const修饰的变量（编译，占用内存）"><a href="#1-4-2-const修饰的变量（编译，占用内存）" class="headerlink" title="1.4.2 const修饰的变量（编译，占用内存）"></a>1.4.2 const修饰的变量（编译，占用内存）</h4><p>变量定义前加const关键字，不可修改</p><h3 id="1-5-关键字"><a href="#1-5-关键字" class="headerlink" title="1.5 关键字"></a>1.5 关键字</h3><p>C++预先保留得标识符</p><h3 id="1-5-标识符命名规则"><a href="#1-5-标识符命名规则" class="headerlink" title="1.5 标识符命名规则"></a>1.5 标识符命名规则</h3><p>由字母、数字、下划线组成；第一个字符不能为数字；字母区分大小写</p><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><p>分配内存空间的关键字</p><h3 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h3><table><thead><tr><th>数据类型</th><th>占用空间</th><th>取值范围</th></tr></thead><tbody><tr><td>short，短整型</td><td>2B</td><td>-2^15~2^15-1</td></tr><tr><td>int，整型</td><td>4B</td><td>-2^31~2^31-1</td></tr><tr><td>long，长整型</td><td>4B (Windows，Linux-32位)， 8B（Linux-64位）</td><td>-2^31~2^31-1</td></tr><tr><td>long long，长长整型</td><td>8B</td><td>-2^63~2^63-1</td></tr></tbody></table><h3 id="2-2-sizeof关键字"><a href="#2-2-sizeof关键字" class="headerlink" title="2.2 sizeof关键字"></a>2.2 sizeof关键字</h3><p>sizeof (数据类型&#x2F;变量名)，单位为字节</p><h3 id="2-3-实型（浮点型）"><a href="#2-3-实型（浮点型）" class="headerlink" title="2.3 实型（浮点型）"></a>2.3 实型（浮点型）</h3><p>单精度 float  7位有效数字</p><p>双精度 double  15~16位有效数字</p><p>默认：C++输出实型 &lt;&#x3D; 6位有效数字</p><p>科学计数法  eg：  3e2 &#x3D; 3 * 10^2     3e-2 &#x3D; 3 * 0.1^2</p><h3 id="2-4-字符型"><a href="#2-4-字符型" class="headerlink" title="2.4 字符型"></a>2.4 字符型</h3><p>char  1B</p><p>表示形式为单引号，传入内存中为ASCII码，强转int后可查看, a - 97, A - 65</p><p>ASCII码：</p><p>​1.非打印控制字符：0~31，用于控制外围设备</p><p>​2.打印字符：32~126，键盘</p><h3 id="2-5-转义字符"><a href="#2-5-转义字符" class="headerlink" title="2.5 转义字符"></a>2.5 转义字符</h3><p>列举几项：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">\a  =  警报<br>\n  =  换行<br>\t  =  水平制表，跳至下一个tab（<span class="hljs-number">8</span>位光标）<br>\\  =  \<br>\<span class="hljs-string">&#x27;  =  &#x27;</span><br>\<span class="hljs-string">&quot;  =  &quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-6-字符串型"><a href="#2-6-字符串型" class="headerlink" title="2.6 字符串型"></a>2.6 字符串型</h3><p>本质为字符数组，表示形式为双引号</p><ul><li>C风格：char Name[] &#x3D; “……”</li><li>C++风格：string Name &#x3D; “……”</li></ul><h3 id="2-7-布尔类型-bool"><a href="#2-7-布尔类型-bool" class="headerlink" title="2.7 布尔类型 bool"></a>2.7 布尔类型 bool</h3><p>bool类型占1B，只有两个值</p><ul><li>true  —真 （本质为1）</li><li>false —假 （本质为0）</li></ul><h3 id="2-8-数据输入"><a href="#2-8-数据输入" class="headerlink" title="2.8 数据输入"></a>2.8 数据输入</h3><p>从键盘获取数据</p><p>cin &gt;&gt; 变量</p><h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h2><p>执行代码的运算</p><table><thead><tr><th>运算符类型</th><th>作用</th></tr></thead><tbody><tr><td>算术运算符</td><td>四则运算</td></tr><tr><td>赋值运算符</td><td>表达式给变量赋值</td></tr><tr><td>比较运算符</td><td>比较表达式，返回真&#x2F;假</td></tr><tr><td>逻辑运算符</td><td>逻辑运算，返回真&#x2F;假</td></tr></tbody></table><h3 id="3-1-算数运算符"><a href="#3-1-算数运算符" class="headerlink" title="3.1 算数运算符"></a>3.1 算数运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">+ - * / % ++ --<br></code></pre></td></tr></table></figure><p>除法运算除数 !&#x3D; 0</p><p>小数不可取模运算</p><p>a++: 存储变量a，对变量a进行递增（副本），语句结束赋值回a</p><p>++a: 对变量a进行递增</p><h3 id="3-2-赋值运算符"><a href="#3-2-赋值运算符" class="headerlink" title="3.2 赋值运算符"></a>3.2 赋值运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">= += -= *= /= %=<br></code></pre></td></tr></table></figure><h3 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">== != &gt; &lt; &gt;= &lt;=<br></code></pre></td></tr></table></figure><p>结果为0或1</p><h3 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h3><table><thead><tr><th>运算符</th><th>术语</th><th>结果</th></tr></thead><tbody><tr><td>！</td><td>非</td><td>a为假，!a为真；a为真，!a为假</td></tr><tr><td>&amp;&amp;</td><td>与</td><td>a与b都为真，a&amp;&amp;b为真，否则为假</td></tr><tr><td>||</td><td>或</td><td>a与b都为假，a||b为假，否则为真</td></tr></tbody></table><h2 id="4-程序流程结构"><a href="#4-程序流程结构" class="headerlink" title="4. 程序流程结构"></a>4. 程序流程结构</h2><p>三种基本的程序运行结构：</p><ul><li>顺序结构：顺序执行，不发生跳转</li><li>选择结构：依据条件选择执行</li><li>循环结构：依据条件循环执行</li></ul><h3 id="4-1-选择结构"><a href="#4-1-选择结构" class="headerlink" title="4.1 选择结构"></a>4.1 选择结构</h3><h4 id="4-1-1-if语句"><a href="#4-1-1-if语句" class="headerlink" title="4.1.1 if语句"></a>4.1.1 if语句</h4><ul><li>单行格式if语句</li><li>多行格式if语句</li><li>多条件的if语句</li></ul><h4 id="4-1-2-三目运算符"><a href="#4-1-2-三目运算符" class="headerlink" title="4.1.2 三目运算符"></a>4.1.2 三目运算符</h4><p>取 MAX(a, b) 赋值于 c</p><ul><li>c &#x3D; a &gt; b ? a : b</li></ul><h4 id="4-1-3-switch语句"><a href="#4-1-3-switch语句" class="headerlink" title="4.1.3 switch语句"></a>4.1.3 switch语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span>(表达式：整型或字符型)&#123;<br><span class="hljs-keyword">case</span> 结果<span class="hljs-number">1</span>: 执行语句; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> 结果<span class="hljs-number">2</span>: 执行语句; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> 结果<span class="hljs-number">3</span>: 执行语句; <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>: 执行语句; <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结构清晰，执行效率高</p><h3 id="4-2-循环结构"><a href="#4-2-循环结构" class="headerlink" title="4.2 循环结构"></a>4.2 循环结构</h3><h4 id="4-2-1-while循环语句"><a href="#4-2-1-while循环语句" class="headerlink" title="4.2.1 while循环语句"></a>4.2.1 while循环语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(循环条件)&#123;循环语句&#125;<br></code></pre></td></tr></table></figure><p>只要循环条件的结果为真，就执行循环语句</p><p>注意事项：避免死循环的出现，即必须提供退出循环的接口</p><ul><li><p>案例：猜数字 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<span class="hljs-comment">//根据系统时间生成随机数</span><br><br><span class="hljs-type">int</span> num = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span>; <span class="hljs-comment">//生成0~99随机数(伪随机数)</span><br>cout &lt;&lt; num &lt;&lt; endl;<br><br><span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>cin &gt;&gt; val;<br><span class="hljs-keyword">if</span> (val &gt; num) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;猜测过大&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &lt; num) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;猜测过小&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;您猜对了&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//跳出当前循环</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-2-2-do……while循环语句"><a href="#4-2-2-do……while循环语句" class="headerlink" title="4.2.2 do……while循环语句"></a>4.2.2 do……while循环语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span>&#123;循环语句&#125;<span class="hljs-keyword">while</span>(循环条件)<br></code></pre></td></tr></table></figure><p>与while语句的区别为先执行一次循环语句，再判断循环条件</p><ul><li><p>案例：水仙花数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> num = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-type">int</span> a = num % <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = num / <span class="hljs-number">10</span> % <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> c = num / <span class="hljs-number">10</span> / <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> d = a*a*a + b*b*b + c*c*c;<br>    <span class="hljs-keyword">if</span> (num == d) &#123;<br>        cout &lt;&lt; num &lt;&lt; endl;<br>    &#125;<br>    num++;<br>&#125; <span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-2-3-for循环语句"><a href="#4-2-3-for循环语句" class="headerlink" title="4.2.3 for循环语句"></a>4.2.3 for循环语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(起始表达式；条件表达式；末尾循环体)&#123;循环语句&#125;<br></code></pre></td></tr></table></figure><ul><li>案例：敲桌子</li></ul><h4 id="4-2-4-嵌套循环"><a href="#4-2-4-嵌套循环" class="headerlink" title="4.2.4 嵌套循环"></a>4.2.4 嵌套循环</h4><p>在循环中嵌套循环，用于处理“多维”问题</p><p>外层执行一次，内层执行一周</p><ul><li><p>案例：乘法口诀表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; ++i) <span class="hljs-comment">//行&#123;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) <span class="hljs-comment">//列&#123;</span><br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; i * j&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-3-跳转语句"><a href="#4-3-跳转语句" class="headerlink" title="4.3 跳转语句"></a>4.3 跳转语句</h3><h4 id="4-3-1-break语句"><a href="#4-3-1-break语句" class="headerlink" title="4.3.1 break语句"></a>4.3.1 break语句</h4><p>使用时机：</p><ul><li>switch选择语句</li><li>循环语句</li></ul><h4 id="4-3-2-continue语句"><a href="#4-3-2-continue语句" class="headerlink" title="4.3.2 continue语句"></a>4.3.2 continue语句</h4><p>在循环语句中，跳过本次循环，继续执行下一次循环</p><h4 id="4-3-3-goto语句"><a href="#4-3-3-goto语句" class="headerlink" title="4.3.3 goto语句"></a>4.3.3 goto语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">goto</span> 标记；<br></code></pre></td></tr></table></figure><p>标记格式为 标记名 + “:”</p><p>若标记存在，则跳转到标记的位置</p><p>不推荐使用，会破环程序空间局部性和代码结构</p><h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>存放相同类型数据的集合</p><ul><li>特点1：每个数据元素的类型相同</li><li>特点2：物理上，内存连续</li></ul><h3 id="5-2-一维数组"><a href="#5-2-一维数组" class="headerlink" title="5.2 一维数组"></a>5.2 一维数组</h3><h4 id="5-2-1-一维数组的定义方式"><a href="#5-2-1-一维数组的定义方式" class="headerlink" title="5.2.1 一维数组的定义方式"></a>5.2.1 一维数组的定义方式</h4><p>三种定义方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span> 数据类型 数组名[数组长度]；<br><br><span class="hljs-comment">//定义时初始化，未初始化的内存会分配 0</span><br><span class="hljs-number">2.</span> 数据类型 数组名[数组长度] = &#123;值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>，值<span class="hljs-number">3</span>，......&#125;<br><span class="hljs-number">3.</span> 数据类型 数组名[] = &#123;值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>，值<span class="hljs-number">3</span>，......&#125;<br><br>eg:  <span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>];<br>通过下标（[序号]，从<span class="hljs-number">0</span>开始）访存，arr[<span class="hljs-number">0</span>]，arr[<span class="hljs-number">1</span>]，arr[<span class="hljs-number">2</span>]，......<br></code></pre></td></tr></table></figure><h4 id="5-2-2-一维数组的数组名"><a href="#5-2-2-一维数组的数组名" class="headerlink" title="5.2.2 一维数组的数组名"></a>5.2.2 一维数组的数组名</h4><ul><li>统计数组长度                                            sizeof(arr)</li><li>获取数组首地址或首元素地址                 arr</li></ul><p>数组名为常量，不可被赋值</p><ul><li><p>案例：五只小猪称体重</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">300</span>,<span class="hljs-number">350</span>,<span class="hljs-number">200</span>,<span class="hljs-number">400</span>,<span class="hljs-number">250</span> &#125;;<br><span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] &gt; max)&#123;<br>        max = arr[i];<br>    &#125;<br>&#125;<br>cout &lt;&lt; max &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li><li><p>案例：数组逆置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;; <span class="hljs-comment">//目标数组</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;逆置前：&quot;</span>  &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i)&#123;<br>    cout &lt;&lt; arr[i] &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; <span class="hljs-comment">//首指针</span><br><span class="hljs-type">int</span> end = <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>; <span class="hljs-comment">//尾指针</span><br><span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>    <span class="hljs-type">int</span> temp = arr[start];<br>    arr[start] = arr[end];<br>    arr[end] = temp;<br>    ++start;<br>    --end;<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;逆置后：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i)&#123;<br>    cout &lt;&lt; arr[i] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="5-2-3-冒泡排序"><a href="#5-2-3-冒泡排序" class="headerlink" title="5.2.3 冒泡排序"></a>5.2.3 冒泡排序</h4><p>对数组内的元素进行排序，具体执行：</p><ol><li>比较相邻的元素，通过交换保证较大元素右侧</li><li>一轮过后，会得到最大元素（尾元素）——”冒泡“</li><li>重复以上步骤，但比较次数-1，因为最大元素已经确定</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span> &#125;;<br>cout &lt;&lt; <span class="hljs-string">&quot;排序前：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i)&#123;<br>    cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//冒泡排序执行 [9-1=8] 轮，每轮确定一个最大值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i) &#123;<br>    <span class="hljs-comment">//每轮执行 [当前元素个数-1] 次对比</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span> - i - <span class="hljs-number">1</span>; ++j) &#123;<br>        <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-type">int</span> temp = arr[j];<br>            arr[j] = arr[j+<span class="hljs-number">1</span>];<br>            arr[j+<span class="hljs-number">1</span>] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;排序后：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i) &#123;<br>    cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-二维数组"><a href="#5-3-二维数组" class="headerlink" title="5.3 二维数组"></a>5.3 二维数组</h3><p>增加数组维度</p><h4 id="5-3-1-二维数组的定义方式"><a href="#5-3-1-二维数组的定义方式" class="headerlink" title="5.3.1 二维数组的定义方式"></a>5.3.1 二维数组的定义方式</h4><p>四种定义方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span> 数据类型 数组名[行数][列数]；<br><span class="hljs-number">2.</span> 数据类型 数组名[行数][列数] = <span class="hljs-comment">//推荐使用</span><br>&#123; <br>&#123;值<span class="hljs-number">0</span>_1，值<span class="hljs-number">0</span>_2，......&#125;，<br>&#123;值<span class="hljs-number">1</span>_1，值<span class="hljs-number">1</span>_2，......&#125;，<br>......<br>&#125;；<br><span class="hljs-number">3.</span> 数据类型 数组名[行数][列数] = &#123;值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>，值<span class="hljs-number">3</span>，值<span class="hljs-number">4</span>，......&#125;；<br><span class="hljs-number">4.</span> 数据类型 数组名[][列数] = &#123;值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>，值<span class="hljs-number">3</span>，值<span class="hljs-number">4</span>，......&#125;；<br><br>eg:  <span class="hljs-type">int</span> arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]<br>通过下标（[行号][列号]，从<span class="hljs-number">0</span>开始）访存，arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]，arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]，arr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]，......<br></code></pre></td></tr></table></figure><h4 id="5-3-2-二维数组的数组名"><a href="#5-3-2-二维数组的数组名" class="headerlink" title="5.3.2 二维数组的数组名"></a>5.3.2 二维数组的数组名</h4><ul><li>统计数组长度                                                              sizeof(arr)</li><li>统计数组每行长度                                                      sizeof(arr[行号])</li><li>获取数组首地址或首行地址或首元素地址                arr</li></ul><p>数组名为常量，不可被赋值</p><h4 id="5-3-3-二维数组应用案例"><a href="#5-3-3-二维数组应用案例" class="headerlink" title="5.3.3 二维数组应用案例"></a>5.3.3 二维数组应用案例</h4><p>考试成绩统计</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>]=<br>&#123;<br>&#123; <span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span> &#125;,<br>&#123; <span class="hljs-number">90</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span> &#125;,<br>&#123; <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; ++j)&#123;<br>        sum += arr[i][j];<br>        cout &lt;&lt; arr[i][j] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;第 &quot;</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;个同学的总分为：&quot;</span> &lt;&lt; sum &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p>将一段经常使用的代码封装起来，减少重复代码——程序块</p><h3 id="6-2-函数的定义"><a href="#6-2-函数的定义" class="headerlink" title="6.2 函数的定义"></a>6.2 函数的定义</h3><p>函数的定义一般分为五部分：</p><ol><li>返回值类型</li><li>函数名</li><li>参数声明列表——形参</li><li>函数体语句</li><li>return表达式</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">返回值类型 函数名 （参数声明列表）&#123;<br>函数体语句；<br><span class="hljs-keyword">return</span>表达式；<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-函数的调用"><a href="#6-3-函数的调用" class="headerlink" title="6.3 函数的调用"></a>6.3 函数的调用</h3><p>传入具体的参数——实参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">函数名（参数值列表）；<br></code></pre></td></tr></table></figure><p>调用时，实参的值会传递给形参</p><h3 id="6-4-值传递"><a href="#6-4-值传递" class="headerlink" title="6.4 值传递"></a>6.4 值传递</h3><p>函数调用时，实参的值会传递给形参，并不受形参的影响</p><h3 id="6-5-函数的常见样式"><a href="#6-5-函数的常见样式" class="headerlink" title="6.5 函数的常见样式"></a>6.5 函数的常见样式</h3><p>常见的函数样式有四种：</p><ol><li>无参无返</li><li>有参无返</li><li>无参有返</li><li>有参有返</li></ol><h3 id="6-6-函数的声明"><a href="#6-6-函数的声明" class="headerlink" title="6.6 函数的声明"></a>6.6 函数的声明</h3><p>向编译器声明函数信息（一般情况下代码逐行执行，意味着函数定义必须写于调用之前，为了改善这种强秩序，引入声明机制）</p><p>函数的实际主体可以单独定义，但必须唯一</p><h3 id="6-7-函数的分文件编写"><a href="#6-7-函数的分文件编写" class="headerlink" title="6.7 函数的分文件编写"></a>6.7 函数的分文件编写</h3><p>让代码结构更加清晰，一般分为四个步骤：</p><ol><li>创建后缀为.hpp的头文件</li><li>创建后缀为.cpp的源文件</li><li>在头文件中写函数的声明</li><li>在源文件中写函数的定义</li></ol><p>通过  #include ”……“  包含自定义的头文件</p><h2 id="7-指针"><a href="#7-指针" class="headerlink" title="7. 指针"></a>7. 指针</h2><h3 id="7-1-指针的基本概念"><a href="#7-1-指针的基本概念" class="headerlink" title="7.1 指针的基本概念"></a>7.1 指针的基本概念</h3><p>可以通过指针间接访问内存</p><ul><li>内存编号从0开始记录，为十六进制数字</li><li>指针变量用于保存地址</li><li>指针本质上是一个对象</li></ul><h3 id="7-2-指针变量的定义和使用"><a href="#7-2-指针变量的定义和使用" class="headerlink" title="7.2 指针变量的定义和使用"></a>7.2 指针变量的定义和使用</h3><p>指针类型声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">数据类型* 指针变量名；<br>数据类型* 指针变量名 = 指针变量；<br></code></pre></td></tr></table></figure><p>取地址与解地址：</p><p>符号* 本质上为算术运算符，即先查左值后查右值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">数据类型 数据变量名；<br>*数据变量名   <span class="hljs-comment">//取地址为指针类型</span><br><br>指针类型 指针变量名；<br>&amp;指针变量名   <span class="hljs-comment">//解地址为数据类型</span><br></code></pre></td></tr></table></figure><h3 id="7-3-指针所占内存空间"><a href="#7-3-指针所占内存空间" class="headerlink" title="7.3 指针所占内存空间"></a>7.3 指针所占内存空间</h3><p>32位操作系统下：占用4字节内存空间</p><p>64位操作系统下：占用8字节内存空间</p><h3 id="7-4-空指针和野指针"><a href="#7-4-空指针和野指针" class="headerlink" title="7.4 空指针和野指针"></a>7.4 空指针和野指针</h3><ul><li>空指针：指针变量指向内存中编号为0的空间——指针初始状态</li></ul><p>空指针指向的内存不可访问（0~255内存编号由系统使用）</p><ul><li>野指针：指针变量指向非法空间</li></ul><ol><li>指针未初始化</li><li>指针局部初始化</li></ol><p>野指针指向内存不可访问（无访问权限）</p><h3 id="7-5-const修饰指针"><a href="#7-5-const修饰指针" class="headerlink" title="7.5 const修饰指针"></a>7.5 const修饰指针</h3><p>const关键字 修饰变量</p><p>*运算符 对右侧变量 (地址) 取值；为右侧变量赋左侧类型的地址——指针声明)</p><ol><li>const修饰指针：常量指针（底层const）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p = &amp;a; <span class="hljs-comment">//const右侧为数据类型（默认变量入栈），const修饰此变量，约束数据   int const* p</span><br>p = &amp;b; <br></code></pre></td></tr></table></figure><ol start="2"><li>const修饰常量：指针常量（顶层const）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a; <span class="hljs-comment">//const右侧为指针变量（指针变量入栈），const修饰指针变量，约束指针  </span><br>*p = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>const既修饰指针又修饰常量</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a; <span class="hljs-comment">//完全约束</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;思考：*运算符本质为重载&#x3D;&#x3D;</p><ol><li><p>&#x3D;&#x3D;左侧为类型，右侧为变量时：指针声明，将左侧默认变量取地址赋给指针变量&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;仅右侧为变量时：解地址&#x3D;&#x3D;</p></li></ol><h3 id="7-6-指针和数组"><a href="#7-6-指针和数组" class="headerlink" title="7.6 指针和数组"></a>7.6 指针和数组</h3><p>利用指针访问数组中的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;<br>cout &lt;&lt; arr[<span class="hljs-number">0</span>] &lt;&lt; endl;                 <span class="hljs-comment">//打印 1</span><br>cout &lt;&lt; *arr &lt;&lt; endl;                   <span class="hljs-comment">//打印 1</span><br><span class="hljs-type">int</span>*p = arr;                            <span class="hljs-comment">//数组名arr不能被修改</span><br>p++;<br>cout &lt;&lt; *p &lt;&lt; endl;                     <span class="hljs-comment">//打印 2，若打印*p++或*(p++) 仍为1</span><br></code></pre></td></tr></table></figure><h3 id="7-7-指针和函数"><a href="#7-7-指针和函数" class="headerlink" title="7.7 指针和函数"></a>7.7 指针和函数</h3><p>利用指针传入函数修改实参的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> temp = *p1;<br>*p1 = * p2;<br>*p2 = temp;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;运算的本质就是操作地址，传入指针相当于自己拥有操作权，否则为系统默认&#x3D;&#x3D;</p><h3 id="7-8-指针和函数"><a href="#7-8-指针和函数" class="headerlink" title="7.8 指针和函数"></a>7.8 指针和函数</h3><p>案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> len)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; ++j) &#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br><span class="hljs-type">int</span> temp = arr[j];<br>arr[j] = arr[j + <span class="hljs-number">1</span>];<br>arr[j + <span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8. 结构体"></a>8. 结构体</h2><h3 id="8-1-结构体基本概念"><a href="#8-1-结构体基本概念" class="headerlink" title="8.1 结构体基本概念"></a>8.1 结构体基本概念</h3><p>结构体属于用户自定义的数据类型，允许用户存储不同的数据类型</p><h3 id="8-2-结构体定义和使用"><a href="#8-2-结构体定义和使用" class="headerlink" title="8.2 结构体定义和使用"></a>8.2 结构体定义和使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> 结构体名 &#123;<br>类型名 成员<span class="hljs-number">1</span>；<br>    类型名 成员<span class="hljs-number">2</span>；<br>    ......<br>&#125;;<br></code></pre></td></tr></table></figure><p>通过结构体创建变量的方式有三种：</p><p>struct 关键字可以省略</p><ul><li>struct 结构体名 变量名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> 结构体名 变量名；<br><span class="hljs-comment">//结构体变量名.成员名 可以访问结构体成员</span><br>变量名.成员<span class="hljs-number">1</span> = ...；<br>变量名.成员<span class="hljs-number">2</span> = ...；<br>......<br></code></pre></td></tr></table></figure><ul><li>struct 结构体名 变量名 &#x3D; {成员1的值，成员2的值，……}</li><li>定义结构体时同步创建变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> 结构体名 &#123;<br>类型名 成员<span class="hljs-number">1</span>；<br>    类型名 成员<span class="hljs-number">2</span>；<br>    ......<br>&#125; 变量名;<br></code></pre></td></tr></table></figure><h3 id="8-3-结构体数组"><a href="#8-3-结构体数组" class="headerlink" title="8.3 结构体数组"></a>8.3 结构体数组</h3><p>将自定义结构体作为数组元素.</p><h3 id="8-4-结构体指针"><a href="#8-4-结构体指针" class="headerlink" title="8.4 结构体指针"></a>8.4 结构体指针</h3><p>通过指针访问结构体成员.</p><ul><li>利用操作符 -&gt; 可以通过结构体指针访问结构体属性.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">struct</span> 结构体名 指针变量名 = &amp;变量名；<br><br><span class="hljs-comment">//结构体指针变量名-&gt;成员名 可以访问结构体成员</span><br>变量名-&gt;成员<span class="hljs-number">1</span> = ...；<br>变量名-&gt;成员<span class="hljs-number">2</span> = ...；<br>......<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;变量未初始化时，C++的行为是未知的，编译器通常会用error来制止这一行为.&#x3D;&#x3D;</p><h3 id="8-5-结构体嵌套结构体"><a href="#8-5-结构体嵌套结构体" class="headerlink" title="8.5 结构体嵌套结构体"></a>8.5 结构体嵌套结构体</h3><p>结构体中的成员可以是另一个结构体  </p><h3 id="8-6-结构体做函数参数"><a href="#8-6-结构体做函数参数" class="headerlink" title="8.6 结构体做函数参数"></a>8.6 结构体做函数参数</h3><p>将结构体作为参数向函数中传递.</p><ul><li>值传递</li><li>地址传递</li></ul><h3 id="8-7-结构体中const使用场景"><a href="#8-7-结构体中const使用场景" class="headerlink" title="8.7 结构体中const使用场景"></a>8.7 结构体中const使用场景</h3><p>使用地址传递节省传递开销，为了只读，需要使用const修饰.</p><h3 id="8-8-结构体案例"><a href="#8-8-结构体案例" class="headerlink" title="8.8 结构体案例"></a>8.8 结构体案例</h3><p>使用地址传递节省传递开销，为了只读，需要使用const修饰.</p><h4 id="8-8-1-案例一"><a href="#8-8-1-案例一" class="headerlink" title="8.8.1 案例一"></a>8.8.1 案例一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>string sName;<br><span class="hljs-type">int</span> score;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Teacher</span> &#123;<br>string tName;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> sArray[<span class="hljs-number">5</span>];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">allocate_print</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Teacher tArray[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>string nameSeed = <span class="hljs-string">&quot;ABCDE&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>tArray[i].tName = <span class="hljs-string">&quot;Teacher_&quot;</span>;<br>tArray[i].tName += nameSeed[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;老师姓名：&quot;</span> &lt;&lt; tArray[i].tName &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; ++j) &#123;<br>tArray[i].sArray[j].sName = <span class="hljs-string">&quot;Student_&quot;</span>;<br>tArray[i].sArray[j].sName += nameSeed[j];<br><span class="hljs-type">int</span> random = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>;<br>tArray[i].sArray[j].score = random;<br>cout &lt;&lt; <span class="hljs-string">&quot;\t学生姓名&quot;</span> &lt;&lt; tArray[i].sArray[j].sName <br>                 &lt;&lt; <span class="hljs-string">&quot; 考试分数：&quot;</span> &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Teacher</span> tArray[<span class="hljs-number">3</span>];<br><span class="hljs-built_in">allocate_print</span>(tArray, <span class="hljs-built_in">size</span>(tArray));<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="8-8-2-案例二"><a href="#8-8-2-案例二" class="headerlink" title="8.8.2 案例二"></a>8.8.2 案例二</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hero</span> &#123;<br>string name;<br><span class="hljs-type">int</span> age;<br>    string sex;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort_print</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Hero heroArray[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; ++j) &#123;<br><span class="hljs-keyword">if</span> (heroArray[j].age &gt; heroArray[j + <span class="hljs-number">1</span>].age) &#123;<br><span class="hljs-type">int</span> temp = heroArray[j];<br>heroArray[j] = heroArray[j+<span class="hljs-number">1</span>];<br>heroArray[j+<span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>&#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span>&lt;&lt; heroArray[i].name<br>             &lt;&lt; <span class="hljs-string">&quot;年龄：&quot;</span>&lt;&lt; heroArray[i].age<br>             &lt;&lt; <span class="hljs-string">&quot;性别：&quot;</span>&lt;&lt; heroArray[i].sex &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Hero</span> heroArray[<span class="hljs-number">5</span>] = <br>    &#123;<br>        &#123;<span class="hljs-string">&quot;刘备&quot;</span>，<span class="hljs-number">23</span>，<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;关羽&quot;</span>，<span class="hljs-number">22</span>，<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;张飞&quot;</span>，<span class="hljs-number">20</span>，<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;吕布&quot;</span>，<span class="hljs-number">21</span>，<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;貂蝉&quot;</span>，<span class="hljs-number">19</span>，<span class="hljs-string">&quot;女&quot;</span>&#125;,   <br>    &#125;;<br>    <span class="hljs-built_in">bubbleSort_print</span>(heroArray,<span class="hljs-built_in">size</span>(heroArray));<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Program Language</category>
      
      <category>C++</category>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
